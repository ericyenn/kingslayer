<roblox version="4">
  <Item class="Lighting" referent="0">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0</R>
        <G>0</G>
        <B>0</B>
      </Color3>
      <float name="Brightness">2</float>
      <bool name="GlobalShadows">true</bool>
      <bool name="Outlines">false</bool>
      <token name="Technology">1</token>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">EnemyModels</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="3">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">ActionConstants</string>
          <string name="Source"><![CDATA[-- Action constants to eliminate magic strings and provide centralized action names
local ActionConstants = {}

-- Tool Actions (simplified to one generic attack)
ActionConstants.Tool = {
    ATTACK = "tool_attack",
    DEFAULT = "default_action"
}

-- Armor Actions (no click actions, only equip system)
ActionConstants.Armor = {
    DEFAULT = "default_action"
}

-- Functional Item Actions (placeholder for future customization)
ActionConstants.Functional = {
    HEALING_ESSENCE = "healing_essence_action",
    SUMMONER = "summoner_action",
    REVIVE_PLUSH = "revive_plush_action",
    DEFAULT = "default_action"
}

-- General Actions (used across categories)
ActionConstants.General = {
    DEFAULT = "default_action"
}

-- Helper function to get all action names for a category
function ActionConstants.GetAllActions(category)
    if category == "Tool" then
        return ActionConstants.Tool
    elseif category == "Armor" then
        return ActionConstants.Armor
    elseif category == "Functional" then
        return ActionConstants.Functional
    else
        return ActionConstants.General
    end
end

-- Helper function to validate action name exists
function ActionConstants.IsValidAction(actionName, category)
    local categoryActions = ActionConstants.GetAllActions(category)
    
    for _, validAction in pairs(categoryActions) do
        if validAction == actionName then
            return true
        end
    end
    
    return false
end

-- Helper function to get default action for category
function ActionConstants.GetDefaultAction(category)
    local categoryActions = ActionConstants.GetAllActions(category)
    return categoryActions.DEFAULT or ActionConstants.General.DEFAULT
end

return ActionConstants ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">ActionRegistry</string>
          <string name="Source"><![CDATA[-- Shared action registry system for consistent action handling across all systems
local ActionRegistry = {}

-- Create a new action registry instance
function ActionRegistry.new(systemName)
    local registry = {
        systemName = systemName or "Unknown",
        actions = {},
        defaultAction = nil
    }
    
    -- Set a default action for this registry
    function registry:SetDefaultAction(actionFunction)
        self.defaultAction = actionFunction
    end
    
    -- Register an action with this registry
    function registry:RegisterAction(actionName, actionFunction)
        if type(actionName) ~= "string" then
            error(self.systemName .. ": Action name must be a string")
        end
        if type(actionFunction) ~= "function" then
            error(self.systemName .. ": Action function must be a function")
        end
        
        self.actions[actionName] = actionFunction
        print(self.systemName .. ": Registered action:", actionName)
    end
    
    -- Execute an action by name with consistent error handling
    function registry:ExecuteAction(actionName, player, itemDef, target, actionData, extraParam)
        -- Validate inputs
        if not actionName then
            warn(self.systemName .. ": No action name provided")
            return false
        end
        
        if not itemDef then
            warn(self.systemName .. ": No item definition provided")
            return false
        end
        
        -- Try to find the action
        local actionFunction = self.actions[actionName]
        
        if actionFunction then
            -- Execute with error handling
            local success, errorMessage = pcall(function()
                actionFunction(player, itemDef, target, actionData, extraParam)
            end)
            
            if not success then
                warn(self.systemName .. ": Error executing action", actionName .. ":", errorMessage)
                return false
            end
            
            return true
        else
            -- Try default action if available
            if self.defaultAction then
                print(self.systemName .. ": Unknown action", actionName, "- using default")
                
                local success, errorMessage = pcall(function()
                    self.defaultAction(player, itemDef, target, actionData, extraParam)
                end)
                
                if not success then
                    warn(self.systemName .. ": Error executing default action:", errorMessage)
                    return false
                end
                
                return true
            else
                warn(self.systemName .. ": Unknown action", actionName, "and no default action available")
                return false
            end
        end
    end
    
    -- Get all registered action names
    function registry:GetRegisteredActions()
        local actionNames = {}
        for name, _ in pairs(self.actions) do
            table.insert(actionNames, name)
        end
        return actionNames
    end
    
    -- Check if an action is registered
    function registry:HasAction(actionName)
        return self.actions[actionName] ~= nil
    end
    
    -- Get action count
    function registry:GetActionCount()
        local count = 0
        for _ in pairs(self.actions) do
            count = count + 1
        end
        return count
    end
    
    return registry
end

-- Validate action data structure (basic validation)
function ActionRegistry.ValidateActionData(actionData, itemDef)
    if not actionData then
        return true -- nil is valid
    end
    
    if type(actionData) ~= "table" then
        warn("ActionRegistry: actionData must be a table, got", type(actionData))
        return false
    end
    
    -- Basic validation passed
    return true
end

-- Standard action function signature validator
function ActionRegistry.ValidateActionFunction(actionFunction)
    if type(actionFunction) ~= "function" then
        return false, "Action must be a function"
    end
    
    -- Could add more sophisticated validation here (parameter count, etc.)
    return true
end

return ActionRegistry ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">AltarConfig</string>
          <string name="Source"><![CDATA[-- AltarConfig.luau
-- Configuration for healing altar system

local AltarConfig = {}

-- Main altar configuration
AltarConfig.SETTINGS = {
    requiredSacrifices = 3,
    requiredPlayerSacrifices = 1, -- Only need 1 player sacrifice
    cooldownTime = 30, -- seconds
    rewardItem = "summoner",
    requirePrayer = true -- Must pray to figure before reward triggers
}

-- Sacrifice requirements (simplified - any enemy with "Sacrifice" tag is valid)
AltarConfig.SACRIFICE_REQUIREMENTS = {
    -- No specific enemy type requirements
    -- Any ragdoll with "Sacrifice" tag counts
    -- Player ragdolls with "PlayerSacrifice" tag also count (1 player = philosopher's stone)
}

-- Reward configuration
AltarConfig.REWARD_CONFIG = {
    itemId = "summoner",
    spawnPosition = "altar_center" -- or "random_near_altar"
}

-- Prayer configuration
AltarConfig.PRAYER_CONFIG = {
    interactionDistance = 10, -- Distance to interact with prayer figure
    prayerDuration = 2, -- Seconds to hold E to complete prayer
    prayerKey = "E" -- Key to press for prayer
}

return AltarConfig ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">BossConfig</string>
          <string name="Source"><![CDATA[local BossConfig = {
    -- ATTACK SEQUENCES 
    sequences = {
        default = {"orbitalStrike", "trackingShot", "rippleSquares"},
        -- Add new attack sequences here as you create new abilities
        -- Example: mixed = {"trackingShot", "newAttack", "trackingShot"}
    },
    
    -- MOVEMENT & MELEE SETTINGS
    movement = {
        speed = 16,                      -- Base movement speed (same as default player speed)
        stoppingDistance = 35,           -- How close to get to player before attacking
        selectNewPlayerAfterAttack = true,
        
        -- Melee damage settings
        meleeRange = 8,                  -- Distance for melee damage
        meleeDamage = 20,                -- Damage per melee hit
        meleeKnockback = 10,             -- Knockback force
        meleeCooldown = 1.5,             -- Seconds between melee hits on same player
    },
    
    -- INVINCIBILITY SETTINGS
    invincibility = {
        triggerAfterMoves = 3,           -- Become invincible every 3 moves
        triggerVariation = 1,            -- Random +/- 1 (so 3-4 moves)
        duration = 8,                    -- Seconds of invincibility
        visualEffect = "glow",           -- Visual indicator type
        healAmount = 100,                -- Optional: heal during invincibility
        damageReduction = 1,             -- 1 = completely invincible, 0.5 = 50% damage reduction
    },
    
    -- INDIVIDUAL ATTACK SETTINGS
    abilities = {
        trackingShot = {
            trackingDuration = 2,        -- How long to track player
            blinkCount = 3,              -- Number of beam blinks before lock-on
            blinkSpeed = 0.2,            -- Seconds between blinks
            lockOnDuration = 0.45,       -- Time needed visible during blinks to achieve lock (reduced for floating point safety)
            requiresLineOfSight = false, -- Must see target during blinks to lock on (TEMP: disabled for testing)
            cooldownAfter = 2,           -- Seconds before next action
            
            -- Missile physics settings
            missileSpeed = 12,           -- Slightly slower than player (16)
            missileTurnRate = 3,         -- Radians per second turning speed (more realistic)
            missileLifetime = 10,        -- Max flight time before self-destruct
            missileSize = Vector3.new(1, 1, 3), -- Missile dimensions
            
            -- Damage settings
            damage = 50,                 -- Explosion damage
            explosionRadius = 8,         -- Explosion damage radius
            explosionVisualSize = 12,    -- Visual explosion size
            explosionDuration = 2,       -- How long explosion lasts
            
            -- Network settings
            updateRate = 30,             -- Server updates per second (increased for smoother movement)
            predictionTime = 0.1,        -- Client prediction window (reduced)
            
            -- Laser visual settings (lock-on phase)
            laserColor = Color3.new(1, 0, 0),  -- Red laser (tracking)
            lockOnColor = Color3.new(1, 0.5, 0), -- Orange laser (locked on)
            laserWidth = 0.5,            -- Beam width
            laserTransparency = 0.2,     -- Normal transparency
            blinkTransparency = {0.05, 0.8}, -- Blink on/off transparency
            particleRate = 50,           -- Particle emission rate
            
            -- Missile visual settings
            missileColor = Color3.new(0.8, 0.2, 0), -- Dark red missile
            trailColor = Color3.new(1, 0.4, 0),     -- Orange trail
            trailLength = 20,            -- Trail particle count
        },
        
        orbitalStrike = {
            circleCount = 15,            -- Number of strike circles (increased to 15)
            circleInterval = 0.75,       -- Time between each circle appearing (faster for overlapping strikes)
            strikeDelay = 0.5,           -- Time from circle appearance to strike (NEW: replaces finalWarningDuration)
            damage = 75,                 -- Strike damage
            damageRadius = 10,           -- Damage radius for each circle (increased from 6)
            visualRadius = 12,           -- Visual circle/beam radius (increased from 8)
            beamDuration = 0.5,          -- How long beams last (reduced from 1.0 to 0.5 seconds)
            cooldownAfter = 2,           -- Seconds before next action
            
            -- Strike area settings (expanded radius)
            minDistance = 15,            -- Minimum distance from boss (increased)
            maxDistance = 60,            -- Maximum distance from boss (doubled)
            
            -- Visual settings
            circleColor = Color3.new(1, 0, 0),  -- Red warning circles
            beamColor = Color3.new(1, 0.2, 0),  -- Orange-red beams
        },
        
        rippleSquares = {
            -- Square outline expansion settings
            initialSize = Vector3.new(6, 0.5, 6),      -- Starting size at boss position
            maxSize = Vector3.new(80, 0.5, 80),        -- Maximum expansion size
            expansionDuration = 6,                      -- Time to expand from min to max (slower)
            outlineThickness = 2,                       -- How thick the square outline parts are
            
            -- Ripple timing (more spacing between squares)
            rippleInterval = 3.0,                       -- New square every 3 seconds (increased spacing)
            maxActiveSquares = 4,                       -- Max squares expanding at once
            
            -- Visual settings (client-side styling)
            visualColor = Color3.new(1, 0, 0),         -- Red outline
            visualMaterial = Enum.Material.Neon,       -- Glowing effect
            visualTransparency = 0.2,                  -- Slightly transparent
            
            -- Gameplay settings
            damage = 30,                                -- Damage when touched
            cooldownAfter = 2,                          -- Cooldown after ability
        },
        
        -- Add new abilities here as you create them
        -- Example:
        -- newAttack = {
        --     damage = 30,
        --     cooldownAfter = 1.5,
        --     -- ... other settings
        -- }
    },
    
    -- BOSS STATS
    boss = {
        health = 1000,                   -- Total boss health
        maxHealth = 1000,                -- For health bar calculations
        walkSpeed = 16,                  -- Movement speed (matches player)
        size = Vector3.new(4, 8, 4),     -- Boss size
        spawnPosition = Vector3.new(0, 5, 0), -- Where boss spawns
        model = "rbxasset://models/BossModel", -- Boss model asset (placeholder)
    },
    
    -- TIMING SETTINGS
    timing = {
        globalCooldown = 8,              -- Base cooldown between any actions (further increased for more spacing)
        attackStartDelay = 1,            -- Delay before starting attacks
        sequenceRestartDelay = 3,        -- Delay before restarting sequence
        vulnerabilityDuration = 5,       -- Seconds boss is vulnerable after each attack
        gracePeriod = 10,                -- Seconds after landing where boss can't attack or be damaged
    },
    
    -- TEMPLATE SETTINGS
    templates = {
        bossName = "BossTemplate",       -- Name of boss template in ServerStorage
        enemyName = "EnemyTemplate",     -- Name of enemy template in ServerStorage
        validateOnStart = true,          -- Check templates exist on server start
    }
}

return BossConfig ]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="8">
        <Properties>
          <string name="Name">Components</string>
        </Properties>
        <Item class="ModuleScript" referent="9">
          <Properties>
            <string name="Name">Draggable</string>
            <string name="Source"><![CDATA[-- Draggable component for items
local Draggable = {}
Draggable.__index = Draggable

-- Create a new Draggable component
function Draggable.new(config)
    local self = setmetatable({
        -- Configuration
        force = config.force or 16000,
        maxDistance = config.maxDistance or 50,
        dampening = config.dampening or 0.8,
        
        -- State
        isDragging = false,
        alignPosition = nil,
        attachment = nil,
        dragConnection = nil,
        
        -- Internal
        camera = workspace.CurrentCamera
    }, Draggable)
    
    return self
end

-- Start dragging this item
function Draggable:StartDrag(item, mouse)
    if self.isDragging then return end
    
    self.isDragging = true
    
    -- Create attachment for AlignPosition
    self.attachment = Instance.new("Attachment")
    self.attachment.Parent = item
    
    -- Create AlignPosition for smooth physics-based dragging
    self.alignPosition = Instance.new("AlignPosition")
    self.alignPosition.MaxForce = self.force
    self.alignPosition.MaxVelocity = math.huge
    self.alignPosition.Responsiveness = 200
    self.alignPosition.Attachment0 = self.attachment
    self.alignPosition.Parent = item
    
    -- Connect to mouse movement
    self.dragConnection = mouse.Move:Connect(function()
        self:UpdateDrag(item, mouse)
    end)
    
    -- Initial position update
    self:UpdateDrag(item, mouse)
    
    print("Started dragging with AlignPosition:", item.Name)
end

-- Update drag position based on mouse
function Draggable:UpdateDrag(item, mouse)
    if not self.isDragging or not self.alignPosition then return end
    
    -- Cast ray from camera through mouse position
    local ray = self.camera:ScreenPointToRay(mouse.X, mouse.Y)
    
    -- Calculate target position at max distance
    local targetPosition = ray.Origin + ray.Direction * self.maxDistance
    
    -- Set the align position target
    self.alignPosition.Position = targetPosition
    
    -- Debug: Print position updates (only occasionally to avoid spam)
    if math.random() < 0.1 then -- 10% chance to print
        print("Dragging", item.Name, "to position:", targetPosition)
    end
end

-- Stop dragging this item
function Draggable:StopDrag(item)
    if not self.isDragging then return end
    
    self.isDragging = false
    
    -- Clean up drag connection
    if self.dragConnection then
        self.dragConnection:Disconnect()
        self.dragConnection = nil
    end
    
    -- Clean up align position
    if self.alignPosition then
        self.alignPosition:Destroy()
        self.alignPosition = nil
    end
    
    -- Clean up attachment
    if self.attachment then
        self.attachment:Destroy()
        self.attachment = nil
    end
    
    print("Stopped dragging:", item and item.Name or "unknown")
end

-- Check if currently being dragged
function Draggable:IsDragging()
    return self.isDragging
end

-- Clean up (called when component is removed)
function Draggable:Destroy()
    if self.isDragging then
        self.isDragging = false
        
        -- Clean up connections
        if self.dragConnection then
            self.dragConnection:Disconnect()
        end
        
        -- Clean up constraints
        if self.alignPosition then
            self.alignPosition:Destroy()
        end
        
        if self.attachment then
            self.attachment:Destroy()
        end
    end
    
    -- Clear all references
    self.dragConnection = nil
    self.alignPosition = nil
    self.attachment = nil
    self.isDragging = false
end

return Draggable ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="10">
          <Properties>
            <string name="Name">Hoverable</string>
            <string name="Source"><![CDATA[-- Hoverable component for items
local Hoverable = {}
Hoverable.__index = Hoverable

-- Create a new Hoverable component
function Hoverable.new(config)
    local self = setmetatable({
        -- Configuration
        displayName = config.displayName or "Item",
        highlightColor = config.highlightColor or Color3.fromRGB(255, 255, 0),
        showHighlight = config.showHighlight ~= false, -- Default true
        
        -- State
        isHovered = false,
        selectionBox = nil
    }, Hoverable)
    
    return self
end

-- Start hovering (no visual highlight, just prepare for name display)
function Hoverable:StartHover(item)
    if self.isHovered then return end
    
    self.isHovered = true
    
    -- No visual highlighting - removed selection box creation
end

-- Stop hovering (no cleanup needed since no visual highlight)
function Hoverable:StopHover(item)
    if not self.isHovered then return end
    
    self.isHovered = false
    
    -- No selection box to clean up
end

-- Get the display name
function Hoverable:GetDisplayName()
    return self.displayName
end

-- Check if currently being hovered
function Hoverable:IsHovered()
    return self.isHovered
end

-- Clean up (called when component is removed)
function Hoverable:Destroy()
    if self.isHovered then
        self:StopHover()
    end
end

return Hoverable ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="11">
          <Properties>
            <string name="Name">Inventoryable</string>
            <string name="Source"><![CDATA[-- Inventoryable component for items that can be stored in inventory
local Inventoryable = {}
Inventoryable.__index = Inventoryable

-- Create a new Inventoryable component
function Inventoryable.new(config)
    local self = setmetatable({
        -- Configuration
        canPickup = config.canPickup ~= false, -- Default true
        stackable = config.stackable or false,
        maxStack = config.maxStack or 1,
        category = config.category or "Items",
        inventoryIcon = config.inventoryIcon or "",
        
        -- State
        isInInventory = false,
        hotbarSlot = nil, -- Which slot (1-10) or nil if not equipped
        stackCount = 1,
        originalCFrame = nil, -- Where it was in world before pickup
        originalParent = nil -- Original parent before pickup
    }, Inventoryable)
    
    return self
end

-- Move item to inventory
function Inventoryable:MoveToInventory(slot)
    if self.isInInventory then return false end
    
    self.isInInventory = true
    self.hotbarSlot = slot
    
    return true
end

-- Move item back to world
function Inventoryable:MoveToWorld(newCFrame, newParent)
    if not self.isInInventory then return false end
    
    self.isInInventory = false
    self.hotbarSlot = nil
    self.originalCFrame = newCFrame
    self.originalParent = newParent
    
    return true
end

-- Check if item can be picked up
function Inventoryable:CanPickup()
    return self.canPickup and not self.isInInventory
end

-- Get display information
function Inventoryable:GetDisplayInfo()
    return {
        stackable = self.stackable,
        stackCount = self.stackCount,
        maxStack = self.maxStack,
        category = self.category,
        icon = self.inventoryIcon
    }
end

-- Clean up (called when component is removed)
function Inventoryable:Destroy()
    -- Nothing special to clean up for now
end

return Inventoryable ]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="12">
        <Properties>
          <string name="Name">Constants</string>
          <string name="Source"><![CDATA[-- Shared constants for the game
local Constants = {}

-- Drag system settings
Constants.DRAG = {
    DEFAULT_FORCE = 16000,
    DEFAULT_MAX_DISTANCE = 50,
    DEFAULT_DAMPENING = 0.8,
    RAYCAST_DISTANCE = 15,
    MAX_DRAG_DISTANCE = 15,
    MIN_DRAG_DISTANCE = 3
}

-- Hover system settings
Constants.HOVER = {
    RAYCAST_DISTANCE = 15,
    HIGHLIGHT_COLOR = Color3.fromRGB(255, 255, 0),
    UI_OFFSET = Vector2.new(10, -30)
}

-- Item tags (for CollectionService)
Constants.TAGS = {
    DRAGGABLE_ITEM = "DraggableItem"
}

return Constants ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="13">
        <Properties>
          <string name="Name">DialogueData</string>
          <string name="Source"><![CDATA[-- DialogueData.luau
-- Contains all NPC dialogue configurations

local DialogueData = {}

-- Dialogue states for each NPC
DialogueData.NPCDialogues = {
	-- Wise Man NPC - Changes based on quest state
	wise_man_default = {
		text = "Welcome, I am Gary. What wisdom do you seek?\n\n• [Request Quest] - Why are we here?\n• [Learn Ancient Lore] - What is this land?\n• [Depart] - Thank you for your time, wise one",
		actions = {"start_quest", "show_lore", "goodbye"}
	},
	
	wise_man_quest_active = {
		text = "The princess awaits rescue in the tower!\n\n• [Quest Info] - Tell me about the princess\n• [Learn Ancient Lore] - Tell me of the old days\n• [Depart] - I must go help her",
		actions = {"quest_info", "show_lore", "goodbye"}
	},
	
	-- Princess NPC - Only appears after quest is taken
	princess = {
		text = "Oh brave hero! You've found me! Please help break this terrible curse!\n\n• [Break Curse - Become Companion] - I'll escort you to safety\n• [Break Curse - Test Your Strength] - Prove you're worthy first\n• [Leave Cursed] - I cannot help you right now",
		actions = {"become_companion", "enable_combat", "goodbye"}
	},
	
	-- Trader NPC
	trader = {
		text = "Ah, a customer! I have rare goods to trade.\n\n• [Open Trading Post] - Let's make a deal\n• [Leave] - Perhaps another time",
		actions = {"open_trade", "goodbye"}
	},
	
	-- Regular NPC
	regular_npc = {
		text = "Hello there, traveler! Care to hear a tale?\n\n• [Hear Story] - I'd love to listen\n• [Move Along] - Maybe another time",
		actions = {"tell_story", "goodbye"}
	}
}

-- Response dialogues that replace the old overhead text system
DialogueData.ResponseDialogues = {
	start_quest = {
		text = "My daughter, Ella, was kidnapped by an evil god. They call him the uncrowned king. Bring her back and I shall teach you how to return to your world.",
		actions = {}
	},
	show_lore = {
		text = "Ella, known for her vibrant spirit and her unusual affinity for the high mountain meadows, was not a typical royal. She often ventured far beyond the castle walls, seeking out rare herbs and sketching the intricate patterns of alpine flowers. It was said she had a connection to the 'Aether Weave,' the invisible currents of magic and life that flowed through the peaks. This made her, unbeknownst to her, a beacon.",
		actions = {}
	},
	quest_info = {
		text = "She's trapped in the eastern tower, cursed by an ancient spell. Only a true hero can free her!",
		actions = {}
	},
	become_companion = {
		text = "Thank you! I am free! I shall accompany you on your adventures!",
		actions = {}
	},
	enable_combat = {
		text = "The curse compels me to fight! Defeat me to break the curse forever!",
		actions = {}
	},
	open_trade = {
		text = "Choose your trades wisely! I have the finest goods in the realm!",
		actions = {}
	},
	tell_story = {
		text = "Once upon a time, in a village much like this one, a great dragon threatened all who lived here. But a brave hero rose to challenge the beast, and that's how our town was saved!",
		actions = {}
	}
}

-- Trade configurations for the trader
DialogueData.TradeOptions = {
	{give = "Wood", giveAmount = 5, receive = "Stone", receiveAmount = 1},
	{give = "Stone", giveAmount = 3, receive = "Iron", receiveAmount = 1},
	{give = "Iron", giveAmount = 2, receive = "Gold", receiveAmount = 1},
}

return DialogueData ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="14">
        <Properties>
          <string name="Name">ECS</string>
          <string name="Source"><![CDATA[-- Simple ECS component manager
local ECS = {}

-- Store components for each item
local itemComponents = {}

-- Add a component to an item
function ECS:AddComponent(item, componentName, componentData)
    if not itemComponents[item] then
        itemComponents[item] = {}
    end
    itemComponents[item][componentName] = componentData
end

-- Get a specific component from an item
function ECS:GetComponent(item, componentName)
    return itemComponents[item] and itemComponents[item][componentName]
end

-- Check if an item has a specific component
function ECS:HasComponent(item, componentName)
    return itemComponents[item] and itemComponents[item][componentName] ~= nil
end

-- Query all items that have the specified components
function ECS:QueryComponents(...)
    local requiredComponents = {...}
    local results = {}
    
    for item, components in pairs(itemComponents) do
        local hasAll = true
        for _, componentName in ipairs(requiredComponents) do
            if not components[componentName] then
                hasAll = false
                break
            end
        end
        if hasAll then
            table.insert(results, item)
        end
    end
    
    return results
end

-- Remove a component from an item
function ECS:RemoveComponent(item, componentName)
    if itemComponents[item] then
        itemComponents[item][componentName] = nil
        
        -- Clean up if no components left
        if next(itemComponents[item]) == nil then
            itemComponents[item] = nil
        end
    end
end

-- Remove all components from an item (cleanup)
function ECS:RemoveAllComponents(item)
    itemComponents[item] = nil
end

return ECS ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="15">
        <Properties>
          <string name="Name">EnemyChatData</string>
          <string name="Source"><![CDATA[-- EnemyChatData.luau
-- Contains all enemy chat phrases organized by type and state

local EnemyChatData = {}

-- Chat phrases organized by enemy type and AI state
EnemyChatData.ChatPhrases = {
    -- Default phrases for any enemy type
    default = {
        idle = {
            "Nothing happening here.",
            "Quiet around these parts.",
            "How's your watch going?",
            "Pretty peaceful tonight.",
            "Seen anything interesting?",
            "Just another boring shift.",
            "All quiet on my end.",
            "Nothing to report."
        },
        patrol = {
            "All clear on my route.",
            "Making my rounds.",
            "Patrol route looks good.",
            "Nothing suspicious spotted.",
            "Area seems secure.",
            "Just checking the perimeter.",
            "Keeping an eye out.",
            "Making sure everything's in order."
        }
    },
    
    -- Specific phrases for melee enemies (guards, warriors, etc.)
    melee = {
        idle = {
            "My weapon feels heavy today.",
            "Ready for anything that comes.",
            "Keeping my blade sharp.",
            "Standing guard as always.",
            "Nothing beats a good sword.",
            "These boots are killing me.",
            "At least the weather's nice.",
            "Hope nothing exciting happens."
        },
        patrol = {
            "Checking for intruders.",
            "Securing the area.",
            "No threats detected.",
            "Perimeter sweep complete.",
            "All entrances secured.",
            "Area is locked down tight.",
            "No signs of trouble.",
            "Everything's under control."
        }
    },
    
    -- Specific phrases for ranged enemies (archers, mages, etc.)
    ranged = {
        idle = {
            "Good visibility from here.",
            "Perfect vantage point.",
            "Can see for miles.",
            "Arrows are ready.",
            "Watching the horizon.",
            "Eyes open, ready to shoot.",
            "Scanning for targets.",
            "Range is clear."
        },
        patrol = {
            "Sweeping with my eyes.",
            "No movement detected.",
            "Covering the long range.",
            "All sight lines clear.",
            "No targets in range.",
            "Watching from afar.",
            "Keeping overwatch.",
            "Long range all clear."
        }
    },
    
    -- Specific phrases for special enemies (bosses, unique units, etc.)
    special = {
        idle = {
            "The power flows through me.",
            "Ancient magic stirs.",
            "Something feels different today.",
            "The air crackles with energy.",
            "I sense disturbances.",
            "Magic is strong here.",
            "The elements whisper secrets.",
            "Mystical forces are at work."
        },
        patrol = {
            "Channeling protective wards.",
            "Magical barriers holding strong.",
            "Sensing no hostile magic.",
            "The arcane is balanced.",
            "No magical threats detected.",
            "Weaving protective spells.",
            "Mystical defenses active.",
            "Ancient powers stand guard."
        }
    }
}

-- Get random chat phrase for an enemy type and state
function EnemyChatData:GetRandomPhrase(enemyType, aiState)
    -- Validate inputs
    if not enemyType or not aiState then
        return nil
    end
    
    -- Only allow chat during idle and patrol states
    if aiState ~= "idle" and aiState ~= "patrol" then
        return nil
    end
    
    -- Get phrases for this enemy type, fallback to default
    local typeData = self.ChatPhrases[enemyType] or self.ChatPhrases.default
    local statePhrases = typeData[aiState]
    
    if not statePhrases or #statePhrases == 0 then
        return nil
    end
    
    -- Return random phrase
    return statePhrases[math.random(1, #statePhrases)]
end

-- Get all available enemy types that have chat data
function EnemyChatData:GetAvailableEnemyTypes()
    local types = {}
    for enemyType, _ in pairs(self.ChatPhrases) do
        table.insert(types, enemyType)
    end
    return types
end

return EnemyChatData ]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="16">
        <Properties>
          <string name="Name">EnemyComponents</string>
        </Properties>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">AnimationSet</string>
            <string name="Source"><![CDATA[-- AnimationSet.lua
-- Data structure for entity animations

return {
    idle = nil,   -- AnimationTrack
    walk = nil,   -- AnimationTrack  
    attack = nil, -- AnimationTrack
    current = nil, -- Currently playing AnimationTrack
    animationSource = "state", -- "movement" or "state" - tracks what's controlling current animation
} ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="18">
          <Properties>
            <string name="Name">Combat</string>
            <string name="Source"><![CDATA[-- Combat.lua
-- Simple data structure for entity combat state

return {
    target = nil, -- Entity being attacked
    damage = 10, -- Damage per attack
    lastAttackTime = 0, -- When last attack occurred
    
    -- Attack state for moving shapecast
    isAttacking = false, -- Whether currently performing an attack
    attackStartTime = 0, -- When current attack started
    attackTargetPlayer = nil, -- Player being attacked during current attack
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="19">
          <Properties>
            <string name="Name">CombatEffects</string>
            <string name="Source"><![CDATA[-- CombatEffects.lua
-- Simple data structure for combat visual effects

return {
    enableHitEffects = true
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="20">
          <Properties>
            <string name="Name">CombatStats</string>
            <string name="Source"><![CDATA[-- CombatStats.lua
-- Simple data structure for combat statistics

return {
    damage = 10, -- Base damage dealt
    defense = 0, -- Damage reduction
    critChance = 0.1, -- Critical hit chance (0.0-1.0)
    critMultiplier = 1.5, -- Critical hit damage multiplier
} ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="21">
          <Properties>
            <string name="Name">EnemyAI</string>
            <string name="Source"><![CDATA[-- EnemyAI.lua
-- Simple data structure for enemy AI state data

return {
    state = "idle", -- Current AI state: idle, patrol, chase, attack, dead
    stateStartTime = 0, -- When current state started
    detectionRange = 30, -- How far enemy can detect players
    attackRange = 5, -- How close needed to attack
    speed = 16, -- Movement speed
    homePosition = Vector3.new(0,0,0), -- Starting position for patrol (set by spawn system)
    patrolRadius = 30, -- Maximum distance from homePosition during patrol
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="22">
          <Properties>
            <string name="Name">EnemyType</string>
            <string name="Source"><![CDATA[-- EnemyType.lua
-- Simple data structure for enemy type identification

return {
    enemyType = "Wolf", -- Type identifier: Wolf, Bear, Goblin, etc.
} ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="23">
          <Properties>
            <string name="Name">Health</string>
            <string name="Source"><![CDATA[-- Health.lua
-- Simple data structure for entity health

return {
    max = 100,
    current = 100,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="24">
          <Properties>
            <string name="Name">IdleState</string>
            <string name="Source"><![CDATA[-- IdleState.lua
-- Simple data structure for idle state behavior

return {
    homePosition = Vector3.new(0, 0, 0),
    wanderRadius = 20,
    wanderCooldown = 5,
    lastWanderTime = 0,
    isWandering = false,
} ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="25">
          <Properties>
            <string name="Name">Model</string>
            <string name="Source"><![CDATA[-- Model.lua
-- Simple data structure for entity model instances

return {
    model = nil,  -- Instance
    part  = nil,  -- BasePart (PrimaryPart)
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="26">
          <Properties>
            <string name="Name">Spawner</string>
            <string name="Source"><![CDATA[-- Spawner.lua
-- Simple data structure for spawning configuration

return {
    Enemies         = {},
    CountRange      = { min = 1, max = 1 },
    Radius          = 50,
    Cooldown        = 30,
    LastSpawnTime   = 0,
    SpawnedEntities = {},
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="27">
        <Properties>
          <string name="Name">EnemyComponents</string>
          <string name="Source"><![CDATA[-- Components.lua
-- Component templates and default values
-- Single responsibility: Define what data each component type holds

local Components = {}

-- Health and combat
Components.Health = {
    max = 100,
    current = 100
}

Components.Combat = {
    target = nil,           -- Entity ID being attacked
    damage = 10,           -- Damage per attack
    lastAttackTime = 0,    -- When last attack occurred
    attackCooldown = 1,    -- Time between attacks
    attackRange = 5        -- Attack range in studs
}

Components.CombatStats = {
    baseAttack = 10,
    baseDefense = 0,
    critChance = 0.1,       -- 0.0 to 1.0
    critMultiplier = 1.5,
    dodgeChance = 0.05
}

-- Enemy AI and behavior
Components.EnemyType = {
    enemyType = "melee",    -- "melee", "ranged", "special"
    enemyId = "",           -- Original enemy ID from EnemyDefinitions (e.g., "goblin_warrior")
    config = {}             -- Custom configuration data
}

Components.EnemyAI = {
    state = "idle",         -- "idle", "patrol", "chase", "attack", "dead"
    stateStartTime = 0,
    detectionRange = 3,    -- How far enemy can detect players (changed from 30 to 15)
    attackRange = 5,
    speed = 16,
    homePosition = Vector3.new(0, 0, 0),
    patrolRadius = 30,      -- Maximum distance from homePosition during patrol
    lastUpdateTime = 0,     -- For state-based update frequency
    lastMoveToTime = 0      -- For stuck detection
}

Components.EnemyChat = {
    lastChatTime = 0,       -- When this enemy last chatted
    chatCooldown = 8,       -- Minimum seconds between chats (default 8 seconds)
    chatRange = 12,         -- How close enemies need to be to chat (studs)
    canChat = true,         -- Whether this enemy can participate in chat
    chattedWith = {},       -- Track recent chat partners to prevent spam between same enemies
    partnerCooldown = 15    -- Seconds before can chat with same partner again
}

-- Spawning
Components.Spawner = {
    enemies = {},           -- List of enemy types to spawn
    countRange = {min = 1, max = 1},
    radius = 25,            -- Default spawn radius in studs (smaller for closer spawning)
    cooldown = 10,
    lastSpawnTime = 0,
    spawnedEntities = {},   -- Track spawned entities
    centerPosition = Vector3.new(0, 0, 0),  -- Center position for spawning
    activationRange = 60,   -- Only spawn when player within this range
    spawnType = "once",     -- "once" or "continuous" - defaults to one-time spawning
    hasSpawned = false      -- Track if one-time spawner has already activated
}

-- Visual representation (this IS needed - links entities to Roblox models)
Components.Model = {
    model = nil,            -- Roblox Model instance
    part = nil,             -- Primary part reference
    humanoid = nil          -- Humanoid reference
}

-- Animation management for entities
Components.AnimationSet = {
    idle = nil,      -- AnimationTrack for idle animation
    walk = nil,      -- AnimationTrack for walk animation  
    attack = nil,    -- AnimationTrack for attack animation
    current = nil,   -- Currently playing AnimationTrack
}

-- Helper function to create a component with custom data
function Components.create(componentType, customData)
    local template = Components[componentType]
    if not template then
        warn("❌ Unknown component type:", componentType)
        return nil
    end
    
    -- Create a copy of the template
    local component = {}
    for key, value in pairs(template) do
        component[key] = value
    end
    
    -- Override with custom data
    if customData then
        for key, value in pairs(customData) do
            component[key] = value
        end
    end
    
    return component
end

-- Debug function to list all component types
function Components.debugPrint()
    print("🔍 Available Component Types:")
    for componentType, template in pairs(Components) do
        if type(template) == "table" and componentType ~= "create" and componentType ~= "debugPrint" then
            print("  ", componentType, ":", template)
        end
    end
end

return Components ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="28">
        <Properties>
          <string name="Name">EnemyData</string>
          <string name="Source">-- Data module
-- Exports all data modules for the StayAlive survival game
-- Import this module to access all data: local Data = require(path.to.data)

local Data = {}

-- Import data modules
local SpawnRules = require(script.SpawnRules)

-- Export data modules
Data.SpawnRules = SpawnRules

print("📚 Data module loaded with SpawnRules")

return Data</string>
        </Properties>
        <Item class="ModuleScript" referent="29">
          <Properties>
            <string name="Name">SpawnRules</string>
            <string name="Source"><![CDATA[-- SpawnRules.lua
-- Simple generic spawn configuration system for StayAlive survival game
-- Defines basic enemy spawning rules without biome dependencies

local SpawnRules = {}

-- ================================
-- SPAWN RULE TYPES AND CONSTANTS
-- ================================

-- Entity types that can spawn
local ENTITY_TYPES = {
	ENEMY = "enemy",
	STRUCTURE = "structure"
}

-- Spawn condition types
local SPAWN_CONDITIONS = {
	ALWAYS = "always",
	TIMED = "timed",
	PROXIMITY = "proximity"
}

-- ================================
-- BASIC SPAWN CONFIGURATIONS
-- ================================

-- Simple spawn rules for generic areas
local BASIC_SPAWN_DATA = {
	enemies = {
		{
			entityId = "Wolf",
			countRange = {min = 2, max = 4},
			minDistance = 25,
			spawnCondition = SPAWN_CONDITIONS.ALWAYS,
			difficulty = 3,
			hostile = true,
			spawnWeight = 1.0
		},
		{
			entityId = "Bear",
			countRange = {min = 1, max = 2},
			minDistance = 50,
			spawnCondition = SPAWN_CONDITIONS.ALWAYS,
			difficulty = 5,
			hostile = true,
			spawnWeight = 0.5
		},
		{
			entityId = "Scorpion",
			countRange = {min = 3, max = 6},
			minDistance = 20,
			spawnCondition = SPAWN_CONDITIONS.ALWAYS,
			difficulty = 2,
			hostile = true,
			spawnWeight = 0.8
		}
	},
	structures = {
		{
			entityId = "GenericSpawner",
			countRange = {min = 1, max = 3},
			minDistance = 100,
			spawnCondition = SPAWN_CONDITIONS.ALWAYS,
			structureType = "spawner"
		}
	}
}

-- ================================
-- PUBLIC API FUNCTIONS
-- ================================

-- Get all available entity types
function SpawnRules.getEntityTypes()
	return ENTITY_TYPES
end

-- Get spawn conditions
function SpawnRules.getSpawnConditions()
	return SPAWN_CONDITIONS
end

-- Get basic spawn rules for enemies
function SpawnRules.getEnemySpawnRules()
	return BASIC_SPAWN_DATA.enemies
end

-- Get basic spawn rules for structures
function SpawnRules.getStructureSpawnRules()
	return BASIC_SPAWN_DATA.structures
end

-- Get all spawn rules
function SpawnRules.getAllSpawnRules()
	return BASIC_SPAWN_DATA
end

-- Get a random enemy type based on spawn weights
function SpawnRules.getRandomEnemyType()
	local enemies = BASIC_SPAWN_DATA.enemies
	local totalWeight = 0
	
	-- Calculate total weight
	for _, enemy in ipairs(enemies) do
		totalWeight = totalWeight + (enemy.spawnWeight or 1.0)
	end
	
	-- Pick random enemy based on weight
	local randomValue = math.random() * totalWeight
	local currentWeight = 0
	
	for _, enemy in ipairs(enemies) do
		currentWeight = currentWeight + (enemy.spawnWeight or 1.0)
		if randomValue <= currentWeight then
			return enemy.entityId
		end
	end
	
	-- Fallback to first enemy
	return enemies[1] and enemies[1].entityId or "Wolf"
end

-- Validate spawn rule configuration
function SpawnRules.validateSpawnRule(rule)
	if not rule then
		return false, "Rule is nil"
	end
	
	if not rule.entityId then
		return false, "Missing entityId"
	end
	
	if not rule.countRange or not rule.countRange.min or not rule.countRange.max then
		return false, "Missing or invalid countRange"
	end
	
	if rule.countRange.min > rule.countRange.max then
		return false, "countRange.min cannot be greater than countRange.max"
	end
	
	return true, "Valid"
end

-- Get spawn count for a rule
function SpawnRules.getSpawnCount(rule)
	if not rule or not rule.countRange then
		return 1
	end
	
	return math.random(rule.countRange.min, rule.countRange.max)
end

-- Check if an entity should spawn based on conditions
function SpawnRules.shouldSpawn(rule, context)
	if not rule then
		return false
	end
	
	local condition = rule.spawnCondition or SPAWN_CONDITIONS.ALWAYS
	
	if condition == SPAWN_CONDITIONS.ALWAYS then
		return true
	elseif condition == SPAWN_CONDITIONS.TIMED then
		-- Basic timed spawning logic
		local currentTime = tick()
		local lastSpawn = context.lastSpawnTime or 0
		local spawnInterval = rule.spawnInterval or 30 -- 30 seconds default
		return (currentTime - lastSpawn) >= spawnInterval
	elseif condition == SPAWN_CONDITIONS.PROXIMITY then
		-- Basic proximity spawning logic
		return context.playersNearby or false
	end
	
	return false
end

-- ================================
-- HELPER FUNCTIONS
-- ================================

-- Get minimum distance for entity placement
function SpawnRules.getMinDistance(entityId)
	-- Check enemies first
	for _, enemy in ipairs(BASIC_SPAWN_DATA.enemies) do
		if enemy.entityId == entityId then
			return enemy.minDistance or 20
		end
	end
	
	-- Check structures
	for _, structure in ipairs(BASIC_SPAWN_DATA.structures) do
		if structure.entityId == entityId then
			return structure.minDistance or 50
		end
	end
	
	return 20 -- Default minimum distance
end

-- Get difficulty for entity
function SpawnRules.getDifficulty(entityId)
	for _, enemy in ipairs(BASIC_SPAWN_DATA.enemies) do
		if enemy.entityId == entityId then
			return enemy.difficulty or 1
		end
	end
	return 1
end

-- Check if entity is hostile
function SpawnRules.isHostile(entityId)
	for _, enemy in ipairs(BASIC_SPAWN_DATA.enemies) do
		if enemy.entityId == entityId then
			return enemy.hostile or false
		end
	end
	return false
end

return SpawnRules ]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="30">
        <Properties>
          <string name="Name">EnemyDefinitions</string>
          <string name="Source"><![CDATA[-- EnemyDefinitions.lua
-- Enemy definitions with component configurations for different enemy types
-- Similar to ItemDefinitions but for enemies with EnemyType components

local EnemyDefinitions = {}
-- Import Components from our custom ECS (find ModuleScript specifically to avoid folder conflict)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("EnemyDefinitions: Could not find EnemyComponents ModuleScript")
end

-- Helper function for deep merging tables
local function mergeTables(t1, t2)
    local t3 = {}
    for k, v in pairs(t1) do
        t3[k] = v
    end
    for k, v in pairs(t2) do
        if type(v) == "table" and type(t3[k]) == "table" then
            t3[k] = mergeTables(t3[k], v)
        else
            t3[k] = v
        end
    end
    return t3
end

-- Enemy definitions organized by type and specific variants
EnemyDefinitions.enemies = {
    -- MELEE ENEMIES
    forest_berserker = {
        name = "Forest Berserker",
        description = "A fierce melee fighter that charges directly at enemies.",
        model = "ForestBerserkerModel",
        enemyType = "melee",
        
        -- Visual properties
        color = Color3.fromRGB(120, 80, 40), -- Brown
        size = Vector3.new(2, 4, 2),
        material = Enum.Material.Plastic,
        
        -- Custom configuration overrides
        customConfig = {
            moveSpeed = 18, -- Faster than default melee
            damage = 20,    -- Higher damage
            attackSpeed = 2.2,
            detectionRange = 15,
            -- Idle movement settings
            idleMovementEnabled = true,
            idleMovementRadius = 20,
            idleMovementInterval = 4,
            idleMovementSpeed = 10,
        },
        
        -- Loot drops
        loot = {
            { item = "sword", chance = 0.3 },
            { item = "gold_coin", chance = 0.8 },
            { item = "health_potion", chance = 0.2 }
        },
        
        -- Health and stats
        health = 80,
        experience = 15
    },
    
    desert_berserker = {
        name = "Desert Berserker",
        description = "Desert killa",
        model = "DesertBerserkerModel",
        enemyType = "melee",
        
        color = Color3.fromRGB(80, 120, 60), -- Dark green
        size = Vector3.new(3, 5, 3),
        material = Enum.Material.Concrete,
        
        customConfig = {
            moveSpeed = 14, -- Slower but tankier
            damage = 40,
            attackSpeed = 1.8,
            detectionRange = 40,
            chaseDistance = 60 -- Persistent chaser
        },
        
        loot = {
            { item = "battle_axe", chance = 0.4 },
            { item = "armor_scrap", chance = 0.6 },
            { item = "gold_coin", chance = 1.0 }
        },
        
        health = 150,
        experience = 25
    },
    
    -- RANGED ENEMIES
    desert_archer = {
        name = "Desert Archer",
        description = "Desert dude archer that keeps its distance and shoots arrows.",
        model = "DesertArcherModel",
        enemyType = "ranged",
        
        color = Color3.fromRGB(200, 200, 180), -- Bone white
        size = Vector3.new(2, 4, 2),
        material = Enum.Material.Marble,
        
        customConfig = {
            moveSpeed = 10, -- Slower movement
            damage = 7,
            attackSpeed = 1.2,
            attackRange = 40,
            detectionRange = 45,
            projectileSpeed = 60,
            aimAccuracy = 0.85,
            -- Ranged-specific settings
            burstSize = 1,
            shotInterval = 0.25,
            aimTime = 0.2,
            postBurstPause = 0.5,
            repositionThreshold = 8,
            optimalDistance = 25,
            projectileSize = Vector3.new(0.2, 0.2, 0.2),
            projectileColor = Color3.fromRGB(255, 100, 50), -- Orange-red
            projectileLifetime = 3,
            -- Idle movement settings for ranged enemies
            idleMovementEnabled = true,
            idleMovementRadius = 12,
            idleMovementInterval = 6,
            idleMovementSpeed = 6,
        },
        
        loot = {
            { item = "bow", chance = 0.5 },
            { item = "arrow", chance = 0.9 },
            { item = "bone", chance = 0.7 }
        },
        
        health = 60,
        experience = 20
    },
    
    pirate_bucaneer = {
        name = "Pirate Bucaneer",
        description = "A pirate with a powerful flintlock",
        model = "PirateBucaneerModel",
        enemyType = "ranged",
        
        color = Color3.fromRGB(100, 60, 120), -- Purple
        size = Vector3.new(1.8, 3.5, 1.8),
        material = Enum.Material.Neon,
        
        customConfig = {
            moveSpeed = 8,
            damage = 35,
            attackSpeed = 0.8, -- Slower but powerful
            attackRange = 30,
            detectionRange = 35,
            projectileSpeed = 40,
            projectileType = "magic_bolt",
            aimAccuracy = 0.9,
            -- Ranged-specific settings
            burstSize = 1, -- Single powerful shot
            shotInterval = 1,
            aimTime = 0.3,
            postBurstPause = 2.0, -- Increased to 2.0 seconds for slower attacks
            repositionThreshold = 12,
            optimalDistance = 30,
            projectileSize = Vector3.new(0.3, 0.3, 0.3),
            projectileColor = Color3.fromRGB(100, 60, 120), -- Purple
            projectileLifetime = 4,
        },
        
        loot = {
            { item = "magic_staff", chance = 0.3 },
            { item = "mana_crystal", chance = 0.6 },
            { item = "spell_scroll", chance = 0.4 }
        },
        
        health = 50,
        experience = 30
    },
    
    -- SPECIAL ENEMIES
    shadow_assassin = {
        name = "Shadow Assassin",
        description = "A mysterious enemy that can teleport and strike from shadows.",
        model = "ShadowAssassinModel",
        enemyType = "special",
        
        color = Color3.fromRGB(40, 40, 80), -- Dark blue
        size = Vector3.new(2, 4, 2),
        material = Enum.Material.ForceField,
        
        customConfig = {
            moveSpeed = 20, -- Very fast
            damage = 45,
            attackSpeed = 3.5,
            detectionRange = 50,
            specialAttacks = {"teleport", "stealth_strike"},
            manaPool = 80,
            spellCooldown = 6.0,
            teleportRange = 25,
            teleportCooldown = 10.0
        },
        
        loot = {
            { item = "shadow_blade", chance = 0.2 },
            { item = "stealth_cloak", chance = 0.1 },
            { item = "rare_gem", chance = 0.3 }
        },
        
        health = 120,
        experience = 50
    },
    
    yeti = {
        name = "Yeti",
        description = "A powerful spellcaster with area-of-effect abilities.",
        model = "YetiModel",
        enemyType = "special",
        
        color = Color3.fromRGB(255, 100, 100), -- Fiery red
        size = Vector3.new(2.5, 4.5, 2.5),
        material = Enum.Material.Neon,
        
        customConfig = {
            moveSpeed = 12,
            damage = 50,
            attackSpeed = 2.0,
            detectionRange = 45,
            specialAttacks = {"fireball", "area_damage", "magic_shield"},
            manaPool = 150,
            spellCooldown = 4.0,
            retreatThreshold = 8 -- Keeps distance
        },
        
        loot = {
            { item = "elemental_staff", chance = 0.4 },
            { item = "fire_crystal", chance = 0.7 },
            { item = "magic_tome", chance = 0.3 }
        },
        
        health = 100,
        experience = 60
    },
    
    necromancer = {
        name = "Necromancer",
        description = "A dark wizard that can summon minions and drain life.",
        model = "NecromancerModel",
        enemyType = "special",
        
        color = Color3.fromRGB(80, 40, 80), -- Dark purple
        size = Vector3.new(2.2, 4.8, 2.2),
        material = Enum.Material.Glass,
        
        customConfig = {
            moveSpeed = 10,
            damage = 35,
            attackSpeed = 1.5,
            detectionRange = 40,
            specialAttacks = {"summon_minions", "life_drain", "curse"},
            manaPool = 200,
            spellCooldown = 8.0,
            canTeleport = false -- Prefers summoning
        },
        
        loot = {
            { item = "necromancer_staff", chance = 0.3 },
            { item = "soul_gem", chance = 0.5 },
            { item = "dark_tome", chance = 0.4 }
        },
        
        health = 80,
        experience = 70
    }
}

-- ▼ put this near the top of EnemyDefinitions.lua
local DEFAULT_MODEL_BY_TYPE = {
    melee   = "Jason",
    ranged  = "R6",
    special = "Dog",
}

local DEFAULT_IDLE_ANIM = "Idle"
local DEFAULT_RUN_ANIM  = "Run"

-- Set default models and animations for all enemies
for _, enemy in pairs(EnemyDefinitions.enemies) do
    -- only fill in if you didn’t already specify one
    enemy.model = enemy.model or DEFAULT_MODEL_BY_TYPE[enemy.enemyType]

    enemy.customConfig = enemy.customConfig or {}
    enemy.customConfig.idleAnim = enemy.customConfig.idleAnim or DEFAULT_IDLE_ANIM
    enemy.customConfig.runAnim  = enemy.customConfig.runAnim  or DEFAULT_RUN_ANIM
end

-- Get enemy definition by ID
function EnemyDefinitions:GetEnemy(enemyId)
    return self.enemies[enemyId]
end

-- Get all enemy IDs
function EnemyDefinitions:GetAllEnemyIds()
    local ids = {}
    for id, _ in pairs(self.enemies) do
        table.insert(ids, id)
    end
    return ids
end

-- Get enemies by type
function EnemyDefinitions:GetEnemiesByType(enemyType)
    local enemies = {}
    for id, enemy in pairs(self.enemies) do
        if enemy.enemyType == enemyType then
            enemies[id] = enemy
        end
    end
    return enemies
end

-- Create components for an enemy
function EnemyDefinitions:CreateEnemyComponents(enemyId)
    local enemyDef = self:GetEnemy(enemyId)
    if not enemyDef then
        warn("Enemy definition not found: " .. tostring(enemyId))
        return nil
    end
    
    local cfg = enemyDef.customConfig or {}
    return {
        EnemyType = Components.create("EnemyType", {
            enemyType = enemyDef.enemyType,
            enemyId = enemyId,  -- Store the original enemy ID for model lookup
            config = cfg
        }),
        EnemyAI = Components.create("EnemyAI", {
            state = "idle",
            detectionRange = cfg.detectionRange or 30,
            attackRange = cfg.attackRange or 5,
            speed = cfg.moveSpeed or 16,
            homePosition = Vector3.new(0, 0, 0)
        }),
        Combat = Components.create("Combat", {
            damage = cfg.damage or 10,
            attackCooldown = cfg.attackSpeed and (1 / cfg.attackSpeed) or 1,
            attackRange = cfg.attackRange or 5
        }),
        CombatStats = Components.create("CombatStats", {
            baseAttack = cfg.damage or 10,
            baseDefense = 5,
            critChance = 0.1,
            critMultiplier = 1.5,
            dodgeChance = 0.05
        }),
        -- Health component removed - enemies now use Humanoid.Health directly
        -- Note: enemyType is stored in the EnemyType component, not as a separate field
    }
end

-- Get random enemy of specific type
function EnemyDefinitions:GetRandomEnemyOfType(enemyType)
    local enemiesOfType = self:GetEnemiesByType(enemyType)
    local ids = {}
    for id, _ in pairs(enemiesOfType) do
        table.insert(ids, id)
    end
    
    if #ids > 0 then
        return ids[math.random(1, #ids)]
    end
    
    return nil
end

-- Get random enemy (any type)
function EnemyDefinitions:GetRandomEnemy()
    local allIds = self:GetAllEnemyIds()
    if #allIds > 0 then
        return allIds[math.random(1, #allIds)]
    end
    return nil
end

-- Validate enemy definition
function EnemyDefinitions:ValidateEnemyDefinition(enemyId)
    local enemy = self:GetEnemy(enemyId)
    if not enemy then
        return false, "Enemy not found: " .. tostring(enemyId)
    end
    
    -- Simple enemy type validation (no longer using Components.isValidType)
    local validTypes = {"melee", "ranged", "special"}
    local isValid = false
    for _, validType in ipairs(validTypes) do
        if enemy.enemyType == validType then
            isValid = true
            break
        end
    end
    if not isValid then
        return false, "Invalid enemy type: " .. tostring(enemy.enemyType)
    end
    
    if not enemy.health or enemy.health <= 0 then
        return false, "Enemy must have valid health"
    end
    
    return true
end

-- Debug function to print all enemies
function EnemyDefinitions:DebugPrintAllEnemies()
    print("🎭 Enemy Definitions Debug:")
    for id, enemy in pairs(self.enemies) do
        print(string.format("  %s (%s): %s", id, enemy.enemyType, enemy.name))
        print(string.format("    Health: %d, Damage: %d", 
            enemy.health, 
            enemy.customConfig and enemy.customConfig.damage or "default"))
    end
end

print("👾 EnemyDefinitions loaded with " .. #EnemyDefinitions:GetAllEnemyIds() .. " enemy types")

return EnemyDefinitions ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="31">
        <Properties>
          <string name="Name">EnemySystemManager</string>
          <string name="Source"><![CDATA[-- SystemManager.lua
-- Simple system execution manager
-- Single responsibility: Run all registered systems each frame

local SystemManager = {}

-- Storage for registered systems
SystemManager.systems = {}

-- Register a system to be updated each frame
function SystemManager.registerSystem(system)
    if system and system.update and type(system.update) == "function" then
        table.insert(SystemManager.systems, system)
        print("✅ Registered system:", system.name or "Unknown")
    else
        warn("❌ Invalid system - must have an 'update' function")
    end
end

-- Run all registered systems
function SystemManager.runAllSystems(deltaTime)
    for _, system in ipairs(SystemManager.systems) do
        local success, err = pcall(system.update, deltaTime)
        if not success then
            warn("❌ System error in", system.name or "Unknown", ":", err)
        end
    end
end

-- Start the main game loop
function SystemManager.startGameLoop()
    local RunService = game:GetService("RunService")
    
    RunService.Heartbeat:Connect(function(deltaTime)
        SystemManager.runAllSystems(deltaTime)
    end)
    
    print("🎮 Game loop started with", #SystemManager.systems, "systems")
end

-- Get system count
function SystemManager.getSystemCount()
    return #SystemManager.systems
end

-- Debug: Print all registered systems
function SystemManager.debugPrint()
    print("🔍 SystemManager Debug:")
    print("  Registered Systems:", #SystemManager.systems)
    for i, system in ipairs(SystemManager.systems) do
        print("   ", i, system.name or "Unknown")
    end
end

return SystemManager ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="32">
        <Properties>
          <string name="Name">EntityManager</string>
          <string name="Source"><![CDATA[-- EntityManager.lua
-- Simple entity and component management system
-- Single responsibility: Create entities and store their components

local EntityManager = {}

-- Core storage
EntityManager.nextEntityId = 1
EntityManager.components = {} -- [componentType][entityId] = componentData

-- Create a new entity (just assigns a unique ID)
function EntityManager.createEntity()
    local entityId = EntityManager.nextEntityId
    EntityManager.nextEntityId = EntityManager.nextEntityId + 1
    return entityId
end

-- Add a component to an entity
function EntityManager.addComponent(entityId, componentType, componentData)
    if not EntityManager.components[componentType] then
        EntityManager.components[componentType] = {}
    end
    EntityManager.components[componentType][entityId] = componentData
end

-- Get a component from an entity
function EntityManager.getComponent(entityId, componentType)
    if EntityManager.components[componentType] then
        return EntityManager.components[componentType][entityId]
    end
    return nil
end

-- Check if entity has a component
function EntityManager.hasComponent(entityId, componentType)
    return EntityManager.getComponent(entityId, componentType) ~= nil
end

-- Remove a component from an entity
function EntityManager.removeComponent(entityId, componentType)
    if EntityManager.components[componentType] then
        EntityManager.components[componentType][entityId] = nil
    end
end

-- Remove an entity and all its components
function EntityManager.removeEntity(entityId)
    for componentType, _ in pairs(EntityManager.components) do
        EntityManager.components[componentType][entityId] = nil
    end
end

-- Get all entities that have a specific component
function EntityManager.getEntitiesWith(componentType)
    local entities = {}
    if EntityManager.components[componentType] then
        for entityId, _ in pairs(EntityManager.components[componentType]) do
            table.insert(entities, entityId)
        end
    end
    return entities
end

-- Get all entities that have ALL specified components
function EntityManager.getEntitiesWithAll(componentTypes)
    local entities = {}
    local firstComponentType = componentTypes[1]
    
    if EntityManager.components[firstComponentType] then
        for entityId, _ in pairs(EntityManager.components[firstComponentType]) do
            local hasAll = true
            for i = 2, #componentTypes do
                if not EntityManager.hasComponent(entityId, componentTypes[i]) then
                    hasAll = false
                    break
                end
            end
            if hasAll then
                table.insert(entities, entityId)
            end
        end
    end
    
    return entities
end

-- Debug: Print all entities and their components
function EntityManager.debugPrint()
    print("🔍 EntityManager Debug:")
    print("  Next Entity ID:", EntityManager.nextEntityId)
    for componentType, componentStorage in pairs(EntityManager.components) do
        print("  Component:", componentType)
        for entityId, componentData in pairs(componentStorage) do
            print("    Entity", entityId, ":", componentData)
        end
    end
end

return EntityManager ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="33">
        <Properties>
          <string name="Name">EventSystem</string>
          <string name="Source"><![CDATA[-- Simple event system for inter-system communication
local EventSystem = {}

-- Registry of event listeners
local eventListeners = {}

-- Subscribe to an event
function EventSystem.Subscribe(eventName, callback, systemName)
    if not eventName or not callback then
        error("EventSystem: eventName and callback are required")
    end
    
    if not eventListeners[eventName] then
        eventListeners[eventName] = {}
    end
    
    local listenerId = #eventListeners[eventName] + 1
    eventListeners[eventName][listenerId] = {
        callback = callback,
        systemName = systemName or "Unknown"
    }
    
    print("EventSystem:", (systemName or "Unknown"), "subscribed to", eventName)
    return listenerId
end

-- Unsubscribe from an event
function EventSystem.Unsubscribe(eventName, listenerId)
    if not eventListeners[eventName] then
        return false
    end
    
    if eventListeners[eventName][listenerId] then
        local listener = eventListeners[eventName][listenerId]
        eventListeners[eventName][listenerId] = nil
        print("EventSystem:", listener.systemName, "unsubscribed from", eventName)
        return true
    end
    
    return false
end

-- Publish an event to all subscribers
function EventSystem.Publish(eventName, data, publisherName)
    if not eventName then
        error("EventSystem: eventName is required")
    end
    
    local listeners = eventListeners[eventName]
    if not listeners then
        return 0 -- No listeners
    end
    
    local notified = 0
    for listenerId, listener in pairs(listeners) do
        if listener and listener.callback then
            local success, errorMessage = pcall(listener.callback, data, publisherName)
            if success then
                notified = notified + 1
            else
                warn("EventSystem: Error notifying", listener.systemName, "for event", eventName .. ":", errorMessage)
            end
        end
    end
    
    if notified > 0 then
        print("EventSystem:", (publisherName or "Unknown"), "published", eventName, "to", notified, "listeners")
    end
    
    return notified
end

-- Get all event names that have listeners
function EventSystem.GetActiveEvents()
    local events = {}
    for eventName, listeners in pairs(eventListeners) do
        local count = 0
        for _ in pairs(listeners) do
            count = count + 1
        end
        if count > 0 then
            events[eventName] = count
        end
    end
    return events
end

-- Clear all event listeners (for testing/cleanup)
function EventSystem.ClearAll()
    eventListeners = {}
    print("EventSystem: All event listeners cleared")
end

return EventSystem ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="34">
        <Properties>
          <string name="Name">FrameBudgetManager</string>
          <string name="Source"><![CDATA[-- Frame Budget Manager - Prevents performance spikes by limiting operations per frame
local RunService = game:GetService("RunService")

local FrameBudgetManager = {}

-- Configuration
local MAX_FRAME_TIME = 1/60 * 0.8 -- Use 80% of 60fps frame time (13.33ms)
local MIN_YIELD_TIME = 1/240 -- Minimum time between operations

-- Private variables
local currentFrameBudget = MAX_FRAME_TIME
local lastFrameStart = 0

-- Reset frame budget at the start of each frame
local function resetFrameBudget()
    lastFrameStart = tick()
    currentFrameBudget = MAX_FRAME_TIME
end

-- Initialize frame budget tracking
RunService.Heartbeat:Connect(resetFrameBudget)

-- Check if we have budget remaining for an operation
function FrameBudgetManager.hasBudget(estimatedTime: number?): boolean
    local timeUsed = tick() - lastFrameStart
    local timeLeft = currentFrameBudget - timeUsed
    local requiredTime = estimatedTime or MIN_YIELD_TIME
    
    return timeLeft >= requiredTime
end

-- Yield if we're running out of frame budget
function FrameBudgetManager.yieldIfNeeded(estimatedTime: number?)
    if not FrameBudgetManager.hasBudget(estimatedTime) then
        task.wait() -- Yield to next frame
    end
end

-- Execute a batch of operations with frame budgeting
function FrameBudgetManager.executeBatch(operations: {() -> ()}, operationTime: number?)
    local timePerOp = operationTime or MIN_YIELD_TIME
    
    for _, operation in ipairs(operations) do
        -- Check if we have budget for this operation
        if not FrameBudgetManager.hasBudget(timePerOp) then
            task.wait() -- Yield to next frame
        end
        
        -- Execute the operation
        operation()
    end
end

-- Execute operations with a maximum count per frame
function FrameBudgetManager.executeWithLimit(operations: {() -> ()}, maxPerFrame: number)
    local executed = 0
    
    for _, operation in ipairs(operations) do
        if executed >= maxPerFrame then
            task.wait() -- Yield to next frame
            executed = 0
        end
        
        operation()
        executed += 1
    end
end

return FrameBudgetManager ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="35">
        <Properties>
          <string name="Name">Hello</string>
          <string name="Source">-- This file is no longer needed, replaced by ECS system
return {}</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="36">
        <Properties>
          <string name="Name">InventoryPredictor</string>
          <string name="Source"><![CDATA[-- Inventory Prediction System - Provides immediate feedback while maintaining server authority
local InventoryPredictor = {}

-- Prediction state
local predictedOperations = {}
local operationIdCounter = 1

-- Configuration
local PREDICTION_TIMEOUT = 5.0 -- Seconds before prediction is considered failed

-- Generate unique operation ID
local function generateOperationId()
    local id = "pred_" .. operationIdCounter
    operationIdCounter += 1
    return id
end

-- Validate if prediction should be applied
local function canPredict(operation, ...)
    local args = {...}
    
    if operation == "pickup_to_inventory" then
        local object, slot = args[1], args[2]
        return object and object.Parent and slot and slot >= 1 and slot <= 10
    elseif operation == "drop_from_inventory" then
        local slot = args[1]
        return slot and slot >= 1 and slot <= 10
    elseif operation == "equip_slot" then
        local slot = args[1]
        return slot == nil or (slot >= 1 and slot <= 10)
    elseif operation == "swap_slots" then
        local slot1, slot2 = args[1], args[2]
        return slot1 and slot2 and slot1 >= 1 and slot1 <= 10 and slot2 >= 1 and slot2 <= 10
    end
    
    return false
end

-- Apply prediction locally
function InventoryPredictor.predict(operation, ...)
    local args = {...}
    
    -- Check if we can predict this operation
    if not canPredict(operation, ...) then
        return nil, "Cannot predict operation"
    end
    
    -- Generate operation ID
    local operationId = generateOperationId()
    
    -- Store prediction
    predictedOperations[operationId] = {
        operation = operation,
        args = args,
        timestamp = tick(),
        applied = false
    }
    
    -- Apply prediction optimistically
    local success, result = InventoryPredictor.applyPrediction(operationId, operation, args)
    
    if success then
        predictedOperations[operationId].applied = true
        return operationId, result
    else
        -- Remove failed prediction
        predictedOperations[operationId] = nil
        return nil, result
    end
end

-- Apply prediction to local state
function InventoryPredictor.applyPrediction(operationId, operation, args)
    -- Get current inventory system
    local InventorySystem = _G.InventorySystem
    if not InventorySystem then
        return false, "InventorySystem not available"
    end
    
    local inventory = InventorySystem:GetInventory()
    local equippedSlot = InventorySystem:GetEquippedSlot()
    
    if operation == "pickup_to_inventory" then
        local object, slot = args[1], args[2]
        
        -- Check if slot is empty
        if inventory[slot] then
            return false, "Slot already occupied"
        end
        
        -- Predict pickup
        return true, {
            type = "pickup",
            slot = slot,
            object = object
        }
        
    elseif operation == "drop_from_inventory" then
        local slot = args[1]
        
        -- Check if slot has item
        if not inventory[slot] then
            return false, "Slot is empty"
        end
        
        -- Predict drop
        return true, {
            type = "drop",
            slot = slot,
            item = inventory[slot]
        }
        
    elseif operation == "equip_slot" then
        local slot = args[1]
        
        -- Predict equip/unequip
        return true, {
            type = "equip",
            previousSlot = equippedSlot,
            newSlot = slot
        }
        
    elseif operation == "swap_slots" then
        local slot1, slot2 = args[1], args[2]
        
        -- Predict swap
        return true, {
            type = "swap",
            slot1 = slot1,
            slot2 = slot2,
            item1 = inventory[slot1],
            item2 = inventory[slot2]
        }
    end
    
    return false, "Unknown operation"
end

-- Confirm prediction when server responds
function InventoryPredictor.confirm(operationId)
    local prediction = predictedOperations[operationId]
    if prediction then
        predictedOperations[operationId] = nil
        return true
    end
    return false
end

-- Rollback prediction if server rejects
function InventoryPredictor.rollback(operationId, reason)
    local prediction = predictedOperations[operationId]
    if not prediction or not prediction.applied then
        return false
    end
    
    warn("Rolling back prediction", operationId, ":", reason or "Server rejected")
    
    -- Get current inventory system
    local InventorySystem = _G.InventorySystem
    if not InventorySystem then
        return false
    end
    
    -- Rollback based on operation type
    local operation = prediction.operation
    local args = prediction.args
    
    if operation == "pickup_to_inventory" then
        -- Remove predicted item from inventory
        local slot = args[2]
        local inventory = InventorySystem:GetInventory()
        inventory[slot] = nil
        
    elseif operation == "drop_from_inventory" then
        -- Restore predicted item to inventory
        local slot = args[1]
        -- Note: We'd need to store the original item data for full rollback
        
    elseif operation == "equip_slot" then
        -- Restore previous equipped slot
        -- This would require more complex state tracking
        
    end
    
    -- Update UI
    InventorySystem:UpdateHotbarUI()
    
    -- Clean up prediction
    predictedOperations[operationId] = nil
    return true
end

-- Clean up expired predictions
function InventoryPredictor.cleanupExpired()
    local currentTime = tick()
    
    for operationId, prediction in pairs(predictedOperations) do
        if currentTime - prediction.timestamp > PREDICTION_TIMEOUT then
            warn("Prediction timed out:", operationId)
            InventoryPredictor.rollback(operationId, "Timeout")
        end
    end
end

-- Get pending predictions
function InventoryPredictor.getPendingCount()
    local count = 0
    for _ in pairs(predictedOperations) do
        count += 1
    end
    return count
end

-- Clear all predictions (for debugging)
function InventoryPredictor.clearAll()
    predictedOperations = {}
end

return InventoryPredictor ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="37">
        <Properties>
          <string name="Name">ItemCategory</string>
          <string name="Source"><![CDATA[--[[
ItemCategory
============
Central table enumerating item categories and shared configs.
Returns a single table with:
  • Tool, Armor, Functional, Item category constants.
  • DEFAULT_COMPONENTS : per-category default component property overrides.
  • USE_HANDLERS      : category→handler module name (client side).
--]]

local ItemCategory = {}

-- Simple enum-like identifiers
ItemCategory.Tool       = "tool"
ItemCategory.Armor      = "armor"
ItemCategory.Functional = "functional"
ItemCategory.Item       = "item"

-- Component defaults that get merged into each item definition
ItemCategory.DEFAULT_COMPONENTS = {
    [ItemCategory.Tool] = {
        Draggable = { force = 12000, maxDistance = 45, dampening = 0.75 },
        Hoverable = { highlightColor = Color3.fromRGB(255, 255, 0) }, -- yellow
        Inventoryable = { stackable = false, maxStack = 1, inventoryIcon = "❔", canPickup = true },
    },
    [ItemCategory.Armor] = {
        Draggable = { force = 10000, maxDistance = 40, dampening = 0.7 },
        Hoverable = { highlightColor = Color3.fromRGB(150, 150, 255) }, -- light blue
        Inventoryable = { stackable = false, maxStack = 1, inventoryIcon = "🗡️", canPickup = true },
    },
    [ItemCategory.Functional] = {
        Draggable = { force = 9000, maxDistance = 40, dampening = 0.7 },
        Hoverable = { highlightColor = Color3.fromRGB(255, 200, 150) },
        Inventoryable = { stackable = false, maxStack = 1, inventoryIcon = "⚙️", canPickup = true },
    },
    [ItemCategory.Item] = {
        Draggable = { force = 8000, maxDistance = 35, dampening = 0.6 },
        Hoverable = { highlightColor = Color3.fromRGB(200, 200, 200) },
        Inventoryable = { stackable = true, maxStack = 20, inventoryIcon = "📦", canPickup = true },
    },
}

-- (Client-side) table that maps category to handler global names used by ToolHandler
ItemCategory.USE_HANDLERS = {
    [ItemCategory.Tool]       = "ToolSystem",
    [ItemCategory.Armor]      = "ArmorSystem",
    [ItemCategory.Functional] = "FunctionalSystem",
}

return ItemCategory ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="38">
        <Properties>
          <string name="Name">ItemDefinitions</string>
          <string name="Source"><![CDATA[-- Item definitions with component configurations
local ItemDefinitions = {}
local Categories = require(script.Parent.ItemCategory)
local ActionConstants = require(script.Parent.ActionConstants)
local Color3 = Color3 -- Assume Color3 is globally available or imported if necessary

-- Helper function for deep merging tables
local function mergeTables(t1, t2)
    local t3 = {}
    for k, v in pairs(t1) do
        t3[k] = v
    end
    for k, v in pairs(t2) do
        if type(v) == "table" and type(t3[k]) == "table" then
            t3[k] = mergeTables(t3[k], v)
        else
            t3[k] = v
        end
    end
    return t3
end

ItemDefinitions.items = {
    -- TOOLS - All use generic attack action with different damage
    stick = {
        name = "Cane",
        description = "Just a stick for walking. Not meant for combat, but will do.",
        model = "CaneModel",
        category = Categories.Tool,
        actionType = ActionConstants.Tool.ATTACK,
        actionData = {
            damage = 5,
            chargeMultiplier = 2.0, -- Charged attack does 2x damage (10 total)
            criticalMultiplier = 3.0 -- Critical attack does 3x damage (15 total)
        },
        components = {
            Draggable = {
                force = 8000,
                maxDistance = 35,
                dampening = 0.6
            },
            Hoverable = {
                displayName = "Walking Stick",
                description = "Just a stick for walking. Not meant for combat, but will do."
            },
            Inventoryable = {
                inventoryIcon = "🪵"
            }
        }
    },
    
    cutlass = {
        name = "Cutlass",
        description = "A sharp curved sword. Effective weapon for combat.",
        model = "CutlassModel",
        category = Categories.Tool,
        actionType = ActionConstants.Tool.ATTACK,
        actionData = {
            damage = 15,
            chargeMultiplier = 2.0, -- Charged attack does 2x damage (30 total)
            criticalMultiplier = 3.0 -- Critical attack does 3x damage (45 total)
        },
        components = {
            Draggable = {
                force = 12000,
                maxDistance = 45,
                dampening = 0.7
            },
            Hoverable = {
                displayName = "Cutlass",
                description = "A sharp curved sword. Effective weapon for combat."
            },
            Inventoryable = {
                inventoryIcon = "⚔️"
            }
        }
    },
    
    -- ARMOR - No click functionality, gives health when equipped
    chestplate = {
        name = "Chestplate",
        description = "Heavy armor that protects your torso and provides health.",
        model = "ChestplateModel",
        category = Categories.Armor,
        armorSlot = "chestplate",
        -- No actionType - armor has no click functionality
        components = {
            Draggable = {
                force = 14000,
                maxDistance = 45,
                dampening = 0.8
            },
            Hoverable = {
                displayName = "Chestplate",
                description = "Heavy armor that protects your torso and provides health.",
                highlightColor = Color3.fromRGB(255, 150, 150)
            },
            Inventoryable = {
                stackable = false,
                maxStack = 1,
                category = Categories.Armor,
                inventoryIcon = "🦺",
                canPickup = true
            }
        }
    },
    
    -- FUNCTIONAL ITEMS - Placeholder for future customization
    healing_essence = {
        name = "Healing Essence",
        description = "A magical essence with healing properties. Use to restore health.",
        model = "HealingEssenceModel",
        category = Categories.Functional,
        actionType = ActionConstants.Functional.HEALING_ESSENCE,
        actionData = {
            -- Placeholder data - you can customize this later
        },
        components = {
            Draggable = {
                force = 6000,
                maxDistance = 30,
                dampening = 0.5
            },
            Hoverable = {
                displayName = "Healing Essence",
                description = "A magical essence with healing properties. Use to restore health.",
                highlightColor = Color3.fromRGB(34, 139, 34)
            },
            Inventoryable = {
                stackable = true,
                maxStack = 10,
                inventoryIcon = "🌿",
                canPickup = true
            }
        }
    },
    
    summoner = {
        name = "Summoner",
        description = "A mysterious artifact with summoning powers. Single use item.",
        model = "SummonerModel",
        category = Categories.Functional,
        actionType = ActionConstants.Functional.SUMMONER,
        actionData = {
            -- Placeholder data - you can customize this later
        },
        components = {
            Draggable = {
                force = 7000,
                maxDistance = 35,
                dampening = 0.6
            },
            Hoverable = {
                displayName = "Summoner",
                description = "A mysterious artifact with summoning powers. Single use item.",
                highlightColor = Color3.fromRGB(128, 0, 128)
            },
            Inventoryable = {
                stackable = false,
                maxStack = 1,
                inventoryIcon = "🔮",
                canPickup = true
            }
        }
    },
    
    revive_plush = {
        name = "Revive Plush",
        description = "A magical plush toy that can bring players back to life. Use near a dead player to revive them.",
        model = "RevivePlushModel",
        category = Categories.Functional,
        actionType = ActionConstants.Functional.REVIVE_PLUSH,
        preventClickConsume = true, -- Prevent normal click consumption
        actionData = {
            -- Revive action data
        },
        components = {
            Draggable = {
                force = 6000,
                maxDistance = 30,
                dampening = 0.5
            },
            Hoverable = {
                displayName = "Revive Plush",
                description = "A magical plush toy that can bring players back to life. Use near a dead player to revive them.",
                highlightColor = Color3.fromRGB(255, 182, 193) -- Light pink
            },
            Inventoryable = {
                stackable = false,
                maxStack = 1,
                inventoryIcon = "🧸",
                canPickup = true
            }
        }
    },
    
    -- ITEMS - No click actions, basic materials
    wood = {
        name = "Wood",
        description = "Basic crafting material from trees. Essential for many recipes.",
        model = "WoodModel",
        category = Categories.Item,
        -- No actionType - items have no click actions
        components = {
            Draggable = {
                force = 6000,
                maxDistance = 30,
                dampening = 0.5
            },
            Hoverable = {
                displayName = "Wood",
                description = "Basic crafting material from trees. Essential for many recipes.",
                highlightColor = Color3.fromRGB(139, 69, 19)
            },
            Inventoryable = {
                stackable = false,
                maxStack = 1,
                canPickup = true
            }
        }
    },
    
    stone = {
        name = "Stone",
        description = "Solid rock material. Useful for construction and crafting.",
        model = "StoneModel",
        category = Categories.Item,
        -- No actionType - items have no click actions
        components = {
            Draggable = {
                force = 8000,
                maxDistance = 35,
                dampening = 0.6
            },
            Hoverable = {
                displayName = "Stone",
                description = "Solid rock material. Useful for construction and crafting.",
                highlightColor = Color3.fromRGB(128, 128, 128)
            },
            Inventoryable = {
                stackable = false,
                maxStack = 1,
                canPickup = true
            }
        }
    }
}

-- Get item definition by ID
function ItemDefinitions:GetItem(itemId)
    return self.items[itemId]
end

-- Get all item IDs
function ItemDefinitions:GetAllItemIds()
    local ids = {}
    for id, _ in pairs(self.items) do
        table.insert(ids, id)
    end
    return ids
end

-- Get items by category
function ItemDefinitions:GetItemsByCategory(category)
    local items = {}
    for id, item in pairs(self.items) do
        if item.category == category then
            items[id] = item
        end
    end
    return items
end

-- Get armor items by slot
function ItemDefinitions:GetArmorBySlot(armorSlot)
    local items = {}
    for id, item in pairs(self.items) do
        if item.category == Categories.Armor and item.armorSlot == armorSlot then
            items[id] = item
        end
    end
    return items
end

return ItemDefinitions ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="39">
        <Properties>
          <string name="Name">ItemLootPools</string>
          <string name="Source"><![CDATA[-- ItemLootPools.luau
-- Defines item pools, rarities, and guaranteed items for each region/pool

local ItemLootPools = {
    ForestLootPool = {
        items = { "cane", "cutlass", "chestplate", "summoner" },
        rarities = { 0.25, 0.15, 0.1, 0.2, 0.15, 0.1, 0.05 },
        guaranteed = { "revive_plush", "cutlass" },
        region = "forest"
    },
    DesertLootPool = {
        items = { "water_flask", "scimitar", "sand_shield", "dagger", "amulet", "main_quest_item_desert" },
        rarities = { 0.2, 0.2, 0.15, 0.2, 0.15, 0.1 },
        guaranteed = { "main_quest_item_desert" },
        region = "desert"
    },
    -- Add more pools as needed
}

return ItemLootPools ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="40">
        <Properties>
          <string name="Name">ItemMapping</string>
          <string name="Source"><![CDATA[-- ItemMapping.luau
-- Maps TraderData item names to ItemDefinitions IDs and provides trade utilities

local ItemMapping = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)

-- Mapping from TraderData item names to ItemDefinitions IDs
-- This allows the trader system to reference actual game items
ItemMapping.TraderToGameItems = {
    -- Trader items that correspond to actual game items
    ["Iron Sword"] = "iron_sword", -- Would need to be added to ItemDefinitions
    ["Steel Armor"] = "steel_armor", -- Would need to be added to ItemDefinitions
    ["Helmet"] = "helmet", -- Already exists in ItemDefinitions
    ["Chestplate"] = "chestplate", -- Already exists in ItemDefinitions
    ["Boots"] = "boots", -- Already exists in ItemDefinitions
    
    -- Basic materials and currency (these would be simple stackable items)
    ["Wood"] = "wood", -- Would need to be added to ItemDefinitions
    ["Iron Ingot"] = "iron_ingot", -- Would need to be added to ItemDefinitions
    ["Silver Coin"] = "silver_coin", -- Would need to be added to ItemDefinitions
    ["Healing Herbs"] = "healing_herbs", -- Would need to be added to ItemDefinitions
    ["Crystal Orb"] = "crystal_orb", -- Would need to be added to ItemDefinitions
    ["Fire Gem"] = "fire_gem", -- Would need to be added to ItemDefinitions
    ["Dragon Scale"] = "dragon_scale", -- Would need to be added to ItemDefinitions
    ["Enchanted Book"] = "enchanted_book", -- Would need to be added to ItemDefinitions
}

-- Reverse mapping for quick lookups
ItemMapping.GameToTraderItems = {}
for traderName, gameId in pairs(ItemMapping.TraderToGameItems) do
    ItemMapping.GameToTraderItems[gameId] = traderName
end

-- Check if a trader item name maps to a valid game item
function ItemMapping:IsValidTraderItem(traderItemName)
    local gameItemId = self.TraderToGameItems[traderItemName]
    if not gameItemId then
        return false, "No mapping found for trader item: " .. traderItemName
    end
    
    local itemDefinition = ItemDefinitions:GetItem(gameItemId)
    if not itemDefinition then
        return false, "Game item definition not found: " .. gameItemId
    end
    
    return true, gameItemId
end

-- Get the game item ID for a trader item name
function ItemMapping:GetGameItemId(traderItemName)
    return self.TraderToGameItems[traderItemName]
end

-- Get the trader item name for a game item ID
function ItemMapping:GetTraderItemName(gameItemId)
    return self.GameToTraderItems[gameItemId]
end

-- Check if an inventory item matches a trader requirement
function ItemMapping:DoesInventoryItemMatch(inventoryItemName, requiredTraderItemName)
    -- Direct name match
    if inventoryItemName == requiredTraderItemName then
        return true
    end
    
    -- Check if the inventory item's name matches the trader item
    local gameItemId = self.TraderToGameItems[requiredTraderItemName]
    if gameItemId then
        local itemDefinition = ItemDefinitions:GetItem(gameItemId)
        if itemDefinition and itemDefinition.name == inventoryItemName then
            return true
        end
    end
    
    return false
end

-- Validate if a player's inventory contains the required items for a trade
function ItemMapping:ValidateTradeRequirements(playerInventory, requirements)
    local missingItems = {}
    local validationResults = {}
    
    for _, requirement in ipairs(requirements) do
        local requiredItem = requirement.item
        local requiredQuantity = requirement.quantity
        local foundQuantity = 0
        local foundSlots = {}
        
        -- Search through player's inventory
        for slot, inventoryItem in pairs(playerInventory) do
            if inventoryItem and self:DoesInventoryItemMatch(inventoryItem.itemName, requiredItem) then
                -- For now, assume all items have quantity 1 (non-stackable)
                -- TODO: Add proper stackable item support
                foundQuantity = foundQuantity + 1
                table.insert(foundSlots, slot)
                
                if foundQuantity >= requiredQuantity then
                    break
                end
            end
        end
        
        validationResults[requiredItem] = {
            required = requiredQuantity,
            found = foundQuantity,
            slots = foundSlots,
            satisfied = foundQuantity >= requiredQuantity
        }
        
        if foundQuantity < requiredQuantity then
            table.insert(missingItems, {
                item = requiredItem,
                required = requiredQuantity,
                found = foundQuantity,
                missing = requiredQuantity - foundQuantity
            })
        end
    end
    
    local isValid = #missingItems == 0
    return isValid, validationResults, missingItems
end

return ItemMapping ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="41">
        <Properties>
          <string name="Name">PrefabLibrary</string>
          <string name="Source"><![CDATA[-- PrefabLibrary.lua
-- Prefab model library for creating standardized models for different entity types
-- Supports generic model variations and extensible prefab definitions

local PrefabLibrary = {}

-- Prefab configuration
local PREFAB_CONFIG = {
	defaultSize = Vector3.new(2, 2, 2),
	defaultMaterial = Enum.Material.Plastic,
	scaleVariation = 0.2, -- +/- 20% size variation
	enableRandomRotation = true,
	maxPrefabsPerType = 10, -- Maximum prefab variations per entity type
}

-- Entity type definitions with prefab configurations
local ENTITY_PREFABS = {
	-- Trees and natural structures
	tree = {
		category = "natural",
		variations = {
			{
				name = "OakTree",
				description = "Standard oak tree with trunk and canopy",
				baseSize = Vector3.new(3, 12, 3),
				parts = {
					{name = "Trunk", size = Vector3.new(1.5, 8, 1.5), position = Vector3.new(0, 0, 0), material = "Wood"},
					{name = "Canopy", size = Vector3.new(8, 6, 8), position = Vector3.new(0, 6, 0), material = "Leaf", shape = "Ball"}
				}
			},
			{
				name = "PineTree",
				description = "Coniferous tree with triangular shape",
				baseSize = Vector3.new(2, 15, 2),
				parts = {
					{name = "Trunk", size = Vector3.new(1, 10, 1), position = Vector3.new(0, 0, 0), material = "Wood"},
					{name = "Branches1", size = Vector3.new(6, 3, 6), position = Vector3.new(0, 7, 0), material = "Leaf", shape = "Cylinder"},
					{name = "Branches2", size = Vector3.new(4, 3, 4), position = Vector3.new(0, 9, 0), material = "Leaf", shape = "Cylinder"},
					{name = "Top", size = Vector3.new(2, 3, 2), position = Vector3.new(0, 11, 0), material = "Leaf", shape = "Cylinder"}
				}
			}
		}
	},
	
	-- Enemy entities
	enemy = {
		category = "hostile",
		variations = {
			{
				name = "HumanoidEnemy",
				description = "Standard humanoid enemy",
				baseSize = Vector3.new(2, 6, 2),
				parts = {
					{name = "Head", shape = "Ball", size = Vector3.new(2, 2, 2), position = Vector3.new(0, 2.5, 0), material = "Flesh"},
					{name = "Torso", size = Vector3.new(2, 2, 1), position = Vector3.new(0, 0, 0), material = "Flesh"},
					{name = "LeftArm", size = Vector3.new(1, 2, 1), position = Vector3.new(-1.5, 0, 0), material = "Flesh"},
					{name = "RightArm", size = Vector3.new(1, 2, 1), position = Vector3.new(1.5, 0, 0), material = "Flesh"},
					{name = "LeftLeg", size = Vector3.new(1, 2, 1), position = Vector3.new(-0.5, -2, 0), material = "Flesh"},
					{name = "RightLeg", size = Vector3.new(1, 2, 1), position = Vector3.new(0.5, -2, 0), material = "Flesh"}
				},
				attachments = {},
				humanoid = {
					health = 100,
					walkSpeed = 16,
					jumpPower = 50,
				}
			},
			{
				name = "Orc",
				description = "Basic enemy with humanoid shape",
				baseSize = Vector3.new(2, 6, 2),
				parts = {
					{name = "Torso", size = Vector3.new(2, 3, 1), position = Vector3.new(0, 0, 0), material = "Flesh"},
					{name = "Head", size = Vector3.new(1.5, 1.5, 1.5), position = Vector3.new(0, 2.25, 0), material = "Flesh", shape = "Ball"},
					{name = "LeftArm", size = Vector3.new(0.8, 2.5, 0.8), position = Vector3.new(-1.4, 0, 0), material = "Flesh"},
					{name = "RightArm", size = Vector3.new(0.8, 2.5, 0.8), position = Vector3.new(1.4, 0, 0), material = "Flesh"},
					{name = "LeftLeg", size = Vector3.new(0.8, 2.5, 0.8), position = Vector3.new(-0.6, -2.75, 0), material = "Flesh"},
					{name = "RightLeg", size = Vector3.new(0.8, 2.5, 0.8), position = Vector3.new(0.6, -2.75, 0), material = "Flesh"}
				}
			},
			{
				name = "Spider",
				description = "Multi-legged creature",
				baseSize = Vector3.new(4, 2, 4),
				parts = {
					{name = "Body", size = Vector3.new(3, 1.5, 2), position = Vector3.new(0, 0, 0), material = "Chitin", shape = "Ball"},
					{name = "Head", size = Vector3.new(1.5, 1, 1.5), position = Vector3.new(0, 0, 1.75), material = "Chitin"},
					{name = "Leg1", size = Vector3.new(0.3, 0.3, 3), position = Vector3.new(-1.5, 0, 1), material = "Chitin"},
					{name = "Leg2", size = Vector3.new(0.3, 0.3, 3), position = Vector3.new(1.5, 0, 1), material = "Chitin"},
					{name = "Leg3", size = Vector3.new(0.3, 0.3, 3), position = Vector3.new(-1.5, 0, -1), material = "Chitin"},
					{name = "Leg4", size = Vector3.new(0.3, 0.3, 3), position = Vector3.new(1.5, 0, -1), material = "Chitin"}
				}
			}
		}
	},
	
	-- Boss entities
	boss = {
		category = "elite",
		variations = {
			{
				name = "DragonBoss",
				description = "Large dragon with wings and breath attack",
				baseSize = Vector3.new(12, 8, 20),
				parts = {
					{name = "Body", size = Vector3.new(8, 6, 12), position = Vector3.new(0, 0, 0), material = "DragonScale"},
					{name = "Head", size = Vector3.new(4, 3, 6), position = Vector3.new(0, 3, 8), material = "DragonScale"},
					{name = "LeftWing", size = Vector3.new(12, 1, 8), position = Vector3.new(-6, 2, -2), material = "Membrane"},
					{name = "RightWing", size = Vector3.new(12, 1, 8), position = Vector3.new(6, 2, -2), material = "Membrane"},
					{name = "Tail", size = Vector3.new(2, 2, 10), position = Vector3.new(0, 0, -8), material = "DragonScale"}
				}
			}
		}
	},
	
	-- Structures and buildings
	structure = {
		category = "building",
		variations = {
			{
				name = "Hut",
				description = "Small dwelling structure",
				baseSize = Vector3.new(8, 8, 8),
				parts = {
					{name = "Walls", size = Vector3.new(8, 6, 8), position = Vector3.new(0, 0, 0), material = "Wood"},
					{name = "Roof", size = Vector3.new(10, 3, 10), position = Vector3.new(0, 4.5, 0), material = "Thatch", shape = "Wedge"},
					{name = "Door", size = Vector3.new(2, 4, 0.5), position = Vector3.new(0, -1, 4), material = "Wood"}
				}
			},
			{
				name = "Tower",
				description = "Tall defensive structure",
				baseSize = Vector3.new(6, 20, 6),
				parts = {
					{name = "Base", size = Vector3.new(6, 16, 6), position = Vector3.new(0, 0, 0), material = "Stone"},
					{name = "Roof", size = Vector3.new(8, 5, 8), position = Vector3.new(0, 10.5, 0), material = "Stone", shape = "Cylinder"},
					{name = "Window1", size = Vector3.new(1, 2, 0.5), position = Vector3.new(3, 4, 0), material = "Glass"},
					{name = "Window2", size = Vector3.new(1, 2, 0.5), position = Vector3.new(-3, 4, 0), material = "Glass"},
					{name = "Window3", size = Vector3.new(1, 2, 0.5), position = Vector3.new(0, 8, 3), material = "Glass"}
				}
			}
		}
	},
	
	-- Resource nodes
	resource = {
		category = "harvestable",
		variations = {
			{
				name = "RockNode",
				description = "Mineable rock formation",
				baseSize = Vector3.new(4, 3, 4),
				parts = {
					{name = "MainRock", size = Vector3.new(4, 3, 4), position = Vector3.new(0, 0, 0), material = "Rock", shape = "Ball"},
					{name = "Crystal", size = Vector3.new(1, 2, 1), position = Vector3.new(1, 1, 1), material = "Crystal"}
				}
			},
			{
				name = "BerryBush",
				description = "Harvestable food source",
				baseSize = Vector3.new(3, 2, 3),
				parts = {
					{name = "Bush", size = Vector3.new(3, 2, 3), position = Vector3.new(0, 0, 0), material = "Leaf", shape = "Ball"},
					{name = "Berries", size = Vector3.new(0.3, 0.3, 0.3), position = Vector3.new(1, 1, 0), material = "Berry", shape = "Ball"},
					{name = "Berries2", size = Vector3.new(0.3, 0.3, 0.3), position = Vector3.new(-0.5, 0.8, 1), material = "Berry", shape = "Ball"},
					{name = "Berries3", size = Vector3.new(0.3, 0.3, 0.3), position = Vector3.new(0, 1.2, -1), material = "Berry", shape = "Ball"}
				}
			}
		}
	},
	
	-- Spawner objects
	spawner = {
		category = "system",
		variations = {
			{
				name = "GenericSpawner",
				description = "A generic spawner object",
				baseSize = Vector3.new(3, 3, 3),
				parts = {
					{name = "Base", size = Vector3.new(3, 1, 3), position = Vector3.new(0, 0, 0), material = "Metal", shape = "Cylinder"},
					{name = "Core", size = Vector3.new(1, 1, 1), position = Vector3.new(0, 1.5, 0), material = "Neon", shape = "Ball"}
				}
			}
		}
	},
	
	-- Default fallback
	default = {
		category = "misc",
		variations = {
			{
				name = "Placeholder",
				description = "Generic placeholder object",
				baseSize = Vector3.new(2, 2, 2),
				parts = {
					{name = "Main", size = Vector3.new(2, 2, 2), position = Vector3.new(0, 0, 0), material = "Neon", shape = "Ball"}
				}
			}
		}
	}
}

-- Material mappings
local MATERIAL_MAPPINGS = {
	Wood = Enum.Material.Wood,
	Leaf = Enum.Material.Grass,
	Flesh = Enum.Material.Plastic,
	Chitin = Enum.Material.Metal,
	DragonScale = Enum.Material.DiamondPlate,
	Membrane = Enum.Material.Fabric,
	Stone = Enum.Material.Concrete,
	Thatch = Enum.Material.Wood,
	Glass = Enum.Material.Glass,
	Rock = Enum.Material.Rock,
	Crystal = Enum.Material.Neon,
	Berry = Enum.Material.Neon,
	Neon = Enum.Material.Neon
}

-- Color mappings for materials
local MATERIAL_COLORS = {
	Wood = Color3.new(0.6, 0.4, 0.2),
	Leaf = Color3.new(0.2, 0.8, 0.2),
	Flesh = Color3.new(0.8, 0.6, 0.5),
	Chitin = Color3.new(0.2, 0.2, 0.2),
	DragonScale = Color3.new(0.8, 0.2, 0.2),
	Membrane = Color3.new(0.4, 0.3, 0.2),
	Stone = Color3.new(0.6, 0.6, 0.6),
	Thatch = Color3.new(0.8, 0.7, 0.4),
	Glass = Color3.new(0.8, 0.9, 1),
	Rock = Color3.new(0.4, 0.4, 0.4),
	Crystal = Color3.new(0.3, 0.8, 1),
	Berry = Color3.new(0.8, 0.2, 0.4),
	Neon = Color3.new(0.2, 0.8, 1)
}

-- ================================
-- PREFAB CREATION FUNCTIONS
-- ================================

-- Get prefab data for a specific entity type and variation
function PrefabLibrary.getPrefabData(entityType, variationName)
	local entityCategory = ENTITY_PREFABS[entityType] or ENTITY_PREFABS.default
	
	if variationName then
		for _, variation in ipairs(entityCategory.variations) do
			if variation.name == variationName then
				return variation
			end
		end
	end
	
	-- Return first variation if no name is specified
	return entityCategory.variations[1]
end

-- Create a prefab model for a given entity type
function PrefabLibrary.createPrefab(entityType, variationName)
	local prefabData = PrefabLibrary.getPrefabData(entityType, variationName)
	if not prefabData then
		warn("Prefab not found for type: " .. entityType .. " and variation: " .. (variationName or "default"))
		return nil
	end

	local model = Instance.new("Model")
	model.Name = prefabData.name

	for i, partData in ipairs(prefabData.parts) do
		local part = Instance.new("Part")
		part.Name = partData.name
		part.Size = partData.size
		part.Position = partData.position
		part.Anchored = false

		if partData.shape then
			part.Shape = Enum.PartType[partData.shape]
		end
		
		local materialName = partData.material or "Plastic"
		part.Material = MATERIAL_MAPPINGS[materialName] or Enum.Material.Plastic
		part.Color = MATERIAL_COLORS[materialName] or Color3.new(1, 1, 1)

		part.Parent = model
		
		if i == 1 then
			model.PrimaryPart = part
		else
			local weld = Instance.new("WeldConstraint")
			weld.Part0 = model.PrimaryPart
			weld.Part1 = part
			weld.Parent = model.PrimaryPart
		end
	end
	
	if prefabData.humanoid then
		local humanoid = Instance.new("Humanoid")
		humanoid.Health = prefabData.humanoid.health or 100
		humanoid.MaxHealth = prefabData.humanoid.health or 100
		humanoid.WalkSpeed = prefabData.humanoid.walkSpeed or 16
		humanoid.JumpPower = prefabData.humanoid.jumpPower or 50
		humanoid.Parent = model
		
		if model.PrimaryPart then
			local rootPart = model.PrimaryPart
			rootPart.Name = "HumanoidRootPart"
			rootPart.CanCollide = true
			rootPart.Anchored = false
		end
	end

	return model
end

local categoryCount = 0
for _ in pairs(ENTITY_PREFABS) do
	categoryCount = categoryCount + 1
end

print("📦 PrefabLibrary loaded with " .. categoryCount .. " entity categories.")

function PrefabLibrary.createEnemyPrefab()
    if prefabCache.enemy then
        return prefabCache.enemy:Clone()
    end
    
    local model = Instance.new("Model")
    model.Name = "EnemyPrefab"
    
    local humanoid = Instance.new("Humanoid")
    humanoid.Name = "Humanoid"
    humanoid.Health = 100
    humanoid.MaxHealth = 100
    humanoid.WalkSpeed = 16
    humanoid.Parent = model
    
    local hrp = Instance.new("Part")
    hrp.Name = "HumanoidRootPart"
    hrp.Size = Vector3.new(2, 2, 1)
    hrp.Position = Vector3.new(0, 3, 0)
    hrp.Anchored = false
    hrp.Massless = true
    hrp.Parent = model
    
    local head = Instance.new("Part")
    head.Name = "Head"
    head.Size = Vector3.new(2, 2, 2)
    head.Position = Vector3.new(0, 5, 0)
    head.Parent = model
    
    local torso = Instance.new("Part")
    torso.Name = "Torso"
    torso.Size = Vector3.new(4, 4, 2)
    torso.Position = Vector3.new(0, 2, 0)
    torso.Parent = model
    
    local leftArm = Instance.new("Part")
    leftArm.Name = "LeftArm"
    leftArm.Size = Vector3.new(1, 4, 1)
    leftArm.Position = Vector3.new(-2.5, 2, 0)
    leftArm.Parent = model
    
    local rightArm = Instance.new("Part")
    rightArm.Name = "RightArm"
    rightArm.Size = Vector3.new(1, 4, 1)
    rightArm.Position = Vector3.new(2.5, 2, 0)
    rightArm.Parent = model
    
    local leftLeg = Instance.new("Part")
    leftLeg.Name = "LeftLeg"
    leftLeg.Size = Vector3.new(1.5, 4, 1.5)
    leftLeg.Position = Vector3.new(-1, -2, 0)
    leftLeg.Parent = model
    
    local rightLeg = Instance.new("Part")
    rightLeg.Name = "RightLeg"
    rightLeg.Size = Vector3.new(1.5, 4, 1.5)
    rightLeg.Position = Vector3.new(1, -2, 0)
    rightLeg.Parent = model
    
    -- Create welds to hold the model together
    local rootWeld = Instance.new("WeldConstraint")
    rootWeld.Part0 = hrp
    rootWeld.Part1 = torso
    rootWeld.Parent = hrp
    
    local headWeld = Instance.new("WeldConstraint")
    headWeld.Part0 = torso
    headWeld.Part1 = head
    headWeld.Parent = torso
    
    local leftArmWeld = Instance.new("WeldConstraint")
    leftArmWeld.Part0 = torso
    leftArmWeld.Part1 = leftArm
    leftArmWeld.Parent = torso
    
    local rightArmWeld = Instance.new("WeldConstraint")
    rightArmWeld.Part0 = torso
    rightArmWeld.Part1 = rightArm
    rightArmWeld.Parent = torso
    
    local leftLegWeld = Instance.new("WeldConstraint")
    leftLegWeld.Part0 = torso
    leftLegWeld.Part1 = leftLeg
    leftLegWeld.Parent = torso
    
    local rightLegWeld = Instance.new("WeldConstraint")
    rightLegWeld.Part0 = torso
    rightLegWeld.Part1 = rightLeg
    rightLegWeld.Parent = torso
    
    prefabCache.enemy = model
    
    return model:Clone()
end

function PrefabLibrary.get(name)
    if prefabs[name] then
        return prefabs[name]
    end
    
    -- In a real scenario, you would load these from ReplicatedStorage
    -- For this test, we'll just create a simple part
    local prefab = Instance.new("Part")
    prefab.Size = Vector3.new(4, 4, 4)
    prefab.Anchored = true
    prefab.Name = name
    
    prefabs[name] = prefab
    return prefab
end

function PrefabLibrary.create(name, properties)
    local template = PrefabLibrary.get(name)
    local newInstance = template:Clone()
    
    for prop, value in pairs(properties) do
        newInstance[prop] = value
    end
    
    return newInstance
end

return PrefabLibrary ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="42">
        <Properties>
          <string name="Name">RemoteEventBatcher</string>
          <string name="Source"><![CDATA[-- RemoteEvent Batcher - Reduces network overhead by batching multiple events
local RunService = game:GetService("RunService")

local RemoteEventBatcher = {}

-- Configuration
local BATCH_INTERVAL = 1/30 -- 30fps batching (33ms)
local MAX_BATCH_SIZE = 10 -- Maximum events per batch

-- Private variables
local pendingBatches: {[RemoteEvent]: {{[string]: any}}} = {}
local batchConnections: {[RemoteEvent]: thread} = {}

-- Send a batch of events
local function sendBatch(remote: RemoteEvent, events: {{[string]: any}})
    if #events == 0 then return end
    
    if #events == 1 then
        -- Single event, send directly for lower latency
        remote:FireAllClients(events[1])
    else
        -- Multiple events, send as batch
        remote:FireAllClients({
            batchedEvents = events,
            isBatch = true
        })
    end
end

-- Process pending batches for a specific RemoteEvent
local function processBatch(remote: RemoteEvent)
    local batch = pendingBatches[remote]
    if batch and #batch > 0 then
        sendBatch(remote, batch)
        pendingBatches[remote] = {} -- Clear the batch
    end
end

-- ENHANCED: Add an event to the batch queue with memory management
function RemoteEventBatcher.queueEvent(remote: RemoteEvent, eventData: {[string]: any})
    -- Validate remote exists and is still valid
    if not remote or not remote.Parent then
        warn("BATCHER WARNING: Attempted to queue event for invalid remote")
        return
    end
    
    -- Initialize batch for this remote if needed
    if not pendingBatches[remote] then
        pendingBatches[remote] = {}
        
        print("BATCHER DEBUG: Initializing batch for remote:", remote.Name)
        
        -- Set up batching timer for this remote
        batchConnections[remote] = task.spawn(function()
            local batchStartTime = tick()
            while pendingBatches[remote] do
                task.wait(BATCH_INTERVAL)
                
                -- ENHANCED: Check if remote is still valid
                if not remote or not remote.Parent then
                    warn("BATCHER WARNING: Remote became invalid, stopping batch processing")
                    break
                end
                
                processBatch(remote)
                
                -- ENHANCED: Prevent runaway batch connections
                local batchDuration = tick() - batchStartTime
                if batchDuration > 300 then -- 5 minutes max
                    print("BATCHER DEBUG: Batch connection timeout after", batchDuration, "seconds")
                    break
                end
            end
            
            -- Cleanup when done
            if batchConnections[remote] then
                batchConnections[remote] = nil
            end
        end)
    end
    
    -- ENHANCED: Prevent memory leaks from oversized batches
    if #pendingBatches[remote] >= MAX_BATCH_SIZE * 2 then
        warn("BATCHER WARNING: Batch size exceeded limit, forcing immediate send")
        processBatch(remote)
    end
    
    -- Add event to batch
    table.insert(pendingBatches[remote], eventData)
    
    -- Send immediately if batch is full
    if #pendingBatches[remote] >= MAX_BATCH_SIZE then
        processBatch(remote)
    end
end

-- Send all pending events immediately (for urgent events)
function RemoteEventBatcher.flushAll()
    for remote, _ in pairs(pendingBatches) do
        processBatch(remote)
    end
end

-- Send pending events for a specific RemoteEvent immediately
function RemoteEventBatcher.flush(remote: RemoteEvent)
    processBatch(remote)
end

-- Clean up batching for a specific RemoteEvent
function RemoteEventBatcher.cleanup(remote: RemoteEvent)
    -- Send any remaining events
    processBatch(remote)
    
    -- Clean up
    if batchConnections[remote] then
        task.cancel(batchConnections[remote])
        batchConnections[remote] = nil
    end
    pendingBatches[remote] = nil
end

-- Clean up all batching
function RemoteEventBatcher.cleanupAll()
    for remote, _ in pairs(pendingBatches) do
        RemoteEventBatcher.cleanup(remote)
    end
end

return RemoteEventBatcher ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="43">
        <Properties>
          <string name="Name">RemoteEvents</string>
          <string name="Source"><![CDATA[-- Remote events for client-server communication (merged with dialogue system)
local RemoteEvents = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Function to create RemoteEvent if it doesn't exist
local function createRemoteEvent(name)
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then
		return existing
	end
	
	local remoteEvent = Instance.new("RemoteEvent")
	remoteEvent.Name = name
	remoteEvent.Parent = ReplicatedStorage
	return remoteEvent
end

-- Function to create RemoteFunction if it doesn't exist
local function createRemoteFunction(name)
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then
		return existing
	end
	
	local remoteFunction = Instance.new("RemoteFunction")
	remoteFunction.Name = name
	remoteFunction.Parent = ReplicatedStorage
	return remoteFunction
end

if RunService:IsServer() then
    -- Server: Create the RemoteFunctions (existing inventory system)
    local dragRequestRemote = createRemoteFunction("DragRequest")
    local inventoryRequestRemote = createRemoteFunction("InventoryRequest")
    local armorRequestRemote = createRemoteFunction("ArmorRequest")
    
    -- Server: Create dialogue RemoteEvents
    local startDialogueRemote = createRemoteEvent("StartDialogue")
    local displayDialogueRemote = createRemoteEvent("DisplayDialogue")
    local processChoiceRemote = createRemoteEvent("ProcessChoice")
    local endDialogueRemote = createRemoteEvent("EndDialogue")
    local showOverheadTextRemote = createRemoteEvent("ShowOverheadText")
    local openTradeMenuRemote = createRemoteEvent("OpenTradeMenu")
    local openTraderShopRemote = createRemoteEvent("OpenTraderShop")
    local closeTraderShopRemote = createRemoteEvent("CloseTraderShop")
    local tradeRequestRemote = createRemoteFunction("TradeRequest")
    local updateInventoryRemote = createRemoteEvent("UpdateInventory")
    
    -- Server: Create damage system RemoteEvents
    local applyDamageRemote = createRemoteEvent("ApplyDamage")
    
    -- Server: Create item consumption RemoteEvents
    local consumeItemRequestRemote = createRemoteEvent("ConsumeItemRequest")
    local consumeItemResponseRemote = createRemoteEvent("ConsumeItemResponse")
    
    -- Server: Create boss spawn RemoteEvent
    local spawnBossRemote = createRemoteEvent("SpawnBoss")
    
    -- Server: Create boss landed RemoteEvent
    local bossLandedRemote = createRemoteEvent("BossLanded")
    
    -- Server: Create boss health update RemoteEvent
    local bossHealthUpdateRemote = createRemoteEvent("BossHealthUpdate")

    -- Server: Create prayer system RemoteEvent
    local prayerRequestRemote = createRemoteEvent("PrayerRequest")

    -- Server: Create time system RemoteEvents
    local clockUpdateRemote = createRemoteEvent("ClockUpdate")
    local statsUpdateRemote = createRemoteEvent("StatsUpdate")
    
    -- Server: Create revive system RemoteEvents
    local reviveRequestRemote = createRemoteEvent("ReviveRequest")
    local reviveResponseRemote = createRemoteEvent("ReviveResponse")
    
    print("Server created DragRequest RemoteFunction") -- Debug
    print("Server created InventoryRequest RemoteFunction") -- Debug
    print("Server created ArmorRequest RemoteFunction") -- Debug
    print("Server created dialogue RemoteEvents") -- Debug
    
    -- Existing inventory system remotes
    RemoteEvents.DragRequest = dragRequestRemote
    RemoteEvents.InventoryRequest = inventoryRequestRemote
    RemoteEvents.ArmorRequest = armorRequestRemote
    
    -- Dialogue system remotes
    RemoteEvents.StartDialogue = startDialogueRemote
    RemoteEvents.DisplayDialogue = displayDialogueRemote
    RemoteEvents.ProcessChoice = processChoiceRemote
    RemoteEvents.EndDialogue = endDialogueRemote
    RemoteEvents.ShowOverheadText = showOverheadTextRemote
    RemoteEvents.OpenTradeMenu = openTradeMenuRemote
    RemoteEvents.OpenTraderShop = openTraderShopRemote
    RemoteEvents.CloseTraderShop = closeTraderShopRemote
    RemoteEvents.TradeRequest = tradeRequestRemote
    RemoteEvents.UpdateInventory = updateInventoryRemote
    
    -- Damage system remotes
    RemoteEvents.ApplyDamage = applyDamageRemote
    
    -- Item consumption remotes
    RemoteEvents.ConsumeItemRequest = consumeItemRequestRemote
    RemoteEvents.ConsumeItemResponse = consumeItemResponseRemote
    
    -- Boss spawn remote
    RemoteEvents.SpawnBoss = spawnBossRemote
    
    -- Boss landed remote
    RemoteEvents.BossLanded = bossLandedRemote
    
    -- Boss health update remote
    RemoteEvents.BossHealthUpdate = bossHealthUpdateRemote

    -- Time system remotes
    RemoteEvents.ClockUpdate = clockUpdateRemote
    RemoteEvents.StatsUpdate = statsUpdateRemote
    
    -- Revive system remotes
    RemoteEvents.ReviveRequest = reviveRequestRemote
    RemoteEvents.ReviveResponse = reviveResponseRemote
else
    -- Client: Wait for the RemoteFunctions to be created by server (existing)
    local dragRequestRemote = ReplicatedStorage:WaitForChild("DragRequest")
    local inventoryRequestRemote = ReplicatedStorage:WaitForChild("InventoryRequest")
    local armorRequestRemote = ReplicatedStorage:WaitForChild("ArmorRequest")
    
    -- Client: Wait for dialogue RemoteEvents
    local startDialogueRemote = ReplicatedStorage:WaitForChild("StartDialogue")
    local displayDialogueRemote = ReplicatedStorage:WaitForChild("DisplayDialogue")
    local processChoiceRemote = ReplicatedStorage:WaitForChild("ProcessChoice")
    local endDialogueRemote = ReplicatedStorage:WaitForChild("EndDialogue")
    local showOverheadTextRemote = ReplicatedStorage:WaitForChild("ShowOverheadText")
    local openTradeMenuRemote = ReplicatedStorage:WaitForChild("OpenTradeMenu")
    local openTraderShopRemote = ReplicatedStorage:WaitForChild("OpenTraderShop")
    local closeTraderShopRemote = ReplicatedStorage:WaitForChild("CloseTraderShop")
    local tradeRequestRemote = ReplicatedStorage:WaitForChild("TradeRequest")
    local updateInventoryRemote = ReplicatedStorage:WaitForChild("UpdateInventory")
    
    -- Client: Wait for damage system RemoteEvents
    local applyDamageRemote = ReplicatedStorage:WaitForChild("ApplyDamage")
    
    -- Client: Wait for item consumption RemoteEvents
    local consumeItemRequestRemote = ReplicatedStorage:WaitForChild("ConsumeItemRequest")
    local consumeItemResponseRemote = ReplicatedStorage:WaitForChild("ConsumeItemResponse")
    
    -- Client: Wait for boss spawn RemoteEvent
    local spawnBossRemote = ReplicatedStorage:WaitForChild("SpawnBoss")
    
    -- Client: Wait for boss landed RemoteEvent
    local bossLandedRemote = ReplicatedStorage:WaitForChild("BossLanded")
    
    -- Client: Wait for boss health update RemoteEvent
    local bossHealthUpdateRemote = ReplicatedStorage:WaitForChild("BossHealthUpdate")
    
    -- Client: Wait for prayer system RemoteEvent
    local prayerRequestRemote = ReplicatedStorage:WaitForChild("PrayerRequest")

    -- Client: Wait for time system RemoteEvents
    local clockUpdateRemote = ReplicatedStorage:WaitForChild("ClockUpdate")
    local statsUpdateRemote = ReplicatedStorage:WaitForChild("StatsUpdate")
    
    -- Client: Wait for revive system RemoteEvents
    local reviveRequestRemote = ReplicatedStorage:WaitForChild("ReviveRequest")
    local reviveResponseRemote = ReplicatedStorage:WaitForChild("ReviveResponse")
    
    print("Client found DragRequest RemoteFunction") -- Debug
    print("Client found InventoryRequest RemoteFunction") -- Debug
    print("Client found ArmorRequest RemoteFunction") -- Debug
    print("Client found dialogue RemoteEvents") -- Debug
    
    -- Existing inventory system remotes
    RemoteEvents.DragRequest = dragRequestRemote
    RemoteEvents.InventoryRequest = inventoryRequestRemote
    RemoteEvents.ArmorRequest = armorRequestRemote
    
    -- Dialogue system remotes
    RemoteEvents.StartDialogue = startDialogueRemote
    RemoteEvents.DisplayDialogue = displayDialogueRemote
    RemoteEvents.ProcessChoice = processChoiceRemote
    RemoteEvents.EndDialogue = endDialogueRemote
    RemoteEvents.ShowOverheadText = showOverheadTextRemote
    RemoteEvents.OpenTradeMenu = openTradeMenuRemote
    RemoteEvents.OpenTraderShop = openTraderShopRemote
    RemoteEvents.CloseTraderShop = closeTraderShopRemote
    RemoteEvents.TradeRequest = tradeRequestRemote
    RemoteEvents.UpdateInventory = updateInventoryRemote
    
    -- Damage system remotes
    RemoteEvents.ApplyDamage = applyDamageRemote
    
    -- Item consumption remotes
    RemoteEvents.ConsumeItemRequest = consumeItemRequestRemote
    RemoteEvents.ConsumeItemResponse = consumeItemResponseRemote
    
    -- Boss spawn remote
    RemoteEvents.SpawnBoss = spawnBossRemote
    
    -- Boss landed remote
    RemoteEvents.BossLanded = bossLandedRemote
    
    -- Boss health update remote
    RemoteEvents.BossHealthUpdate = bossHealthUpdateRemote
    
    -- Prayer system remote
    RemoteEvents.PrayerRequest = prayerRequestRemote

    -- Time system remotes
    RemoteEvents.ClockUpdate = clockUpdateRemote
    RemoteEvents.StatsUpdate = statsUpdateRemote
    
    -- Revive system remotes
    RemoteEvents.ReviveRequest = reviveRequestRemote
    RemoteEvents.ReviveResponse = reviveResponseRemote
end

return RemoteEvents ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="44">
        <Properties>
          <string name="Name">RewardConfig</string>
          <string name="Source"><![CDATA[-- RewardConfig.luau
-- Configuration for altar reward system

local RewardConfig = {}

-- Reward configuration for summoner item
RewardConfig.SUMMONER_REWARD = {
    itemId = "summoner",
    spawnPosition = "altar_center", -- or "random_near_altar"
    spawnOffset = Vector3.new(0, 2, 0) -- Offset above altar
}

-- Reward configuration for philosopher's stone
RewardConfig.PHILOSOPHERS_STONE_REWARD = {
    itemId = "philosophers_stone",
    spawnPosition = "altar_center", -- or "random_near_altar"
    spawnOffset = Vector3.new(0, 2, 0) -- Offset above altar
}

-- Spawn position types
RewardConfig.SPAWN_POSITIONS = {
    altar_center = function(altar)
        return altar.Position + Vector3.new(0, 2, 0)
    end,
    random_near_altar = function(altar)
        local radius = 5
        local angle = math.random() * 2 * math.pi
        local distance = math.random() * radius
        return altar.Position + Vector3.new(
            math.cos(angle) * distance,
            2,
            math.sin(angle) * distance
        )
    end
}

return RewardConfig ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="45">
        <Properties>
          <string name="Name">SacrificeData</string>
          <string name="Source"><![CDATA[-- SacrificeData.luau
-- Data structures for sacrifice tracking

local SacrificeData = {}

-- Sacrifice tracking structure
SacrificeData.SacrificeTracker = {}
SacrificeData.SacrificeTracker.__index = SacrificeData.SacrificeTracker

function SacrificeData.SacrificeTracker.new()
    local self = setmetatable({
        sacrifices = {}, -- [ragdoll] = true
        playerSacrifices = {}, -- [ragdoll] = true (player sacrifices)
        count = 0,
        playerCount = 0, -- Count of player sacrifices
        altar = nil,
        lastTriggerTime = 0,
        hasPrayed = false, -- Track if player has prayed to the figure
        prayerFigure = nil -- Reference to the prayer figure
    }, SacrificeData.SacrificeTracker)
    
    return self
end

-- Add a sacrifice to the tracker
function SacrificeData.SacrificeTracker:addSacrifice(ragdoll)
    if not self.sacrifices[ragdoll] then
        self.sacrifices[ragdoll] = true
        self.count = self.count + 1
        print("Added sacrifice to altar. Count:", self.count)
        return true
    end
    return false
end

-- Remove a sacrifice from the tracker
function SacrificeData.SacrificeTracker:removeSacrifice(ragdoll)
    if self.sacrifices[ragdoll] then
        self.sacrifices[ragdoll] = nil
        self.count = self.count - 1
        print("Removed sacrifice from altar. Count:", self.count)
        return true
    end
    return false
end

-- Add a player sacrifice to the tracker
function SacrificeData.SacrificeTracker:addPlayerSacrifice(ragdoll)
    if not self.playerSacrifices[ragdoll] then
        self.playerSacrifices[ragdoll] = true
        self.playerCount = self.playerCount + 1
        print("Added player sacrifice to altar. Player count:", self.playerCount)
        return true
    end
    return false
end

-- Remove a player sacrifice from the tracker
function SacrificeData.SacrificeTracker:removePlayerSacrifice(ragdoll)
    if self.playerSacrifices[ragdoll] then
        self.playerSacrifices[ragdoll] = nil
        self.playerCount = self.playerCount - 1
        print("Removed player sacrifice from altar. Player count:", self.playerCount)
        return true
    end
    return false
end

-- Check if altar has enough sacrifices
function SacrificeData.SacrificeTracker:hasEnoughSacrifices()
    -- If there are any player sacrifices, only need 1
    if self.playerCount > 0 then
        return true
    end
    -- Otherwise need 3 enemy sacrifices
    return self.count >= 3
end

-- Get all current sacrifices
function SacrificeData.SacrificeTracker:getSacrifices()
    local sacrifices = {}
    for ragdoll, _ in pairs(self.sacrifices) do
        table.insert(sacrifices, ragdoll)
    end
    return sacrifices
end

-- Get all current player sacrifices
function SacrificeData.SacrificeTracker:getPlayerSacrifices()
    local playerSacrifices = {}
    for ragdoll, _ in pairs(self.playerSacrifices) do
        table.insert(playerSacrifices, ragdoll)
    end
    return playerSacrifices
end

-- Check if altar has any player sacrifices
function SacrificeData.SacrificeTracker:hasPlayerSacrifices()
    return self.playerCount > 0
end

-- Clear all sacrifices
function SacrificeData.SacrificeTracker:clearSacrifices()
    self.sacrifices = {}
    self.playerSacrifices = {}
    self.count = 0
    self.playerCount = 0
    self.hasPrayed = false -- Reset prayer state when sacrifices are cleared
end

-- Check if altar is on cooldown
function SacrificeData.SacrificeTracker:isOnCooldown()
    return (tick() - self.lastTriggerTime) < 30 -- 30 second cooldown
end

-- Set trigger time (when reward was spawned)
function SacrificeData.SacrificeTracker:setTriggerTime()
    self.lastTriggerTime = tick()
end

-- Set prayer state
function SacrificeData.SacrificeTracker:setPrayed(hasPrayed)
    self.hasPrayed = hasPrayed
    print("Prayer state updated:", hasPrayed)
end

-- Check if player has prayed
function SacrificeData.SacrificeTracker:hasPrayed()
    return self.hasPrayed
end

-- Set prayer figure reference
function SacrificeData.SacrificeTracker:setPrayerFigure(figure)
    self.prayerFigure = figure
end

-- Get prayer figure reference
function SacrificeData.SacrificeTracker:getPrayerFigure()
    return self.prayerFigure
end

return SacrificeData ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="46">
        <Properties>
          <string name="Name">SystemManager</string>
          <string name="Source"><![CDATA[-- System manager for dependency injection and inter-system communication
local SystemManager = {}

-- Registry of all systems
local systems = {}

-- Register a system with the manager
function SystemManager.RegisterSystem(systemName, systemInstance)
    if not systemName or not systemInstance then
        error("SystemManager: systemName and systemInstance are required")
    end
    
    systems[systemName] = systemInstance
    print("SystemManager: Registered system:", systemName)
end

-- Get a system by name
function SystemManager.GetSystem(systemName)
    local system = systems[systemName]
    if not system then
        warn("SystemManager: System not found:", systemName)
    end
    return system
end

-- Check if a system is registered
function SystemManager.HasSystem(systemName)
    return systems[systemName] ~= nil
end

-- Get all registered system names
function SystemManager.GetRegisteredSystems()
    local systemNames = {}
    for name, _ in pairs(systems) do
        table.insert(systemNames, name)
    end
    return systemNames
end

-- Call a method on a system if it exists (safe call pattern)
function SystemManager.CallSystem(systemName, methodName, ...)
    local system = systems[systemName]
    if not system then
        warn("SystemManager: System not found:", systemName)
        return nil
    end
    
    local method = system[methodName]
    if not method or type(method) ~= "function" then
        warn("SystemManager: Method not found:", methodName, "on system:", systemName)
        return nil
    end
    
    local success, result = pcall(method, system, ...)
    if not success then
        warn("SystemManager: Error calling", methodName, "on", systemName .. ":", result)
        return nil
    end
    
    return result
end

-- Initialize all registered systems
function SystemManager.InitializeAllSystems()
    print("SystemManager: Initializing all systems...")
    
    for systemName, system in pairs(systems) do
        if system.Initialize and type(system.Initialize) == "function" then
            local success, errorMessage = pcall(system.Initialize, system)
            if success then
                print("SystemManager: Initialized", systemName)
            else
                warn("SystemManager: Failed to initialize", systemName .. ":", errorMessage)
            end
        else
            print("SystemManager:", systemName, "has no Initialize method")
        end
    end
    
    print("SystemManager: System initialization complete")
end

-- Clear all systems (for testing/cleanup)
function SystemManager.ClearSystems()
    systems = {}
    print("SystemManager: All systems cleared")
end

return SystemManager ]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="47">
        <Properties>
          <string name="Name">Systems</string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="48">
        <Properties>
          <string name="Name">ToolHandler</string>
          <string name="Source"><![CDATA[-- This script runs on the client and is attached to each tool when equipped.
-- It handles the "use" action (left-click) and dispatches to the correct system based on category.

local Tool = script.Parent
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

print("DEBUG: ToolHandler script starting for tool:", Tool.Name)

-- Shared Modules
local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)
local Categories = require(ReplicatedStorage.Shared.ItemCategory)

-- Client Systems - Access through StarterPlayerScripts
local player = Players.LocalPlayer
local ClientSystems = player.PlayerScripts.Client.Systems
local ToolSystem = require(ClientSystems.ToolSystem)
local ArmorSystem = require(ClientSystems.ArmorSystem)
local FunctionalSystem = require(ClientSystems.FunctionalSystem)

local camera = workspace.CurrentCamera

-- Debounce to prevent spamming the use action
local debounce = false
local DEBOUNCE_TIME = 0.25 -- 250ms

-- Charged attack configuration
local CHARGE_CONFIG = {
    CHARGE_THRESHOLD = 1.5, -- Seconds to hold for charged attack
}

-- Charge state tracking
local isCharging = false
local chargeStartTime = 0
local chargeConnection = nil
local isToolEquipped = false
local isCriticalWindowActive = false -- Track if critical window is open

-- R6 Animation system for charged attacks
local R6_ANIMATION = {
    MAX_ANGLE = 120, -- degrees (0° to 120° overhead swing)
    PHASES = {
        {duration = 0.5, progress = 0.6}, -- Fast phase: 60% of angle in first 0.5s
        {duration = 0.5, progress = 0.3}, -- Medium phase: 30% of angle in next 0.5s  
        {duration = 0.5, progress = 0.1}, -- Slow phase: 10% of angle in final 0.5s
    }
}

-- Animation state tracking
local chargeAnimationConnection = nil
local originalRightShoulderC0 = nil
local currentRightShoulder = nil
local lastAngleUpdate = 0

-- Animation configuration
local SWING_ANIMATION_ID = "rbxassetid://110625725642736" -- Custom swing animation

-- Shape cast configuration - easy to adjust
local SHAPE_CAST_CONFIG = {
    radius = Vector3.new(2, 5, 2), -- Size of the detection area (player-sized: 2 wide, 5 tall, 2 deep)
    distance = 1, -- Distance in front of player (closer for more precise combat)
    ignoreFloor = true, -- Whether to ignore floor/ground
    visualDuration = 0.1, -- How long visual feedback lasts
}

print("DEBUG: ToolHandler modules loaded, setting up functions...")

local function createVisualShapeCast(centerPosition, radius, color, hasHit)
    -- Create the main detection area visualization
    local shapePart = Instance.new("Part")
    shapePart.Name = "DebugShapeCast"
    shapePart.Anchored = true
    shapePart.CanCollide = false
    shapePart.Shape = Enum.PartType.Block
    shapePart.Material = Enum.Material.ForceField
    shapePart.BrickColor = BrickColor.new(color)
    shapePart.Transparency = 0.7
    shapePart.Size = radius
    shapePart.CFrame = CFrame.new(centerPosition)
    shapePart.Parent = workspace
    
    -- Create center indicator (smaller cube in the middle)
    local centerPart = Instance.new("Part")
    centerPart.Name = "DebugShapeCastCenter"
    centerPart.Anchored = true
    centerPart.CanCollide = false
    centerPart.Shape = Enum.PartType.Block
    centerPart.Material = Enum.Material.Neon
    local centerColor = hasHit and "Bright green" or "Bright red"
    centerPart.BrickColor = BrickColor.new(centerColor)
    centerPart.Transparency = 0.3
    centerPart.Size = Vector3.new(1, 1, 1) -- Small center square
    centerPart.CFrame = CFrame.new(centerPosition)
    centerPart.Parent = workspace
    
    -- Remove after configured duration
    Debris:AddItem(shapePart, SHAPE_CAST_CONFIG.visualDuration)
    Debris:AddItem(centerPart, SHAPE_CAST_CONFIG.visualDuration)
    
    return shapePart, centerPart
end

local function performShapeCast(character, centerPosition, radius)
    -- Use GetPartBoundsInBox for shape casting detection
    -- Create CFrame oriented to face the same direction as the player
    local cameraDirection = camera.CFrame.LookVector
    local playerForward = Vector3.new(cameraDirection.X, 0, cameraDirection.Z).Unit -- Keep horizontal only
    local orientedCFrame = CFrame.new(centerPosition, centerPosition + playerForward)
    local partBounds = workspace:GetPartBoundsInBox(orientedCFrame, radius)
    local detectedParts = {}
    
    -- Filter out unwanted parts
    for _, part in ipairs(partBounds) do
        -- Skip character parts
        if part.Parent ~= character and not part:IsDescendantOf(character) then
            -- Skip debug visualization parts (our own hitboxes)
            local isDebugPart = part.Name:find("DebugShapeCast") or 
                               part.Name:find("DebugHitbox") or 
                               part.Name:find("DebugRay")
            
            if not isDebugPart then
                -- Skip floor/ground if configured
                if SHAPE_CAST_CONFIG.ignoreFloor then
                    -- Check if part is likely floor (low Y position, large size, or named like ground)
                    local isFloor = part.Name:lower():find("floor") or 
                                   part.Name:lower():find("ground") or 
                                   part.Name:lower():find("baseplate") or
                                   part.Name:lower():find("spawn") or
                                   (part.Size.X > 50 and part.Size.Z > 50 and part.Position.Y < centerPosition.Y - 2)
                    
                    if not isFloor then
                        table.insert(detectedParts, part)
                    end
                else
                    table.insert(detectedParts, part)
                end
            end
        end
    end
    
    return detectedParts
end

-- Helper function to check if a part can take damage
local function canPartTakeDamage(part)
    if not part or not part.Parent then
        return false
    end
    
    -- Check if the part's parent has a Humanoid (NPCs, players)
    local parent = part.Parent
    if parent and parent:FindFirstChild("Humanoid") then
        return true
    end
    
    -- Check if the part is part of a character model
    -- Look for Humanoid in the model hierarchy
    local model = part.Parent
    while model and model ~= workspace do
        if model:FindFirstChild("Humanoid") then
            return true
        end
        model = model.Parent
    end
    
    return false
end

-- Helper function to find the best damage target from detected parts
local function findBestDamageTarget(detectedParts)
    -- Prioritize parts that can take damage
    for _, part in ipairs(detectedParts) do
        if canPartTakeDamage(part) then
            return part
        end
    end
    
    -- If no damageable targets, return the first part (for other interactions)
    return detectedParts[1]
end

-- Forward declaration for charge functions
local onUse
local cleanupR6ChargeAnimation
local cancelCharging

-- R6 Animation System Functions
local function validateR6Character(character)
    if not character then return false end
    
    local torso = character:FindFirstChild("Torso")
    if not torso then return false end
    
    local rightShoulder = torso:FindFirstChild("Right Shoulder")
    if not rightShoulder then return false end
    
    return true, torso, rightShoulder
end

local function calculateChargeAngle(elapsedTime)
    local maxAngle = R6_ANIMATION.MAX_ANGLE
    local progress = 0
    
    if elapsedTime <= 0.5 then
        -- Fast phase: 60% of angle in first 0.5s
        progress = (elapsedTime / 0.5) * 0.6
    elseif elapsedTime <= 1.0 then
        -- Medium phase: 30% of angle in next 0.5s
        local phaseProgress = (elapsedTime - 0.5) / 0.5
        progress = 0.6 + (phaseProgress * 0.3)
    else
        -- Slow phase: 10% of angle in final 0.5s
        local phaseProgress = math.min((elapsedTime - 1.0) / 0.5, 1.0)
        progress = 0.9 + (phaseProgress * 0.1)
    end
    
    return maxAngle * progress
end

local function updateR6ArmPosition(angleDegrees)
    if not currentRightShoulder or not originalRightShoulderC0 then return end
    
    -- Only update if angle changed significantly (performance optimization)
    if math.abs(angleDegrees - lastAngleUpdate) < 1 then return end
    
    local rotationAngle = math.rad(angleDegrees)
    local rotationCFrame = CFrame.Angles(0, 0, rotationAngle) -- Z-axis rotation for arm swing
    currentRightShoulder.C0 = originalRightShoulderC0 * rotationCFrame
    
    lastAngleUpdate = angleDegrees
end

local function restoreR6ArmPosition(duration)
    if not currentRightShoulder or not originalRightShoulderC0 then return end
    
    duration = duration or 0.2
    
    local tween = TweenService:Create(
        currentRightShoulder,
        TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {C0 = originalRightShoulderC0}
    )
    
    tween:Play()
    
    -- Clean up references after tween completes
    tween.Completed:Connect(function()
        lastAngleUpdate = 0
    end)
end

local function setupR6ChargeAnimation()
    local character = player.Character
    local isValid, torso, rightShoulder = validateR6Character(character)
    
    if not isValid then
        warn("ToolHandler: Cannot setup R6 charge animation - invalid character structure")
        return false
    end
    
    -- Clean up any existing animation first
    cleanupR6ChargeAnimation()
    
    -- Store references
    currentRightShoulder = rightShoulder
    originalRightShoulderC0 = rightShoulder.C0
    lastAngleUpdate = 0
    
    print("DEBUG: R6 charge animation setup complete")
    return true
end

cleanupR6ChargeAnimation = function()
    -- Stop animation updates
    if chargeAnimationConnection then
        chargeAnimationConnection:Disconnect()
        chargeAnimationConnection = nil
    end
    
    -- Restore arm position
    if currentRightShoulder and originalRightShoulderC0 then
        restoreR6ArmPosition(0.2)
    end
    
    -- Clean up references
    currentRightShoulder = nil
    originalRightShoulderC0 = nil
    lastAngleUpdate = 0
    
    print("DEBUG: R6 charge animation cleanup complete")
end

-- Charge management functions
local function startCharging()
    if debounce or isCharging then return end
    
    -- Only Tools can charge
    local itemKey = string.lower(Tool.Name)
    local itemDef = ItemDefinitions:GetItem(itemKey)
    
    if not itemDef or itemDef.category ~= Categories.Tool then
        return -- Only Tools can charge
    end
    
    isCharging = true
    chargeStartTime = tick()
    
    print("DEBUG: Started charging attack")
    
    -- Setup R6 charge animation
    if setupR6ChargeAnimation() then
        -- Start real-time animation updates
        chargeAnimationConnection = RunService.Heartbeat:Connect(function(deltaTime)
            if not isCharging then return end
            
            -- Safety check: ensure character and joint still exist
            if not validateR6Character(player.Character) then
                warn("DEBUG: Character became invalid during charging - cancelling")
                cancelCharging()
                return
            end
            
            local elapsedTime = tick() - chargeStartTime
            local currentAngle = calculateChargeAngle(elapsedTime)
            
            -- Apply to R6 character
            updateR6ArmPosition(currentAngle)
            
            -- Stop progression at 1.5 seconds (full charge) but keep arm raised
            if elapsedTime >= 1.5 then
                updateR6ArmPosition(R6_ANIMATION.MAX_ANGLE)
                
                -- Show critical bar when fully charged (only once)
                if not isCriticalWindowActive and _G.CriticalAttackUI then
                    _G.CriticalAttackUI:ShowCriticalBar()
                    isCriticalWindowActive = true
                    print("DEBUG: Critical window activated - bar shown")
                end
            end
        end)
        
        print("DEBUG: R6 charge animation started")
    else
        warn("DEBUG: Failed to setup R6 charge animation")
    end
end

local function stopCharging()
    if not isCharging then return end
    
    local holdDuration = tick() - chargeStartTime
    local isCharged = holdDuration >= CHARGE_CONFIG.CHARGE_THRESHOLD
    
    -- Determine attack type based on charge duration and critical timing
    local attackType = "normal"
    if isCharged then
        -- Check if critical window is active and if indicator is in critical zone
        if isCriticalWindowActive and _G.CriticalAttackUI and _G.CriticalAttackUI:IsIndicatorInCriticalZone() then
            attackType = "critical"
            print("DEBUG: CRITICAL ATTACK detected!")
            -- Show critical success effect
            _G.CriticalAttackUI:ShowCriticalSuccessEffect()
        else
            attackType = "charged"
        end
    end
    
    print("DEBUG: Stopped charging after", holdDuration, "seconds. Attack type:", attackType)
    
    -- Hide critical bar if it was shown
    if isCriticalWindowActive and _G.CriticalAttackUI then
        _G.CriticalAttackUI:HideCriticalBar()
        isCriticalWindowActive = false
    end
    
    -- Stop charging state
    isCharging = false
    chargeStartTime = 0
    
    -- Clean up R6 charge animation
    cleanupR6ChargeAnimation()
    
    -- Execute attack based on determined type
    onUse(attackType)
end

cancelCharging = function()
    if not isCharging then return end
    
    print("DEBUG: Cancelled charging attack")
    
    -- Hide critical bar if it was shown
    if isCriticalWindowActive and _G.CriticalAttackUI then
        _G.CriticalAttackUI:HideCriticalBar()
        isCriticalWindowActive = false
    end
    
    -- Stop charging state
    isCharging = false
    chargeStartTime = 0
    
    -- Clean up R6 charge animation
    cleanupR6ChargeAnimation()
end

-- Play swing animation (creates fresh animation each time like the working example)
local function playSwingAnimation()
    -- Only Tools play swing animations
    local itemKey = string.lower(Tool.Name)
    local itemDef = ItemDefinitions:GetItem(itemKey)
    
    if not itemDef or itemDef.category ~= Categories.Tool then
        return -- Only Tools play swing animations
    end
    
    local character = player.Character
    if not character then
        warn("ToolHandler: No character found for animation")
        return
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        warn("ToolHandler: No humanoid found for animation")
        return
    end
    
    local animator = humanoid:FindFirstChild("Animator")
    if not animator then
        warn("ToolHandler: No Animator found in character")
        return
    end
    
    -- Create fresh animation instance each time (like the working example)
    local animation = Instance.new("Animation")
    animation.AnimationId = SWING_ANIMATION_ID
    
    -- Load and play animation immediately
    local animationTrack = animator:LoadAnimation(animation)
    animationTrack.Priority = Enum.AnimationPriority.Action
    animationTrack:Play()
    
    print("ToolHandler: Playing fresh swing animation for", Tool.Name)
end

onUse = function(attackType)
    attackType = attackType or "normal" -- Default to normal attack
    
    if debounce then return end
    debounce = true
    
    local character = player.Character
    if not character then 
        debounce = false
        return 
    end
    
    local human = character:FindFirstChild("Humanoid")
    if not human or human.Health <= 0 then 
        debounce = false
        return 
    end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        debounce = false
        return 
    end

    -- Convert tool name to lowercase and replace spaces with underscores to match ItemDefinitions keys
    local itemKey = string.lower(Tool.Name)
    itemKey = string.gsub(itemKey, " ", "_")  -- Replace spaces with underscores
    local itemDef = ItemDefinitions:GetItem(itemKey)

    if not itemDef then
        warn("ToolHandler: No item definition found for equipped tool:", Tool.Name, "(key:", itemKey .. ")")
        debounce = false
        return
    end

    -- Initialize target as nil
    local target = nil

    -- Only perform shape cast for Tool category items
    if itemDef.category == Categories.Tool then
        
        -- Play swing animation for tools
        playSwingAnimation()
        
        -- Perform shape cast in front of player
        local character = player.Character
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        local head = character and character:FindFirstChild("Head")
        
        if not rootPart then
            print("ToolHandler: No HumanoidRootPart found, skipping shapecast")
            return
        end
        
        -- Get player's forward direction (use camera direction for aiming)
        local cameraDirection = camera.CFrame.LookVector
        local playerForward = Vector3.new(cameraDirection.X, 0, cameraDirection.Z).Unit -- Keep horizontal only
        
        -- Calculate shape cast center position (1 stud in front of player)
        local shapeCastCenter = rootPart.Position + playerForward * SHAPE_CAST_CONFIG.distance
        
        -- Perform the shape cast
        local detectedParts = performShapeCast(character, shapeCastCenter, SHAPE_CAST_CONFIG.radius)
        
        local hasHit = #detectedParts > 0
        
        if hasHit then
            -- Use the best damage target from detected parts
            target = findBestDamageTarget(detectedParts)
            
            -- Create visual shape cast (green for hit)
            createVisualShapeCast(shapeCastCenter, SHAPE_CAST_CONFIG.radius, "Bright green", true)
        else
            -- Create visual shape cast (red for miss)
            createVisualShapeCast(shapeCastCenter, SHAPE_CAST_CONFIG.radius, "Bright red", false)
        end
    end

    -- Centralized dispatch based on category
    print("ToolHandler: Dispatching", itemDef.name, "with category:", itemDef.category)
    
    if itemDef.category == Categories.Tool then
        ToolSystem:Use(itemDef, player, target, attackType)
    elseif itemDef.category == Categories.Armor then
        ArmorSystem:Use(itemDef, player, target)
    elseif itemDef.category == Categories.Functional then
        FunctionalSystem:Use(itemDef, player, target)
    else
        warn("ToolHandler: Unknown category for item:", itemDef.name, itemDef.category)
    end
    
    -- Reset debounce after delay
    wait(DEBOUNCE_TIME)
    debounce = false
end

-- Input handling for charged attacks
local inputConnections = {}

local function setupInputHandling()
    print("DEBUG: setupInputHandling called for", Tool.Name)
    
    -- Clean up existing connections
    for _, connection in pairs(inputConnections) do
        connection:Disconnect()
    end
    inputConnections = {}
    
    -- Setup input handling for Tools and Functional items
    local itemKey = string.lower(Tool.Name)
    itemKey = string.gsub(itemKey, " ", "_")  -- Replace spaces with underscores
    local itemDef = ItemDefinitions:GetItem(itemKey)
    
    print("DEBUG: Item key:", itemKey, "Item def found:", itemDef ~= nil)
    if itemDef then
        print("DEBUG: Item category:", itemDef.category)
    end
    
    if not itemDef then
        print("DEBUG: No item definition found, exiting setupInputHandling")
        return -- Exit early - no item definition found
    end
    
    -- Only Tools use charged attack system, but Functional items need basic click handling
    local allowChargedAttacks = (itemDef.category == Categories.Tool)
    
    if itemDef.category ~= Categories.Tool and itemDef.category ~= Categories.Functional then
        print("DEBUG: Item category not supported for input handling:", itemDef.category)
        return -- Exit early - only Tools and Functional items need input handling
    end
    
    print("DEBUG: Setting up input handling for", itemDef.category, "item with chargedAttacks:", allowChargedAttacks)
    
    -- Mouse input handling
    inputConnections.mouseDown = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        print("DEBUG: Mouse input detected - gameProcessed:", gameProcessed, "isToolEquipped:", isToolEquipped, "inputType:", input.UserInputType)
        
        if gameProcessed then return end
        if not isToolEquipped then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            print("DEBUG: Left mouse button clicked for", Tool.Name, "allowChargedAttacks:", allowChargedAttacks)
            if allowChargedAttacks then
                startCharging() -- Tools use charged attack system
            else
                -- Functional items use immediate action on click
                print("DEBUG: Calling onUse for functional item")
                onUse("normal")
            end
        end
    end)
    
    print("DEBUG: Mouse input connections set up for", Tool.Name)
    
    inputConnections.mouseUp = UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if not isToolEquipped then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            if allowChargedAttacks then
                stopCharging() -- Only Tools use charged system
            end
            -- Functional items don't need mouse up handling
        end
    end)
end

-- Additional edge case handling
local edgeCaseConnections = {}

local function setupEdgeCaseHandling()
            -- Cancel charging when player dies
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                edgeCaseConnections.died = humanoid.Died:Connect(function()
                    cancelCharging()
                end)
            end
            
            -- Handle character removal (respawn, etc.)
            edgeCaseConnections.ancestryChanged = character.AncestryChanged:Connect(function()
                if not character.Parent then
                    cancelCharging()
                end
            end)
        end
        
        -- Cancel charging when UI opens (like inventory, chat, etc.)
        edgeCaseConnections.guiService = game:GetService("GuiService").MenuOpened:Connect(function()
            cancelCharging()
        end)
        
        -- Handle player leaving
        edgeCaseConnections.playerRemoving = game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
            if leavingPlayer == player then
                cleanupR6ChargeAnimation()
            end
        end)
end

local function cleanupEdgeCaseHandling()
    for _, connection in pairs(edgeCaseConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    edgeCaseConnections = {}
end

-- Tool lifecycle events
Tool.Equipped:Connect(function()
    print("DEBUG: Tool.Equipped fired for", Tool.Name)
    isToolEquipped = true
    setupInputHandling()
    setupEdgeCaseHandling()
    print("DEBUG: Tool setup complete for", Tool.Name)
end)

Tool.Unequipped:Connect(function()
    print("DEBUG: Tool.Unequipped fired for", Tool.Name)
    isToolEquipped = false
    cancelCharging()
    
    -- Clean up input connections
    for _, connection in pairs(inputConnections) do
        connection:Disconnect()
    end
    inputConnections = {}
    
    -- Clean up edge case connections
    cleanupEdgeCaseHandling()
    
    -- Ensure R6 animation cleanup
    cleanupR6ChargeAnimation()
    print("DEBUG: Tool cleanup complete for", Tool.Name)
end) ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="49">
        <Properties>
          <string name="Name">TraderData</string>
          <string name="Source"><![CDATA[-- TraderData.luau
-- Contains all trader configurations and item data for UI display

local TraderData = {}

-- Items available for trading (display data only)
TraderData.Items = {
	iron_sword = {
		name = "Iron Sword",
		description = "A sturdy blade forged from iron ore. Perfect for adventurers seeking reliable protection.",
		icon = "rbxassetid://0", -- Placeholder - replace with actual asset ID
		rarity = "common"
	},
	
	steel_armor = {
		name = "Steel Armor",
		description = "Heavy protective gear made from refined steel. Offers excellent defense against physical attacks.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "uncommon"
	},
	
	magic_potion = {
		name = "Magic Potion",
		description = "A mysterious elixir that glows with arcane energy. Its effects are said to be extraordinary.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "rare"
	},
	
	golden_ring = {
		name = "Golden Ring",
		description = "An ornate ring crafted from pure gold. Legends speak of its mystical properties.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "epic"
	},
	
	wooden_shield = {
		name = "Wooden Shield",
		description = "A simple shield carved from oak wood. Basic protection for novice warriors.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "common"
	},
	
	fire_gem = {
		name = "Fire Gem",
		description = "A brilliant red gemstone that radiates warmth. Contains the essence of flame itself.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "rare"
	},
	
	healing_herbs = {
		name = "Healing Herbs",
		description = "Fresh medicinal plants gathered from the forest. Known for their restorative properties.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "common"
	},
	
	dragon_scale = {
		name = "Dragon Scale",
		description = "A magnificent scale from an ancient dragon. Incredibly rare and valuable.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "legendary"
	},
	
	silver_coin = {
		name = "Silver Coin",
		description = "Standard currency used throughout the realm. Accepted by all merchants.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "common"
	},
	
	enchanted_book = {
		name = "Enchanted Book",
		description = "An ancient tome filled with magical knowledge. The pages seem to shimmer with power.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "epic"
	},
	
	crystal_orb = {
		name = "Crystal Orb",
		description = "A perfectly spherical crystal that seems to contain swirling mists. Purpose unknown.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "rare"
	},
	
	iron_ingot = {
		name = "Iron Ingot",
		description = "A refined bar of iron metal. Essential material for crafting weapons and tools.",
		icon = "rbxassetid://0", -- Placeholder
		rarity = "common"
	}
}

-- Trade requirements for each item (display only - no validation)
TraderData.Requirements = {
	iron_sword = {
		{item = "Iron Ingot", quantity = 2},
		{item = "Wood", quantity = 1}
	},
	
	steel_armor = {
		{item = "Iron Ingot", quantity = 5},
		{item = "Silver Coin", quantity = 10}
	},
	
	magic_potion = {
		{item = "Healing Herbs", quantity = 3},
		{item = "Crystal Orb", quantity = 1}
	},
	
	golden_ring = {
		{item = "Silver Coin", quantity = 25},
		{item = "Fire Gem", quantity = 1}
	},
	
	wooden_shield = {
		{item = "Wood", quantity = 3}
	},
	
	fire_gem = {
		{item = "Silver Coin", quantity = 15},
		{item = "Dragon Scale", quantity = 1}
	},
	
	healing_herbs = {
		{item = "Silver Coin", quantity = 2}
	},
	
	dragon_scale = {
		{item = "Silver Coin", quantity = 100},
		{item = "Enchanted Book", quantity = 1}
	},
	
	silver_coin = {
		{item = "Wood", quantity = 1}
	},
	
	enchanted_book = {
		{item = "Silver Coin", quantity = 50},
		{item = "Crystal Orb", quantity = 2}
	},
	
	crystal_orb = {
		{item = "Silver Coin", quantity = 20},
		{item = "Fire Gem", quantity = 1}
	},
	
	iron_ingot = {
		{item = "Silver Coin", quantity = 5}
	}
}

-- UI Configuration for trader interface
TraderData.UIConfig = {
	-- Grid layout
	itemsPerRow = 4,
	gridPadding = 10,
	itemSlotSize = UDim2.new(0, 100, 0, 100),
	
	-- Main window
	shopWindowSize = UDim2.new(0, 600, 0, 500),
	shopWindowPosition = UDim2.new(0.5, -300, 0.5, -250),
	
	-- Item detail popup
	detailWindowSize = UDim2.new(0, 400, 0, 350),
	detailWindowPosition = UDim2.new(0.5, -200, 0.5, -175),
	
	-- Colors
	backgroundColor = Color3.new(0.1, 0.1, 0.1),
	frameColor = Color3.new(0.15, 0.15, 0.15),
	accentColor = Color3.new(0.2, 0.4, 0.8),
	textColor = Color3.new(0.9, 0.9, 0.9),
	
	-- Rarity colors
	rarityColors = {
		common = Color3.new(0.6, 0.6, 0.6),
		uncommon = Color3.new(0.3, 0.8, 0.3),
		rare = Color3.new(0.3, 0.3, 0.9),
		epic = Color3.new(0.8, 0.3, 0.8),
		legendary = Color3.new(1, 0.8, 0.2)
	}
}

-- Get ordered list of items for display
function TraderData:GetItemList()
	print("TraderData: Getting item list")
	local itemList = {}
	for itemId, itemData in pairs(self.Items) do
		print("TraderData: Adding item", itemId, itemData.name)
		table.insert(itemList, {
			id = itemId,
			data = itemData
		})
	end
	
	print("TraderData: Total items before sort:", #itemList)
	
	-- Sort by rarity and name
	local rarityOrder = {common = 1, uncommon = 2, rare = 3, epic = 4, legendary = 5}
	table.sort(itemList, function(a, b)
		local rarityA = rarityOrder[a.data.rarity] or 1
		local rarityB = rarityOrder[b.data.rarity] or 1
		if rarityA == rarityB then
			return a.data.name < b.data.name
		end
		return rarityA < rarityB
	end)
	
	print("TraderData: Total items after sort:", #itemList)
	return itemList
end

-- Get item data by ID
function TraderData:GetItem(itemId)
	return self.Items[itemId]
end

-- Get requirements for an item
function TraderData:GetRequirements(itemId)
	return self.Requirements[itemId] or {}
end

return TraderData ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="50">
        <Properties>
          <string name="Name">Types</string>
          <string name="Source"><![CDATA[-- Type definitions for Boss System
export type BossState = "Falling" | "Moving" | "Attacking" | "Invincible" | "Cooldown" | "Dead"

export type BossData = {
    model: Model,
    humanoid: Humanoid,
    rootPart: BasePart,
    health: number,
    maxHealth: number,
    state: BossState,
    currentTarget: Player?,
    moveCounter: number,
    lastMeleeHit: {[Player]: number}, -- Track melee cooldowns per player
    isInvincible: boolean,
    invincibilityStartTime: number?,
    currentSequence: {string},
    currentSequenceIndex: number,
    lastActionTime: number,
    lastDebugTime: number?,
    wasCloseToTarget: boolean?,
    landingConnection: RBXScriptConnection?,
    landingTime: number?, -- Track when boss landed for grace period
    inGracePeriod: boolean?, -- Track if boss is in grace period
    -- ENHANCED: Additional connections for backup landing detection
    backupLandingConnection: RBXScriptConnection?,
    forceLandingConnection: thread?,
}

export type AbilityConfig = {
    damage: number,
    cooldownAfter: number,
    [string]: any, -- Allow additional properties per ability
}

export type MovementConfig = {
    speed: number,
    pathfindingUpdateRate: number,
    stoppingDistance: number,
    selectNewPlayerAfterAttack: boolean,
    meleeRange: number,
    meleeDamage: number,
    meleeKnockback: number,
    meleeCooldown: number,
}

export type InvincibilityConfig = {
    triggerAfterMoves: number,
    triggerVariation: number,
    duration: number,
    visualEffect: string,
    healAmount: number,
    damageReduction: number,
}

export type PlayerTarget = {
    player: Player,
    character: Model,
    humanoid: Humanoid,
    rootPart: BasePart,
    lastPosition: Vector3,
}

export type AttackResult = {
    success: boolean,
    damage: number?,
    playersHit: {Player}?,
    duration: number?,
}

return {} ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="51">
        <Properties>
          <string name="Name">UIBatcher</string>
          <string name="Source"><![CDATA[-- UI Batcher - Reduces frame drops by batching UI update operations
local RunService = game:GetService("RunService")
local FrameBudgetManager = require(script.Parent.FrameBudgetManager)

local UIBatcher = {}

-- Configuration
local UPDATE_INTERVAL = 1/30 -- 30fps UI updates
local MAX_UPDATES_PER_FRAME = 5

-- Batching state
local pendingUpdates = {}
local updateConnections = {
    heartbeat = nil :: RBXScriptConnection?
}
local lastUpdateTime = 0

-- ENHANCED: Queue a UI update with validation and memory management
function UIBatcher.queueUpdate(uiObject, updateFunction, priority)
    priority = priority or 1 -- Lower number = higher priority
    
    -- ENHANCED: Validate inputs
    if not uiObject then
        warn("UIBATCHER WARNING: Attempted to queue update for nil uiObject")
        return
    end
    
    if type(updateFunction) ~= "function" then
        warn("UIBATCHER WARNING: updateFunction must be a function")
        return
    end
    
    -- ENHANCED: Prevent memory leaks from too many pending updates
    local pendingCount = 0
    for _ in pairs(pendingUpdates) do
        pendingCount += 1
    end
    
    if pendingCount >= 100 then
        warn("UIBATCHER WARNING: Too many pending updates (", pendingCount, ") - forcing flush")
        UIBatcher.flushAll()
    end
    
    local updateId = tostring(uiObject) .. "_" .. tostring(tick())
    
    pendingUpdates[updateId] = {
        uiObject = uiObject,
        updateFunction = updateFunction,
        priority = priority,
        timestamp = tick()
    }
    
    -- Start processing if not already running
    if not updateConnections.heartbeat then
        UIBatcher.startProcessing()
    end
end

-- Queue a hotbar-specific update with batching
function UIBatcher.queueHotbarUpdate(updateFunction, priority)
    priority = priority or 2 -- Medium priority for hotbar
    
    -- Use a fixed key for hotbar to ensure only one update is queued
    local updateId = "hotbar_update"
    
    pendingUpdates[updateId] = {
        uiObject = "hotbar",
        updateFunction = updateFunction,
        priority = priority,
        timestamp = tick()
    }
    
    -- Start processing if not already running
    if not updateConnections.heartbeat then
        UIBatcher.startProcessing()
    end
end

-- Start processing updates
function UIBatcher.startProcessing()
    if updateConnections.heartbeat then
        return -- Already running
    end
    
    updateConnections.heartbeat = RunService.Heartbeat:Connect(function()
        UIBatcher.processUpdates()
    end)
end

-- Stop processing updates
function UIBatcher.stopProcessing()
    if updateConnections.heartbeat then
        updateConnections.heartbeat:Disconnect()
        updateConnections.heartbeat = nil
    end
end

-- Process pending updates with frame budgeting
function UIBatcher.processUpdates()
    local currentTime = tick()
    
    -- Throttle update frequency
    if currentTime - lastUpdateTime < UPDATE_INTERVAL then
        return
    end
    
    lastUpdateTime = currentTime
    
    -- Get updates sorted by priority
    local sortedUpdates = {}
    for updateId, update in pairs(pendingUpdates) do
        table.insert(sortedUpdates, {id = updateId, update = update})
    end
    
    -- Sort by priority (lower number = higher priority)
    table.sort(sortedUpdates, function(a, b)
        return a.update.priority < b.update.priority
    end)
    
    -- Process updates with frame budgeting
    local processed = 0
    for _, updateData in ipairs(sortedUpdates) do
        if processed >= MAX_UPDATES_PER_FRAME then
            break -- Hit frame limit
        end
        
        -- Check frame budget before processing
        FrameBudgetManager.yieldIfNeeded(0.003) -- 3ms estimate for UI update
        
        local updateId = updateData.id
        local update = updateData.update
        
        -- Execute the update
        local success, errorMsg = pcall(function()
            update.updateFunction()
        end)
        
        if success then
            -- Remove completed update
            pendingUpdates[updateId] = nil
            processed += 1
        else
            warn("UIBatcher: Update failed for", updateId, ":", errorMsg)
            -- Remove failed update
            pendingUpdates[updateId] = nil
        end
    end
    
    -- Stop processing if no more updates
    if next(pendingUpdates) == nil then
        UIBatcher.stopProcessing()
    end
end

-- Force process all pending updates immediately
function UIBatcher.flushAll()
    for updateId, update in pairs(pendingUpdates) do
        local success, errorMsg = pcall(function()
            update.updateFunction()
        end)
        
        if not success then
            warn("UIBatcher: Flush failed for", updateId, ":", errorMsg)
        end
        
        pendingUpdates[updateId] = nil
    end
    
    UIBatcher.stopProcessing()
end

-- Get pending update count
function UIBatcher.getPendingCount()
    local count = 0
    for _ in pairs(pendingUpdates) do
        count += 1
    end
    return count
end

-- Clear all pending updates
function UIBatcher.clearAll()
    pendingUpdates = {}
    UIBatcher.stopProcessing()
end

-- Cleanup method
function UIBatcher.cleanup()
    UIBatcher.clearAll()
end

return UIBatcher ]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="52">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="53">
      <Properties>
        <string name="Name">Server</string>
        <token name="RunContext">0</token>
        <string name="Source">-- Server initialization
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")

-- Create remote events first
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local Constants = require(ReplicatedStorage.Shared.Constants)

-- Import systems
local ServerSystems = script:WaitForChild("Systems") -- Corrected path to the Systems folder (child of this script)
local ItemSpawnSystem = require(ServerSystems.ItemSpawnSystem)
local DragServerSystem = require(ServerSystems.DragServerSystem)
local InventoryServerSystem = require(ServerSystems.InventoryServerSystem)
local ArmorServerSystem = require(ServerSystems.ArmorServerSystem)
local DamageSystem = require(ServerSystems.DamageSystem)
local TimeManager = require(ServerSystems.TimeManager)
local PlayerRagdollSystem = require(ServerSystems.PlayerRagdollSystem)
local PlayerEffectsSystem = require(ServerSystems.PlayerEffectsSystem)
local ReviveSystem = require(ServerSystems.ReviveSystem)

-- Import altar systems
local AltarSystem = require(ServerSystems.AltarSystem)
local SacrificeValidator = require(ServerSystems.SacrificeValidator)
local RewardProcessor = require(ServerSystems.RewardProcessor)

-- Import dialogue systems
local NPCManager = require(script.NPCManager)
local DialogueHandler = require(script.DialogueHandler)
local TraderHandler = require(script.TraderHandler)

-- Import boss system
local BossController = require(script.BossSystem.BossController)

print("Server starting...")

-- Initialize server systems
-- ItemSpawnSystem:Initialize()
DragServerSystem:Initialize()
InventoryServerSystem:Initialize()
ArmorServerSystem:Initialize()
DamageSystem:Initialize()
TimeManager.Init()
PlayerRagdollSystem:Initialize()
PlayerEffectsSystem:Initialize()
ReviveSystem:Initialize()

-- Initialize altar systems
AltarSystem:Initialize()

-- Set up ReviveSystem reference in PlayerRagdollSystem
PlayerRagdollSystem:SetReviveSystem(ReviveSystem)

-- Set up prayer handling
local function handlePrayerRequest(player, figure)
    print("Player", player.Name, "requested prayer to figure:", figure:GetFullName())
    
    local success, message = AltarSystem:HandlePrayer(player, figure)
    if success then
        print("Prayer successful for player:", player.Name)
    else
        print("Prayer failed for player:", player.Name, "-", message)
    end
end

-- Connect the prayer request remote
local prayerRequestRemote = ReplicatedStorage:FindFirstChild("PrayerRequest")
if prayerRequestRemote then
    prayerRequestRemote.OnServerEvent:Connect(handlePrayerRequest)
    print("Prayer request remote connected")
end

-- Set up global references for inter-system communication
_G.ItemSpawnSystem = ItemSpawnSystem
_G.InventoryServerSystem = InventoryServerSystem
_G.DamageSystem = DamageSystem
_G.PlayerEffectsSystem = PlayerEffectsSystem

-- Set up boss system RemoteEvent
local BossAbilitiesRemote = Instance.new("RemoteEvent")
BossAbilitiesRemote.Name = "BossAbilities"
BossAbilitiesRemote.Parent = ReplicatedStorage
_G.BossAbilitiesRemote = BossAbilitiesRemote

-- Initialize boss system (but don't auto-spawn boss)
_G.BossController = BossController

-- Set up boss spawn handling
local function handleBossSpawn(player, spawnPosition)
    print("Player", player.Name, "requested boss spawn at position:", spawnPosition)
    
    -- Get player's position for default spawn location
    local playerPosition = Vector3.new(0, 5, 0) -- Default fallback
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        playerPosition = player.Character.HumanoidRootPart.Position + Vector3.new(10, 0, 0) -- Spawn 10 studs away
    end
    
    local finalSpawnPosition = spawnPosition or playerPosition
    
    -- Spawn the boss
    BossController.spawnBoss(finalSpawnPosition)
end

-- Connect the boss spawn remote
local spawnBossRemote = ReplicatedStorage:FindFirstChild("SpawnBoss")
if spawnBossRemote then
    spawnBossRemote.OnServerEvent:Connect(handleBossSpawn)
    print("Boss spawn remote connected")
end

-- Set up respawn RemoteEvent
local RequestRespawn = ReplicatedStorage:FindFirstChild("RequestRespawn")
if not RequestRespawn then
    RequestRespawn = Instance.new("RemoteEvent")
    RequestRespawn.Name = "RequestRespawn"
    RequestRespawn.Parent = ReplicatedStorage
end
RequestRespawn.OnServerEvent:Connect(function(player)
    player:LoadCharacter()
end)



-- Initialize dialogue systems
NPCManager:Initialize()
DialogueHandler:SetNPCManager(NPCManager)
DialogueHandler:Initialize()
TraderHandler:Initialize()

-- Initialize enemy systems (from stayalive-1 integration)
local EnemySystemInitializer = require(script.EnemySystemInitializer)
local SpawnerSetup = require(script.SpawnerSetup)

-- Initialize projectile system
local ProjectileManager = require(script.ProjectileManager)
ProjectileManager.initialize()

-- Initialize spawners BEFORE starting enemy systems
SpawnerSetup.initializeAllSpawners()

-- Initialize item spawners (pool-based)
local ItemPoolSpawnSystem = require(ServerSystems.ItemSpawnSystem)
ItemPoolSpawnSystem.spawnAllItems()

_G.EnemySystemInitializer = EnemySystemInitializer
_G.SpawnerSetup = SpawnerSetup
print("Enemy systems integrated:", EnemySystemInitializer.initialized)

print("Server systems initialized!")</string>
      </Properties>
      <Item class="Folder" referent="54">
        <Properties>
          <string name="Name">BossSystem</string>
        </Properties>
        <Item class="Folder" referent="55">
          <Properties>
            <string name="Name">BossAbilities</string>
          </Properties>
          <Item class="ModuleScript" referent="56">
            <Properties>
              <string name="Name">OrbitalStrike</string>
              <string name="Source"><![CDATA[-- Orbital Strike Ability - Creates warning circles then strikes from above
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)
local Types = require(ReplicatedStorage.Shared.Types)
local FrameBudgetManager = require(ReplicatedStorage.Shared.FrameBudgetManager)
local RemoteEventBatcher = require(ReplicatedStorage.Shared.RemoteEventBatcher)

local OrbitalStrike = {}

-- Private variables
local activeOrbitalStrikes: {[Types.BossData]: {strikePositions: {Vector3}, startTime: number?}} = {}

-- Get the RemoteEvent for client communication
local function getBossAbilitiesRemote(): RemoteEvent
    return _G.BossAbilitiesRemote or ReplicatedStorage:FindFirstChild("BossAbilities")
end

-- Private functions
local function sendOrbitalStrikeUpdate(phase: string, position: Vector3?, index: number?, bossPosition: Vector3)
    local remote = getBossAbilitiesRemote()
    if not remote then
        warn("BossAbilities RemoteEvent not found!")
        return
    end
    
    local data = {
        abilityType = "orbitalStrike",
        phase = phase,
        position = position,
        index = index,
        bossPosition = bossPosition,
    }
    
    -- PERFORMANCE OPTIMIZATION: Batch circle additions but send strikes immediately
    if phase == "addCircle" then
        RemoteEventBatcher.queueEvent(remote, data)
    else
        -- Immediate for strikes and cleanup
        remote:FireAllClients(data)
    end
end

local function generateStrikePositions(bossPosition: Vector3, count: number): {Vector3}
    local config = BossConfig.abilities.orbitalStrike
    local positions = {}
    
    for i = 1, count do
        -- Generate random angle and distance
        local angle = math.random() * math.pi * 2
        local distance = math.random(config.minDistance, config.maxDistance)
        
        -- Calculate position around boss
        local x = bossPosition.X + math.cos(angle) * distance
        local z = bossPosition.Z + math.sin(angle) * distance
        
        -- Raycast to find ground level
        local raycast = workspace:Raycast(Vector3.new(x, bossPosition.Y + 50, z), Vector3.new(0, -100, 0))
        local y = bossPosition.Y
        if raycast then
            y = raycast.Position.Y
        end
        
        table.insert(positions, Vector3.new(x, y, z))
    end
    
    return positions
end

local function dealSingleStrikeDamage(strikePos: Vector3, radius: number, damage: number, strikeIndex: number)
    print("Orbital strike", strikeIndex, "activating at position:", strikePos, "with radius:", radius)
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local playerPosition = player.Character.HumanoidRootPart.Position
            local distance = (strikePos - playerPosition).Magnitude
            
            print(player.Name, "distance from strike", strikeIndex, ":", math.floor(distance), "/ radius:", radius)
            
            if distance <= radius then
                local humanoid = player.Character:FindFirstChild("Humanoid") :: Humanoid?
                if humanoid then
                    humanoid.Health = math.max(0, humanoid.Health - damage)
                    print(player.Name, "took", damage, "damage from orbital strike", strikeIndex, "(distance:", math.floor(distance), ")")
                    return -- Player hit, no need to check other players for this strike
                end
            else
                print(player.Name, "outside strike", strikeIndex, "radius - no damage")
            end
        end
    end
end

-- Public functions
function OrbitalStrike.execute(boss: Types.BossData, targetPlayer: Player?): Types.AttackResult
    -- Prevent multiple simultaneous executions
    if activeOrbitalStrikes[boss] then
        warn("OrbitalStrike already active for this boss!")
        return {success = false}
    end
    
    print("Boss executing meteor shower orbital strike")
    
    local config = BossConfig.abilities.orbitalStrike
    
    -- Generate strike positions around the boss
    local strikePositions = generateStrikePositions(boss.rootPart.Position, config.circleCount)
    
    -- Store strike data
    activeOrbitalStrikes[boss] = {
        strikePositions = strikePositions,
        startTime = tick()
    }
    
    -- NEW APPROACH: Overlapping circle-then-strike pattern
    print("Starting overlapping meteor shower - circles can strike concurrently")
    
    -- Track active strikes for cleanup
    local activeStrikes = {}
    
    -- Spawn circles at regular intervals (independent of strike timing)
    task.spawn(function()
        for i = 1, config.circleCount do
            -- Step 1: Add warning circle
            print("Adding orbital strike circle", i, "of", config.circleCount)
            sendOrbitalStrikeUpdate("addCircle", strikePositions[i], i, boss.rootPart.Position)
            
            -- Step 2: Spawn independent strike task for this circle
            local strikeTask = task.spawn(function()
                -- Wait for strike delay
                task.wait(config.strikeDelay)
                
                -- Fire the strike for this circle
                print("Firing orbital strike", i, "at position:", strikePositions[i])
                sendOrbitalStrikeUpdate("fireSingleStrike", strikePositions[i], i, boss.rootPart.Position)
                
                -- Deal damage for this specific strike
                dealSingleStrikeDamage(strikePositions[i], config.damageRadius, config.damage, i)
                
                -- Mark this strike as completed
                activeStrikes[i] = nil
            end)
            
            -- Track this strike
            activeStrikes[i] = strikeTask
            
            -- Step 3: Wait before next circle (allows overlapping)
            if i < config.circleCount then
                task.wait(config.circleInterval)
            end
        end
        
        print("All circles spawned, waiting for strikes to complete...")
        
        -- Wait for all strikes to complete
        while next(activeStrikes) do
            task.wait(0.1) -- Check every 100ms
        end
        
        -- Wait for final beam visuals to finish
        task.wait(config.beamDuration)
        
        -- Final cleanup
        sendOrbitalStrikeUpdate("cleanup", nil, nil, boss.rootPart.Position)
        activeOrbitalStrikes[boss] = nil
        
        print("Overlapping meteor shower orbital strike completed")
    end)
    
    -- Calculate new total duration for overlapping strikes:
    -- Time to spawn all circles + strike delay for last circle + beam duration
    local totalDuration = (config.circleInterval * (config.circleCount - 1)) + 
                         config.strikeDelay + 
                         config.beamDuration
    
    return {
        success = true,
        damage = config.damage,
        playersHit = {}, -- Could track which players were hit
        duration = totalDuration
    }
end

function OrbitalStrike.interrupt(boss: Types.BossData)
    local strikeData = activeOrbitalStrikes[boss]
    if strikeData then
        -- Tell clients to cleanup
        sendOrbitalStrikeUpdate("cleanup", nil, nil, boss.rootPart.Position)
        activeOrbitalStrikes[boss] = nil
    end
end

function OrbitalStrike.isActive(boss: Types.BossData): boolean
    return activeOrbitalStrikes[boss] ~= nil
end

function OrbitalStrike.cleanup(boss: Types.BossData)
    OrbitalStrike.interrupt(boss)
end

return OrbitalStrike ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="57">
            <Properties>
              <string name="Name">RippleSquares</string>
              <string name="Source"><![CDATA[-- Ripple Squares Ability - Creates expanding square outlines from the boss
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)
local Types = require(ReplicatedStorage.Shared.Types)
local FrameBudgetManager = require(ReplicatedStorage.Shared.FrameBudgetManager)
local RemoteEventBatcher = require(ReplicatedStorage.Shared.RemoteEventBatcher)

local RippleSquares = {}

-- Private variables
local activeRippleSquares: {[Types.BossData]: {squares: {{parts: {BasePart}, startTime: number}}, startTime: number?}} = {}

-- Get the RemoteEvent for client communication
local function getBossAbilitiesRemote(): RemoteEvent
    return _G.BossAbilitiesRemote or ReplicatedStorage:FindFirstChild("BossAbilities")
end

-- Send update to clients for visual effects
local function sendRippleUpdate(phase: string, bossPosition: Vector3, squareIndex: number?)
    local remote = getBossAbilitiesRemote()
    if not remote then
        warn("BossAbilities RemoteEvent not found!")
        return
    end
    
    local data = {
        abilityType = "rippleSquares",
        phase = phase,
        bossPosition = bossPosition,
        squareIndex = squareIndex,
    }
    
    -- PERFORMANCE OPTIMIZATION: Batch square spawns but send start/cleanup immediately
    if phase == "spawnSquare" then
        RemoteEventBatcher.queueEvent(remote, data)
    else
        -- Immediate for start/cleanup
        remote:FireAllClients(data)
    end
end

-- Find ground level at boss position
local function findGroundLevel(position: Vector3): Vector3
    -- Raycast downward to find ground
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    
    -- Filter out boss AND all player characters
    local filterList = {}
    if workspace:FindFirstChild("Boss") then
        table.insert(filterList, workspace:FindFirstChild("Boss"))
    end
    
    -- Add all player characters to filter
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            table.insert(filterList, player.Character)
        end
    end
    
    raycastParams.FilterDescendantsInstances = filterList
    
    local raycast = workspace:Raycast(Vector3.new(position.X, position.Y + 20, position.Z), Vector3.new(0, -100, 0), raycastParams)
    if raycast then
        -- Debug: Print what we hit
        print("Raycast hit:", raycast.Instance.Name, "at Y:", raycast.Position.Y, "Parent:", raycast.Instance.Parent.Name)
        -- Position slightly above ground to ensure visibility
        return Vector3.new(position.X, raycast.Position.Y + 0.1, position.Z)
    else
        -- Debug: Print when no hit
        print("Raycast missed - using fallback position")
        -- Fallback to boss Y position minus some height to get to ground level
        return Vector3.new(position.X, position.Y - 5, position.Z)
    end
end

-- Create a hollow square outline made of 4 parts
local function createSquareOutlineHitbox(bossPosition: Vector3, squareIndex: number): {BasePart}
    local config = BossConfig.abilities.rippleSquares
    local parts = {}
    
    -- Find ground level for the squares
    local groundPosition = findGroundLevel(bossPosition)
    
    -- Create 4 parts that form a hollow square outline
    local partNames = {"Top", "Bottom", "Left", "Right"}
    
    for i, partName in ipairs(partNames) do
        local part = Instance.new("Part")
        part.Name = "RippleSquareOutline_" .. squareIndex .. "_" .. partName
        part.Size = config.initialSize -- Will be tweened to expand
        part.Position = groundPosition
        part.Transparency = 1 -- Invisible hitbox
        part.CanCollide = false
        part.Anchored = true
        part.Parent = workspace
        
        -- Position the parts to form a hollow square on the ground
        if partName == "Top" then
            part.Size = Vector3.new(config.initialSize.X, config.outlineThickness, config.outlineThickness)
            part.Position = groundPosition + Vector3.new(0, config.outlineThickness/2, config.initialSize.Z/2)
        elseif partName == "Bottom" then
            part.Size = Vector3.new(config.initialSize.X, config.outlineThickness, config.outlineThickness)
            part.Position = groundPosition + Vector3.new(0, config.outlineThickness/2, -config.initialSize.Z/2)
        elseif partName == "Left" then
            part.Size = Vector3.new(config.outlineThickness, config.outlineThickness, config.initialSize.Z)
            part.Position = groundPosition + Vector3.new(-config.initialSize.X/2, config.outlineThickness/2, 0)
        elseif partName == "Right" then
            part.Size = Vector3.new(config.outlineThickness, config.outlineThickness, config.initialSize.Z)
            part.Position = groundPosition + Vector3.new(config.initialSize.X/2, config.outlineThickness/2, 0)
        end
        
        -- Add damage detection
        local connection
        connection = part.Touched:Connect(function(hit)
            local humanoid = hit.Parent:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local player = Players:GetPlayerFromCharacter(hit.Parent)
                if player then
                    -- Deal damage
                    humanoid.Health = math.max(0, humanoid.Health - config.damage)
                    print(player.Name, "took", config.damage, "damage from expanding square", squareIndex)
                    
                    -- Disconnect to prevent multiple hits from same square
                    connection:Disconnect()
                end
            end
        end)
        
        table.insert(parts, part)
    end
    
    return parts
end

-- Animate the square outline expansion
local function animateSquareExpansion(parts: {BasePart}, bossPosition: Vector3, squareIndex: number)
    local config = BossConfig.abilities.rippleSquares
    
    -- Find ground level for expansion targets
    local groundPosition = findGroundLevel(bossPosition)
    
    -- Create expansion tween for each part
    local tweenInfo = TweenInfo.new(
        config.expansionDuration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out
    )
    
    for i, part in ipairs(parts) do
        local partName = part.Name:match("_(%w+)$") -- Extract part name (Top, Bottom, etc.)
        local targetSize
        local targetPosition
        
        if partName == "Top" then
            targetSize = Vector3.new(config.maxSize.X, config.outlineThickness, config.outlineThickness)
            targetPosition = groundPosition + Vector3.new(0, config.outlineThickness/2, config.maxSize.Z/2)
        elseif partName == "Bottom" then
            targetSize = Vector3.new(config.maxSize.X, config.outlineThickness, config.outlineThickness)
            targetPosition = groundPosition + Vector3.new(0, config.outlineThickness/2, -config.maxSize.Z/2)
        elseif partName == "Left" then
            targetSize = Vector3.new(config.outlineThickness, config.outlineThickness, config.maxSize.Z)
            targetPosition = groundPosition + Vector3.new(-config.maxSize.X/2, config.outlineThickness/2, 0)
        elseif partName == "Right" then
            targetSize = Vector3.new(config.outlineThickness, config.outlineThickness, config.maxSize.Z)
            targetPosition = groundPosition + Vector3.new(config.maxSize.X/2, config.outlineThickness/2, 0)
        end
        
        -- Create and play the expansion tween
        local sizeTween = TweenService:Create(part, tweenInfo, {Size = targetSize})
        local positionTween = TweenService:Create(part, tweenInfo, {Position = targetPosition})
        
        sizeTween:Play()
        positionTween:Play()
        
        -- Cleanup when expansion completes
        if i == 1 then -- Only need to connect once per square
            sizeTween.Completed:Connect(function()
                -- Remove all parts of this square
                for _, squarePart in ipairs(parts) do
                    if squarePart and squarePart.Parent then
                        squarePart:Destroy()
                    end
                end
            end)
        end
    end
end

-- Public functions
function RippleSquares.execute(boss: Types.BossData, targetPlayer: Player?): Types.AttackResult
    -- Prevent multiple simultaneous executions
    if activeRippleSquares[boss] then
        warn("RippleSquares already active for this boss!")
        return {success = false}
    end
    
    print("Boss executing expanding square ripples ability")
    
    local config = BossConfig.abilities.rippleSquares
    
    -- Initialize tracking data
    activeRippleSquares[boss] = {
        squares = {},
        startTime = tick()
    }
    
    -- Tell clients to start the ability
    sendRippleUpdate("start", boss.rootPart.Position)
    
    -- Spawn expanding squares with timing - FRAME BUDGETED
    task.spawn(function()
        local squareOperations = {}
        for squareIndex = 1, config.maxActiveSquares do
            table.insert(squareOperations, function()
                print("Spawning expanding square", squareIndex)
                
                -- Yield to prevent frame drops during part creation
                FrameBudgetManager.yieldIfNeeded(0.005) -- 5ms estimate for part creation
                
                -- Create server hitbox outline
                local parts = createSquareOutlineHitbox(boss.rootPart.Position, squareIndex)
                
                -- Store square data
                table.insert(activeRippleSquares[boss].squares, {
                    parts = parts,
                    startTime = tick()
                })
                
                -- Tell clients to spawn visual square
                sendRippleUpdate("spawnSquare", boss.rootPart.Position, squareIndex)
                
                -- Start expansion animation
                animateSquareExpansion(parts, boss.rootPart.Position, squareIndex)
                
                -- Wait before next square (except for the last one)
                if squareIndex < config.maxActiveSquares then
                    task.wait(config.rippleInterval)
                end
            end)
        end
        
        -- Execute with frame budgeting (max 2 squares per frame to prevent lag)
        FrameBudgetManager.executeWithLimit(squareOperations, 2)
        
        -- Wait for all squares to finish expanding and disappear
        task.wait(config.expansionDuration + 0.5)
        
        -- Tell clients to cleanup
        sendRippleUpdate("cleanup", boss.rootPart.Position)
        
        -- Clear tracking data
        activeRippleSquares[boss] = nil
        
        print("Expanding square ripples ability completed")
    end)
    
    -- Calculate total duration
    local totalDuration = (config.rippleInterval * (config.maxActiveSquares - 1)) + config.expansionDuration + 0.5
    
    return {
        success = true,
        damage = config.damage,
        playersHit = {}, -- Could track which players were hit
        duration = totalDuration
    }
end

function RippleSquares.interrupt(boss: Types.BossData)
    local rippleData = activeRippleSquares[boss]
    if rippleData then
        -- Cleanup all hitbox parts
        for _, square in ipairs(rippleData.squares) do
            for _, part in ipairs(square.parts) do
                if part and part.Parent then
                    part:Destroy()
                end
            end
        end
        
        -- Tell clients to cleanup
        sendRippleUpdate("cleanup", boss.rootPart.Position)
        activeRippleSquares[boss] = nil
    end
end

function RippleSquares.isActive(boss: Types.BossData): boolean
    return activeRippleSquares[boss] ~= nil
end

function RippleSquares.cleanup(boss: Types.BossData)
    RippleSquares.interrupt(boss)
end

return RippleSquares ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="58">
            <Properties>
              <string name="Name">TrackingShot</string>
              <string name="Source"><![CDATA[-- Tracking Shot Ability - Missile-based lock-on system
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)
local Types = require(ReplicatedStorage.Shared.Types)
local MissilePhysics = require(script.Parent.Parent.MissilePhysics)
local RemoteEventBatcher = require(ReplicatedStorage.Shared.RemoteEventBatcher)

local TrackingShot = {}

-- Private variables
local activeTrackingShots: {[Types.BossData]: {target: Player?, startTime: number?, lockOnAchieved: boolean?}} = {}

-- Get the RemoteEvent for client communication
local function getBossAbilitiesRemote(): RemoteEvent
    return _G.BossAbilitiesRemote or ReplicatedStorage:FindFirstChild("BossAbilities")
end

-- Private functions
local function sendLaserUpdate(phase: string, targetPlayer: Player?, bossPosition: Vector3, extraData: {[string]: any}?)
    local remote = getBossAbilitiesRemote()
    if not remote then
        warn("BossAbilities RemoteEvent not found!")
        return
    end
    
    local data = {
        abilityType = "trackingShot",
        phase = phase,
        targetPlayerId = targetPlayer and targetPlayer.UserId or nil,
        bossPosition = bossPosition,
    }
    
    -- Add any extra data
    if extraData then
        for key, value in pairs(extraData) do
            data[key] = value
        end
    end
    
    -- PERFORMANCE OPTIMIZATION: Use batching for non-critical updates
    if phase == "tracking" or phase == "lockOnAttempt" then
        RemoteEventBatcher.queueEvent(remote, data)
    else
        -- Critical events (lock success/fail, missile launch) send immediately
        remote:FireAllClients(data)
    end
end

local function checkLineOfSight(bossPosition: Vector3, targetPosition: Vector3, targetPlayer: Player): boolean
    local direction = targetPosition - bossPosition
    local distance = direction.Magnitude
    
    if distance < 0.1 then
        return true
    end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Boss")}
    
    -- Add all OTHER player characters to filter (we want to ignore other players but detect the target)
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player ~= targetPlayer then
            table.insert(raycastParams.FilterDescendantsInstances, player.Character)
        end
    end

    local raycastResult = workspace:Raycast(bossPosition, direction, raycastParams)
    
    -- If we hit the target player or nothing, we have line of sight
    if not raycastResult then
        return true -- Clear line of sight
    end
    
    -- Check if we hit the target player
    if raycastResult.Instance and targetPlayer.Character then
        local hitPart = raycastResult.Instance
        return hitPart:IsDescendantOf(targetPlayer.Character)
    end
    
    -- Hit something else (environment) - no line of sight
    return false
end

local function performLockOnSequence(boss: Types.BossData, targetPlayer: Player): boolean
    local config = BossConfig.abilities.trackingShot
    local lockOnTime = 0
    local lockOnRequired = config.lockOnDuration
    
    print("Starting lock-on sequence for", targetPlayer.Name)
    
    -- Phase 1: Start blinking and check for lock-on
    sendLaserUpdate("lockOnAttempt", targetPlayer, boss.rootPart.Position, {
        blinkCount = config.blinkCount
    })
    
    -- Monitor line of sight during blinking
    for i = 1, config.blinkCount do
        local blinkStartTime = tick()
        
        -- Each blink lasts blinkSpeed seconds
        while tick() - blinkStartTime < config.blinkSpeed do
            if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local rootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") :: BasePart
                local targetPosition = rootPart.Position
                
                local hasLineOfSight = true -- Default to true
                if config.requiresLineOfSight then
                    hasLineOfSight = checkLineOfSight(boss.rootPart.Position, targetPosition, targetPlayer)
                end
                
                if hasLineOfSight then
                    lockOnTime = lockOnTime + (1/30) -- Assuming 30 FPS check rate
                    
                    -- Check if we've achieved lock-on
                    if lockOnTime >= lockOnRequired then
                        print("Lock-on achieved for", targetPlayer.Name, "after", lockOnTime, "seconds")
                        sendLaserUpdate("lockOnSuccess", targetPlayer, boss.rootPart.Position)
                        return true
                    end
                else
                    -- Debug: print why line of sight failed
                    print("No line of sight to", targetPlayer.Name, "- target may be behind cover")
                end
            end
            
            task.wait(1/30) -- 30 FPS update rate
        end
        
        print("Blink", i, "completed. Lock-on time:", lockOnTime, "/", lockOnRequired)
    end
    
    -- Lock-on failed
    print("Lock-on failed for", targetPlayer.Name, "- insufficient line of sight time")
    sendLaserUpdate("lockOnFailed", targetPlayer, boss.rootPart.Position)
    return false
end



-- Public functions
function TrackingShot.execute(boss: Types.BossData, targetPlayer: Player?): Types.AttackResult
    -- Prevent multiple simultaneous executions
    if activeTrackingShots[boss] then
        warn("TrackingShot already active for this boss!")
        return {success = false}
    end
    
    print("Boss executing missile tracking shot")
    
    local config = BossConfig.abilities.trackingShot
    
    -- Select target player if none provided
    if not targetPlayer then
        local activePlayers = {}
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(activePlayers, player)
            end
        end
        
        if #activePlayers > 0 then
            targetPlayer = activePlayers[math.random(1, #activePlayers)]
        else
            return {success = false}
        end
    end
    
    if not targetPlayer or not targetPlayer.Character then
        return {success = false}
    end
    
    local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then
        return {success = false}
    end
    
    -- Store tracking data
    activeTrackingShots[boss] = {
        target = targetPlayer,
        startTime = tick(),
        lockOnAchieved = false
    }
    
    -- Phase 1: Start tracking phase - tell clients to render laser
    sendLaserUpdate("tracking", targetPlayer, boss.rootPart.Position)
    
    -- Track for specified duration
    task.wait(config.trackingDuration)
    
    -- Phase 2: Attempt lock-on sequence
    local lockOnSuccessful = performLockOnSequence(boss, targetPlayer)
    
    if lockOnSuccessful then
        -- Lock-on achieved - spawn missile
        activeTrackingShots[boss].lockOnAchieved = true
        
        -- Brief pause to show lock-on success
        task.wait(0.3)
        
        -- Phase 3: Launch missile
        sendLaserUpdate("missileLaunch", targetPlayer, boss.rootPart.Position)
        local missileId = MissilePhysics.spawnMissile(boss.rootPart.Position, targetPlayer)
        
        if missileId then
            print("Missile", missileId, "launched at", targetPlayer.Name)
            
            -- Wait for missile to complete (it will handle its own physics and cleanup)
            -- The missile system will send explosion events when done
            
            -- Cleanup laser visuals
            sendLaserUpdate("inactive", nil, boss.rootPart.Position)
            activeTrackingShots[boss] = nil
    
    return {
        success = true,
                damage = config.damage,
                playersHit = {targetPlayer},
                duration = config.trackingDuration + (config.blinkCount * config.blinkSpeed) + 0.3 -- lock-on pause
            }
        else
            -- Failed to spawn missile
            sendLaserUpdate("inactive", nil, boss.rootPart.Position)
            activeTrackingShots[boss] = nil
            return {success = false}
        end
    else
        -- Lock-on failed - no missile
        print("Lock-on failed - no missile launched")
        
        -- Cleanup
        sendLaserUpdate("inactive", nil, boss.rootPart.Position)
        activeTrackingShots[boss] = nil
        
        return {
            success = true, -- Still counts as ability used
            damage = 0,
            playersHit = {},
            duration = config.trackingDuration + (config.blinkCount * config.blinkSpeed)
        }
    end
end

function TrackingShot.interrupt(boss: Types.BossData)
    local trackingData = activeTrackingShots[boss]
    if trackingData then
        -- Tell clients to cleanup laser visuals
        sendLaserUpdate("inactive", nil, boss.rootPart.Position)
        activeTrackingShots[boss] = nil
    end
    
    -- Also cleanup any missiles (they handle their own cleanup)
    MissilePhysics.destroyAllMissiles()
end

function TrackingShot.isActive(boss: Types.BossData): boolean
    return activeTrackingShots[boss] ~= nil
end

function TrackingShot.cleanup(boss: Types.BossData)
    TrackingShot.interrupt(boss)
end

return TrackingShot ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="59">
          <Properties>
            <string name="Name">BossController</string>
            <string name="Source"><![CDATA[-- Main Boss Controller - Orchestrates all boss behavior
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)
local Types = require(ReplicatedStorage.Shared.Types)

-- Import other boss systems
local BossMovement = require(script.Parent.BossMovement)
local BossInvincibility = require(script.Parent.BossInvincibility)
local TemplateManager = require(script.Parent.TemplateManager)

-- Import boss abilities
local TrackingShot = require(script.Parent.BossAbilities.TrackingShot)
local OrbitalStrike = require(script.Parent.BossAbilities.OrbitalStrike)
local RippleSquares = require(script.Parent.BossAbilities.RippleSquares)

local BossController = {}

-- Active boss data
local activeBoss: Types.BossData? = nil
local bossUpdateConnection: RBXScriptConnection? = nil

-- PERFORMANCE OPTIMIZATION: Async boss model creation to prevent lag
local function createBossModelAsync(callback: (Model?) -> ())
    -- Load boss from template asynchronously
    TemplateManager.loadBossTemplateAsync(function(boss)
        if boss then
            boss.Name = "Boss"
            boss.Parent = workspace
            print("Boss created from template:", boss.Name)
            callback(boss)
        else
            warn("Failed to create boss model")
            callback(nil)
        end
    end)
end

local function initializeBossData(model: Model): Types.BossData
    local humanoid = model:FindFirstChild("Humanoid") :: Humanoid
    local rootPart = model:FindFirstChild("HumanoidRootPart") :: BasePart
    
    return {
        model = model,
        humanoid = humanoid,
        rootPart = rootPart,
        health = BossConfig.boss.health,
        maxHealth = BossConfig.boss.maxHealth,
        state = "Falling",
        currentTarget = nil,
        moveCounter = 0,
        lastMeleeHit = {},
        isInvincible = false,
        invincibilityStartTime = nil,
        currentSequence = BossConfig.sequences.default,
        currentSequenceIndex = math.random(1, #BossConfig.sequences.default),
        lastActionTime = tick() - BossConfig.timing.vulnerabilityDuration, -- Allow immediate first attack
        lastDebugTime = 0,
        wasCloseToTarget = false,
        landingConnection = nil,
        landingTime = nil, -- Track when boss landed for grace period
        inGracePeriod = false, -- Track if boss is in grace period
    }
end

local function getActivePlayers(): {Player}
    local activePlayers = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            table.insert(activePlayers, player)
        end
    end
    return activePlayers
end

-- ENHANCED: Boss state validation and recovery
local function validateBossState(boss: Types.BossData): boolean
    -- Validate boss has required components
    if not boss.model or not boss.model.Parent then
        warn("BOSS ERROR: Boss model is destroyed or not parented")
        return false
    end
    
    if not boss.humanoid or not boss.humanoid.Parent then
        warn("BOSS ERROR: Boss humanoid is destroyed or not parented")
        return false
    end
    
    if not boss.rootPart or not boss.rootPart.Parent then
        warn("BOSS ERROR: Boss root part is destroyed or not parented")
        return false
    end
    
    return true
end

local function recoverStuckBoss(boss: Types.BossData)
    local currentTime = tick()
    
    -- Check if boss has been falling too long
    if boss.state == "Falling" then
        local fallDuration = currentTime - (boss.landingTime or 0)
        if fallDuration > 20 then -- If falling for more than 20 seconds, something is wrong
            warn("BOSS RECOVERY: Boss stuck in Falling state for", fallDuration, "seconds - forcing recovery")
            
            -- Force transition to Moving state
            boss.state = "Moving"
            boss.landingTime = currentTime
            boss.inGracePeriod = true
            
            -- Start movement
            BossMovement.moveToRandomPlayer(boss)
            
            -- Trigger screen shake manually
            local remoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
            pcall(function()
                remoteEvents.BossLanded:FireAllClients()
            end)
            
            print("BOSS RECOVERY: Boss recovered from stuck Falling state")
        end
    end
    
    -- Check if boss has no target for too long
    if boss.state == "Moving" and not boss.currentTarget then
        local noTargetDuration = currentTime - (boss.lastDebugTime or currentTime)
        if noTargetDuration > 10 then -- No target for 10+ seconds
            print("BOSS RECOVERY: Boss has no target - finding new one")
            BossMovement.moveToRandomPlayer(boss)
            boss.lastDebugTime = currentTime
        end
    end
end

-- ENHANCED: Ability execution with comprehensive error handling and recovery
local function executeNextAbility(boss: Types.BossData)
    local abilityName = boss.currentSequence[boss.currentSequenceIndex]
    print("BOSS DEBUG: === EXECUTING ABILITY:", abilityName, "===")
    print("BOSS DEBUG: Current sequence index:", boss.currentSequenceIndex, "/", #boss.currentSequence)
    print("BOSS DEBUG: Move counter:", boss.moveCounter)
    print("BOSS DEBUG: Target:", boss.currentTarget and boss.currentTarget.Name or "none")
    
    -- ENHANCED: Validate boss state before ability execution
    if not validateBossState(boss) then
        warn("BOSS ERROR: Cannot execute ability - boss state invalid")
        return
    end
    
    if boss.state ~= "Moving" then
        warn("BOSS WARNING: Executing ability from non-Moving state:", boss.state)
    end
    
    -- Stop movement during attack and set state immediately
    local success, stopError = pcall(function()
    BossMovement.stopMovement(boss)
    end)
    
    if not success then
        warn("BOSS ERROR: Failed to stop movement:", stopError)
    end
    
    boss.state = "Attacking"
    boss.lastActionTime = tick() -- Set this immediately to prevent multiple triggers
    print("BOSS DEBUG: Boss state set to Attacking")
    
    -- Execute the specific ability
    task.spawn(function()
        local abilityStartTime = tick()
        print("BOSS DEBUG: Ability execution started at", abilityStartTime)
        
        -- Boss becomes invincible during attacks (simple flag)
        boss.isInvincible = true
        print("BOSS DEBUG: Boss invincibility enabled")
        
        local result: Types.AttackResult = {success = false}
        
        -- ENHANCED: Better error handling for ability execution
        local abilitySuccess, abilityError = pcall(function()
        if abilityName == "trackingShot" then
            result = TrackingShot.execute(boss, boss.currentTarget)
        elseif abilityName == "orbitalStrike" then
            result = OrbitalStrike.execute(boss, boss.currentTarget)
        elseif abilityName == "rippleSquares" then
            result = RippleSquares.execute(boss, boss.currentTarget)
        else
                warn("BOSS ERROR: Unknown ability:", abilityName)
                result = {success = false}
            end
        end)
        
        if not abilitySuccess then
            warn("BOSS ERROR: Ability execution crashed:", abilityError)
            result = {success = false}
        end
        
        local abilityDuration = tick() - abilityStartTime
        
        if result.success then
            print("BOSS DEBUG: Ability", abilityName, "completed successfully in", math.floor(abilityDuration * 1000), "ms")
            if result.damage then
                print("BOSS DEBUG: Ability dealt", result.damage, "damage")
            end
            if result.playersHit then
                print("BOSS DEBUG: Ability hit", #result.playersHit, "players")
            end
        else
            warn("BOSS ERROR: Ability", abilityName, "failed after", math.floor(abilityDuration * 1000), "ms")
        end
        
        -- Boss becomes vulnerable after attacks (simple flag)
        boss.isInvincible = false
        print("BOSS DEBUG: Boss invincibility disabled")
        
        -- Increment move counter and sequence index
        boss.moveCounter = boss.moveCounter + 1
        boss.currentSequenceIndex = boss.currentSequenceIndex + 1
        
        -- Wrap around sequence
        if boss.currentSequenceIndex > #boss.currentSequence then
            boss.currentSequenceIndex = 1
            print("BOSS DEBUG: Sequence wrapped around to start")
        end
        
        print("BOSS DEBUG: Next ability will be:", boss.currentSequence[boss.currentSequenceIndex])
        
        -- Set vulnerability phase - boss cannot attack for a period
        boss.lastActionTime = tick() + BossConfig.timing.vulnerabilityDuration
        print("BOSS DEBUG: Vulnerability period started for", BossConfig.timing.vulnerabilityDuration, "seconds")
        
        -- Always resume normal movement after attack
        boss.state = "Moving"
        print("BOSS DEBUG: Boss state set to Moving")
        
        local moveSuccess, moveError = pcall(function()
        BossMovement.moveToRandomPlayer(boss)
        end)
        
        if moveSuccess then
            print("BOSS DEBUG: Boss movement resumed")
        else
            warn("BOSS ERROR: Failed to resume movement:", moveError)
        end
        
        print("BOSS DEBUG: === ABILITY", abilityName, "COMPLETE ===")
    end)
end



local function updateBoss(deltaTime: number)
    if not activeBoss then return end
    
    local boss = activeBoss
    local currentTime = tick()
    
    -- ENHANCED: Validate boss state before processing
    if not validateBossState(boss) then
        warn("BOSS ERROR: Boss state validation failed - despawning")
        BossController.despawnBoss()
        return
    end
    
    -- ENHANCED: Recovery mechanisms for stuck states
    recoverStuckBoss(boss)
    
    -- Check if boss is dead
    if boss.health <= 0 then
        print("BOSS DEBUG: Boss health depleted - transitioning to Dead state")
        boss.state = "Dead"
        BossController.despawnBoss()
        return
    end
    
    -- Update based on current state
    if boss.state == "Falling" then
        -- Boss is falling from sky, don't do anything until it lands
        return
    elseif boss.state == "Moving" then
        BossMovement.updateMovement(boss, deltaTime)
        
        -- Check if grace period has ended
        if boss.inGracePeriod and boss.landingTime then
            local gracePeriodElapsed = currentTime - boss.landingTime >= BossConfig.timing.gracePeriod
            if gracePeriodElapsed then
                boss.inGracePeriod = false
                print("Boss grace period ended - can now attack and be damaged")
            end
        end
        
        -- Check if should start next attack (if close enough to target and not in grace period)
        local shouldAttack = BossMovement.isCloseToTarget(boss)
        local vulnerabilityPassed = currentTime >= boss.lastActionTime
        local notInGracePeriod = not boss.inGracePeriod
        
        -- Only print debug messages when state changes or every few seconds
        local timeSinceLastDebug = currentTime - (boss.lastDebugTime or 0)
        if shouldAttack and not vulnerabilityPassed and timeSinceLastDebug >= 2 then
            local timeLeft = boss.lastActionTime - currentTime
            print("Boss is close to target but in vulnerability phase:", math.ceil(timeLeft), "seconds left")
            boss.lastDebugTime = currentTime
        elseif shouldAttack and vulnerabilityPassed and not notInGracePeriod and timeSinceLastDebug >= 2 then
            local graceTimeLeft = BossConfig.timing.gracePeriod - (currentTime - (boss.landingTime or 0))
            print("Boss is close to target but in grace period:", math.ceil(graceTimeLeft), "seconds left")
            boss.lastDebugTime = currentTime
        end
        
        if shouldAttack and vulnerabilityPassed and notInGracePeriod then
            print("Boss vulnerability phase ended - executing ability!")
            executeNextAbility(boss)
        end
        
    -- Removed old invincibility state handling - now using simple flag system
    end
end

-- ENHANCED: Landing detection with multiple backup methods for reliability
local function setupLandingDetection(boss: Types.BossData, originalSpawnPos: Vector3)
    local humanoid = boss.humanoid
    local rootPart = boss.rootPart
    
    -- Track if boss has landed
    local hasLanded = false
    local fallStartTime = tick()
    local maxFallTime = 15 -- Maximum time boss can fall before forcing landing
    
    print("BOSS DEBUG: Setting up landing detection at position:", originalSpawnPos)
    print("BOSS DEBUG: Boss current position:", rootPart.Position)
    print("BOSS DEBUG: Fall start time:", fallStartTime)
    
    -- Store references locally to prevent garbage collection issues
    local remoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
    local bossMovement = BossMovement
    
    -- Function to trigger landing (used by all detection methods)
    local function triggerLanding(detectionMethod: string)
        if hasLanded then return end -- Prevent multiple triggers
        
        hasLanded = true
        local currentTime = tick()
        local fallDuration = currentTime - fallStartTime
        
        print("BOSS DEBUG: Landing triggered by", detectionMethod)
        print("BOSS DEBUG: Fall duration:", math.floor(fallDuration * 100) / 100, "seconds")
        print("BOSS DEBUG: Boss position at landing:", rootPart.Position)
        
        -- Start grace period - boss can't attack or be damaged for 10 seconds
        boss.landingTime = currentTime
        boss.inGracePeriod = true
        print("BOSS DEBUG: Grace period started - 10 seconds of immunity")
        
        -- Transition boss to Moving state and start normal behavior
        boss.state = "Moving"
        print("BOSS DEBUG: Boss state changed to Moving")
        
        -- Now start targeting and movement
        bossMovement.moveToRandomPlayer(boss)
        print("BOSS DEBUG: Boss movement and targeting started")
        
        -- Fire remote event to all clients for screen shake and health bar
        local success, errorMsg = pcall(function()
            local bossData = {
                health = boss.health,
                maxHealth = boss.maxHealth,
                name = "Boss" -- You can customize this later
            }
            remoteEvents.BossLanded:FireAllClients(bossData)
        end)
        
        if success then
            print("BOSS DEBUG: Boss landed remote event fired successfully with health data")
        else
            warn("BOSS ERROR: Failed to fire boss landed remote:", errorMsg)
        end
        
        -- Cleanup all detection connections
        if boss.landingConnection then
            boss.landingConnection:Disconnect()
            boss.landingConnection = nil
            print("BOSS DEBUG: Primary landing connection cleaned up")
        end
        if boss.backupLandingConnection then
            boss.backupLandingConnection:Disconnect()
            boss.backupLandingConnection = nil
            print("BOSS DEBUG: Backup landing connection cleaned up")
        end
        if boss.forceLandingConnection then
            task.cancel(boss.forceLandingConnection)
            boss.forceLandingConnection = nil
            print("BOSS DEBUG: Force landing connection cleaned up")
        end
    end
    
    -- PRIMARY DETECTION: Humanoid state changes (original method)
    local stateConnection
    stateConnection = humanoid.StateChanged:Connect(function(oldState, newState)
        print("BOSS DEBUG: Humanoid state changed from", oldState, "to", newState)
        
        -- Check if boss landed after falling
        if not hasLanded and (newState == Enum.HumanoidStateType.Landed or newState == Enum.HumanoidStateType.Running) then
            -- Verify boss is close to ground level (within reasonable range of original spawn position)
            local currentY = rootPart.Position.Y
            local groundY = originalSpawnPos.Y
            
            print("BOSS DEBUG: Potential landing detected - Current Y:", currentY, "Ground Y:", groundY, "Difference:", currentY - groundY)
            
            -- If boss is within 10 studs of ground level, consider it landed
            if currentY <= groundY + 10 then
                triggerLanding("primary_humanoid_state")
            else
                print("BOSS DEBUG: Boss not close enough to ground, continuing to fall")
            end
        end
    end)
                
    -- Store primary connection for cleanup
    boss.landingConnection = stateConnection
    print("BOSS DEBUG: Primary humanoid state detection setup complete")
                
    -- BACKUP DETECTION A: Position-based detection (checks every frame)
    local backupConnection = RunService.Heartbeat:Connect(function()
        if hasLanded then return end
        
        local currentY = rootPart.Position.Y
        local groundY = originalSpawnPos.Y
        local distanceToGround = currentY - groundY
        
        -- More forgiving position-based detection
        if distanceToGround <= 12 and rootPart.Velocity.Y >= -5 then -- Nearly stopped falling and close to ground
            print("BOSS DEBUG: Backup position detection triggered - Distance to ground:", distanceToGround, "Velocity Y:", rootPart.Velocity.Y)
            triggerLanding("backup_position_based")
        end
    end)
    
    boss.backupLandingConnection = backupConnection
    print("BOSS DEBUG: Backup position-based detection setup complete")
    
    -- BACKUP DETECTION B: Timer-based forced landing (ultimate fallback)
    local forceConnection = task.spawn(function()
        while not hasLanded do
            task.wait(1) -- Check every second
            
            local currentTime = tick()
            local fallDuration = currentTime - fallStartTime
            
            if fallDuration > maxFallTime then
                warn("BOSS WARNING: Landing detection failed after", fallDuration, "seconds - forcing landing!")
                print("BOSS DEBUG: Current position:", rootPart.Position)
                print("BOSS DEBUG: Target position:", originalSpawnPos)
                print("BOSS DEBUG: Current velocity:", rootPart.Velocity)
                triggerLanding("backup_timer_forced")
                break
            elseif fallDuration > maxFallTime * 0.5 then -- Warn at halfway point
                print("BOSS DEBUG: Fall duration:", math.floor(fallDuration * 100) / 100, "seconds - still falling")
            end
        end
    end)
    
    boss.forceLandingConnection = forceConnection
    print("BOSS DEBUG: Timer-based force landing detection setup complete")
    
    print("BOSS DEBUG: All landing detection methods active")
end

-- Public functions
function BossController.spawnBoss(position: Vector3?): boolean
    print("BOSS DEBUG: === STARTING BOSS SPAWN PROCESS ===")
    
    if activeBoss then
        warn("BOSS ERROR: Boss already exists! Despawn current boss first.")
        return false
    end
    
    -- ENHANCED: Store critical references locally before async operations
    local templateManager = TemplateManager
    local bossMovement = BossMovement
    local remoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
    local bossAbilitiesRemote = _G.BossAbilitiesRemote or ReplicatedStorage:FindFirstChild("BossAbilities")
    
    print("BOSS DEBUG: Critical references captured")
    print("BOSS DEBUG: - TemplateManager:", templateManager and "✓" or "✗")
    print("BOSS DEBUG: - BossMovement:", bossMovement and "✓" or "✗") 
    print("BOSS DEBUG: - RemoteEvents:", remoteEvents and "✓" or "✗")
    print("BOSS DEBUG: - BossAbilitiesRemote:", bossAbilitiesRemote and "✓" or "✗")
    
    -- Validate templates before spawning
    if not templateManager.validateTemplates() then
        error("BOSS ERROR: Cannot spawn boss - Template validation failed!")
        return false
    end
    print("BOSS DEBUG: Template validation passed")
    
    local spawnPos = position or BossConfig.boss.spawnPosition
    print("BOSS DEBUG: Spawn position determined:", spawnPos)
    
    -- Spawn boss in the sky (100 studs above the target position)
    local skySpawnPos = Vector3.new(spawnPos.X, spawnPos.Y + 100, spawnPos.Z)
    print("BOSS DEBUG: Sky spawn position calculated:", skySpawnPos)
    
    -- ENHANCED: Improved async boss creation with better error handling
    task.spawn(function()
        local spawnStartTime = tick()
        print("BOSS DEBUG: Async spawn process started at", spawnStartTime)
        
        -- Step 1: Create boss model asynchronously (prevents lag spike)
        print("BOSS DEBUG: Step 1 - Creating boss model...")
        createBossModelAsync(function(bossModel)
            local step1Time = tick()
            print("BOSS DEBUG: Step 1 completed in", math.floor((step1Time - spawnStartTime) * 1000), "ms")
            
            if not bossModel then
                warn("BOSS ERROR: Failed to create boss model - spawn aborted")
                return
            end
            
            -- Validate boss model components
            local humanoid = bossModel:FindFirstChild("Humanoid")
            local rootPart = bossModel:FindFirstChild("HumanoidRootPart")
            
            if not humanoid or not rootPart then
                warn("BOSS ERROR: Boss model missing required components - Humanoid:", humanoid and "✓" or "✗", "RootPart:", rootPart and "✓" or "✗")
                bossModel:Destroy()
                return
            end
            
            print("BOSS DEBUG: Boss model validation passed")
            print("BOSS DEBUG: Initial position:", rootPart.Position)
            
            -- Yield to next frame after model creation
            task.wait()
            
            -- Step 2: Position boss (quick operation)
            print("BOSS DEBUG: Step 2 - Positioning boss...")
            local step2Start = tick()
            
            -- ENHANCED: More robust positioning with validation
            local success, errorMsg = pcall(function()
                rootPart.CFrame = CFrame.new(skySpawnPos)
            end)
            
            if not success then
                warn("BOSS ERROR: Failed to position boss:", errorMsg)
                bossModel:Destroy()
                return
            end
            
            print("BOSS DEBUG: Step 2 completed - Position set to:", rootPart.Position)
            print("BOSS DEBUG: Position verification - Expected:", skySpawnPos, "Actual:", rootPart.Position)
            
            -- Step 3: Initialize boss data (moderate operation)
            print("BOSS DEBUG: Step 3 - Initializing boss data...")
            local step3Start = tick()
            
            local newBossData = initializeBossData(bossModel)
            if not newBossData then
                warn("BOSS ERROR: Failed to initialize boss data")
                bossModel:Destroy()
                return
            end
            
            -- ENHANCED: Set activeBoss only after validation
            activeBoss = newBossData
            print("BOSS DEBUG: Step 3 completed - Boss data initialized")
            print("BOSS DEBUG: Boss state:", activeBoss.state)
            print("BOSS DEBUG: Boss health:", activeBoss.health, "/", activeBoss.maxHealth)
            
            -- Yield to next frame after data initialization
            task.wait()
            
            -- Step 4: Setup landing detection (lightweight operation)
            print("BOSS DEBUG: Step 4 - Setting up landing detection...")
            local step4Start = tick()
            
            local landingSuccess, landingError = pcall(function()
            setupLandingDetection(activeBoss, spawnPos)
            end)
            
            if not landingSuccess then
                warn("BOSS ERROR: Failed to setup landing detection:", landingError)
                -- Continue anyway - we have backup detection methods
            else
                print("BOSS DEBUG: Step 4 completed - Landing detection active")
            end
            
            -- Step 5: Start the boss update loop
            print("BOSS DEBUG: Step 5 - Starting boss update loop...")
            
            if bossUpdateConnection then
                warn("BOSS WARNING: Boss update connection already exists - disconnecting old one")
                bossUpdateConnection:Disconnect()
            end
            
            bossUpdateConnection = RunService.Heartbeat:Connect(updateBoss)
            print("BOSS DEBUG: Step 5 completed - Update loop started")
            
            -- Yield to next frame before heavy operations
            task.wait()
            
            -- Step 6: Setup melee detection (can be expensive due to part creation)
            print("BOSS DEBUG: Step 6 - Setting up melee detection...")
            
            if activeBoss and activeBoss.state == "Falling" then
                local meleeSuccess, meleeError = pcall(function()
                    bossMovement.setupMeleeTouchDetection(activeBoss)
                end)
                
                if meleeSuccess then
                    print("BOSS DEBUG: Step 6 completed - Melee detection active")
                else
                    warn("BOSS ERROR: Failed to setup melee detection:", meleeError)
                end
            else
                warn("BOSS WARNING: Boss not in Falling state for melee setup - State:", activeBoss and activeBoss.state or "nil")
            end
            
            -- Yield to next frame before client notification
            task.wait()
            
            -- Step 7: Notify clients that boss spawned
            print("BOSS DEBUG: Step 7 - Notifying clients...")
            
            if bossAbilitiesRemote then
                local clientSuccess, clientError = pcall(function()
                    bossAbilitiesRemote:FireAllClients({
                    abilityType = "bossSpawned",
                    bossPosition = spawnPos
                })
                end)
                
                if clientSuccess then
                    print("BOSS DEBUG: Step 7 completed - Client notification sent")
                else
                    warn("BOSS ERROR: Failed to notify clients:", clientError)
                end
            else
                warn("BOSS ERROR: BossAbilities remote not found - clients not notified")
            end
            
            local totalTime = tick() - spawnStartTime
            print("BOSS DEBUG: === BOSS SPAWN COMPLETE ===")
            print("BOSS DEBUG: Total spawn time:", math.floor(totalTime * 1000), "ms")
            print("BOSS DEBUG: Final position:", activeBoss.rootPart.Position)
            print("BOSS DEBUG: Final state:", activeBoss.state)
        end)
    end)
    
    -- Return true to indicate spawn process has started
    print("BOSS DEBUG: Spawn process initiated - returning true")
    return true
end

function BossController.despawnBoss()
    if not activeBoss then return end
    
    -- Store reference before cleanup
    local boss = activeBoss
    
    -- Notify clients that boss is being destroyed
    local remote = _G.BossAbilitiesRemote or ReplicatedStorage:FindFirstChild("BossAbilities")
    if remote then
        remote:FireAllClients({
            abilityType = "bossDestroyed"
        })
    end
    
    -- Cleanup abilities
    TrackingShot.cleanup(boss)
    OrbitalStrike.cleanup(boss)
    RippleSquares.cleanup(boss)
    BossInvincibility.cleanup(boss)
    
    -- Cleanup connections
    if bossUpdateConnection then
        bossUpdateConnection:Disconnect()
        bossUpdateConnection = nil
    end
    
    -- ENHANCED: Cleanup all landing connections
    if boss.landingConnection then
        boss.landingConnection:Disconnect()
        boss.landingConnection = nil
        print("BOSS DEBUG: Primary landing connection cleaned up during despawn")
    end
    
    if boss.backupLandingConnection then
        boss.backupLandingConnection:Disconnect()
        boss.backupLandingConnection = nil
        print("BOSS DEBUG: Backup landing connection cleaned up during despawn")
    end
    
    if boss.forceLandingConnection then
        task.cancel(boss.forceLandingConnection)
        boss.forceLandingConnection = nil
        print("BOSS DEBUG: Force landing connection cleaned up during despawn")
    end
    
    if activeBoss.model then
        activeBoss.model:Destroy()
    end
    
    activeBoss = nil
    print("Boss despawned")
end

function BossController.getBoss(): Types.BossData?
    return activeBoss
end

function BossController.damagePlayer(player: Player, damage: number, damageType: string?)
    if not player.Character then return end
    
    local humanoid = player.Character:FindFirstChild("Humanoid") :: Humanoid?
    if not humanoid then return end
    
    -- Apply damage
    humanoid.Health = math.max(0, humanoid.Health - damage)
    print(player.Name, "took", damage, "damage from boss", damageType or "unknown")
    
    -- TODO: Add visual damage indicators and sound effects
end

function BossController.getActivePlayers(): {Player}
    return getActivePlayers()
end

function BossController.damageBoss(damage: number, source: Player?): boolean
    if not activeBoss then return false end
    
    -- Grace period check - block all damage during grace period
    if activeBoss.inGracePeriod then
        if source then
            print(source.Name, "tried to damage boss but it's in grace period!")
        end
        return false
    end
    
    -- Simple invincibility check - block all damage during attacks
    if activeBoss.isInvincible then
        if source then
            print(source.Name, "tried to damage boss but it's invincible during attack!")
        end
        return false
    end
    
    -- Apply damage normally when vulnerable
    local oldHealth = activeBoss.health
    activeBoss.health = math.max(0, activeBoss.health - damage)
    
    -- Send health update to clients if health changed
    if oldHealth ~= activeBoss.health then
        BossController.sendHealthUpdate()
    end
    
    if source then
        print(source.Name, "dealt", damage, "damage to boss. Boss health:", activeBoss.health)
    else
        print("Boss took", damage, "damage. Boss health:", activeBoss.health)
    end
    
    return true
end

-- Send boss health update to all clients
function BossController.sendHealthUpdate()
    if not activeBoss then return end
    
    local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
    local success, errorMsg = pcall(function()
        RemoteEvents.BossHealthUpdate:FireAllClients({
            health = activeBoss.health,
            maxHealth = activeBoss.maxHealth
        })
    end)
    
    if not success then
        warn("BOSS ERROR: Failed to send health update:", errorMsg)
    end
end

-- Initialize on server start
local function initialize()
    print("Boss Controller initialized")
    
    -- Initialize template manager
    if not TemplateManager.initialize() then
        error("Failed to initialize templates! Check ServerStorage for BossTemplate and EnemyTemplate")
        return
    end
    
    -- Auto-spawn removed - boss is spawned manually from init.server.luau
end

-- Start initialization
initialize()

return BossController ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="60">
          <Properties>
            <string name="Name">BossInvincibility</string>
            <string name="Source"><![CDATA[-- Boss Invincibility System - Handles invincibility phases and effects
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)
local Types = require(ReplicatedStorage.Shared.Types)

local BossInvincibility = {}

-- Private variables
local invincibilityEffects: {[Types.BossData]: {Instance}} = {}

-- Private functions
local function createInvincibilityEffects(boss: Types.BossData)
    local effects = {}
    local rootPart = boss.rootPart
    
    -- Create glowing effect
    local pointLight = Instance.new("PointLight")
    pointLight.Color = Color3.new(1, 0.8, 0)  -- Golden glow
    pointLight.Brightness = 2
    pointLight.Range = 20
    pointLight.Parent = rootPart
    table.insert(effects, pointLight)
    
    -- Create particle effect
    local attachment = Instance.new("Attachment")
    attachment.Parent = rootPart
    table.insert(effects, attachment)
    
    local particles = Instance.new("ParticleEmitter")
    particles.Color = ColorSequence.new(Color3.new(1, 1, 0))  -- Yellow particles
    particles.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(1, 0)
    }
    particles.Lifetime = NumberRange.new(1, 2)
    particles.Rate = 50
    particles.SpreadAngle = Vector2.new(45, 45)
    particles.Speed = NumberRange.new(5, 10)
    particles.Parent = attachment
    table.insert(effects, particles)
    
    -- Create pulsing effect on the boss model
    local originalColor = rootPart.Color
    local originalMaterial = rootPart.Material
    local originalTransparency = rootPart.Transparency
    
    -- Change appearance during invincibility
    rootPart.Color = Color3.new(1, 1, 0)  -- Golden color
    rootPart.Material = Enum.Material.ForceField
    
    -- Create pulsing transparency tween
    local pulseInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
    local pulseTween = TweenService:Create(rootPart, pulseInfo, {Transparency = 0.3})
    pulseTween:Play()
    table.insert(effects, pulseTween)
    
    -- Store original properties for restoration
    effects.originalColor = originalColor
    effects.originalMaterial = originalMaterial
    effects.originalTransparency = originalTransparency
    
    invincibilityEffects[boss] = effects
end

local function removeInvincibilityEffects(boss: Types.BossData)
    local effects = invincibilityEffects[boss]
    if not effects then return end
    
    -- Restore original appearance
    local rootPart = boss.rootPart
    if effects.originalColor then
        rootPart.Color = effects.originalColor
    end
    if effects.originalMaterial then
        rootPart.Material = effects.originalMaterial
    end
    if effects.originalTransparency then
        rootPart.Transparency = effects.originalTransparency
    end
    
    -- Clean up effects
    for _, effect in pairs(effects) do
        if typeof(effect) == "Instance" then
            effect:Destroy()
        elseif typeof(effect) == "Tween" then
            effect:Cancel()
        end
    end
    
    invincibilityEffects[boss] = nil
end

local function healBoss(boss: Types.BossData, amount: number)
    local newHealth = math.min(boss.health + amount, boss.maxHealth)
    boss.health = newHealth
    
    print("Boss healed for", amount, "health. Current health:", newHealth)
end

-- Public functions
function BossInvincibility.startInvincibilityPhase(boss: Types.BossData)
    print("Boss entering invincibility phase")
    
    boss.isInvincible = true
    boss.invincibilityStartTime = tick()
    boss.state = "Invincible"
    boss.moveCounter = 0  -- Reset move counter
    
    -- Stop movement
    local BossMovement = require(script.Parent.BossMovement)
    BossMovement.stopMovement(boss)
    
    -- Create visual effects
    createInvincibilityEffects(boss)
    
    -- Optional healing
    if BossConfig.invincibility.healAmount > 0 then
        healBoss(boss, BossConfig.invincibility.healAmount)
    end
    
    -- TODO: Fire remote event to clients for additional effects
end

function BossInvincibility.endInvincibilityPhase(boss: Types.BossData)
    print("Boss exiting invincibility phase")
    
    boss.isInvincible = false
    boss.invincibilityStartTime = nil
    
    -- Remove visual effects
    removeInvincibilityEffects(boss)
    
    -- TODO: Fire remote event to clients to end effects
end

function BossInvincibility.updateInvincibilityEffects(boss: Types.BossData, deltaTime: number)
    if not boss.isInvincible then return end
    
    -- Update any dynamic effects here
    -- For now, the tween handles the pulsing automatically
    
    -- Could add more complex effects like:
    -- - Rotating particles
    -- - Changing light intensity
    -- - Sound effects
end

function BossInvincibility.shouldEndInvincibility(boss: Types.BossData): boolean
    if not boss.isInvincible or not boss.invincibilityStartTime then
        return false
    end
    
    local currentTime = tick()
    local elapsedTime = currentTime - boss.invincibilityStartTime
    
    return elapsedTime >= BossConfig.invincibility.duration
end

function BossInvincibility.isInvincible(boss: Types.BossData): boolean
    return boss.isInvincible
end

function BossInvincibility.blockDamage(boss: Types.BossData, damageAmount: number): number
    if not boss.isInvincible then
        return damageAmount  -- No damage reduction
    end
    
    local damageReduction = BossConfig.invincibility.damageReduction
    local actualDamage = damageAmount * (1 - damageReduction)
    
    if actualDamage < damageAmount then
        print("Boss invincibility blocked", damageAmount - actualDamage, "damage")
    end
    
    return actualDamage
end

function BossInvincibility.getRemainingInvincibilityTime(boss: Types.BossData): number?
    if not boss.isInvincible or not boss.invincibilityStartTime then
        return nil
    end
    
    local currentTime = tick()
    local elapsedTime = currentTime - boss.invincibilityStartTime
    local remainingTime = BossConfig.invincibility.duration - elapsedTime
    
    return math.max(0, remainingTime)
end

-- Cleanup function for when boss is destroyed
function BossInvincibility.cleanup(boss: Types.BossData)
    removeInvincibilityEffects(boss)
end

return BossInvincibility ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="61">
          <Properties>
            <string name="Name">BossMovement</string>
            <string name="Source"><![CDATA[-- Boss Movement System - Simplified version with no pathfinding
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)
local Types = require(ReplicatedStorage.Shared.Types)

local BossMovement = {}

-- Private functions
local function getRandomPlayer(): Player?
    local activePlayers = {}
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            table.insert(activePlayers, player)
        end
    end
    
    if #activePlayers == 0 then return nil end
    
    return activePlayers[math.random(1, #activePlayers)]
end

local function setupMeleeTouchDetection(boss: Types.BossData)
    -- Create a larger invisible part for melee detection
    local meleePart = Instance.new("Part")
    meleePart.Name = "MeleeDetector"
    meleePart.Size = Vector3.new(BossConfig.movement.meleeRange * 2, BossConfig.movement.meleeRange * 2, BossConfig.movement.meleeRange * 2)
    meleePart.Transparency = 1
    meleePart.CanCollide = false
    meleePart.Anchored = false
    meleePart.Shape = Enum.PartType.Ball
    meleePart.Parent = boss.model
    
    -- Weld it to the boss
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = boss.rootPart
    weld.Part1 = meleePart
    weld.Parent = meleePart
    
    -- Handle touch events
    meleePart.Touched:Connect(function(hit)
        if boss.state ~= "Moving" then return end
        
        local character = hit.Parent
        local humanoid = character:FindFirstChild("Humanoid")
        local player = Players:GetPlayerFromCharacter(character)
        
        if player and humanoid then
            local currentTime = tick()
            local lastHitTime = boss.lastMeleeHit[player] or 0
            local cooldownPassed = currentTime - lastHitTime >= BossConfig.movement.meleeCooldown
            
            if cooldownPassed then
                dealMeleeDamage(boss, player)
                boss.lastMeleeHit[player] = currentTime
            end
        end
    end)
    
    return meleePart
end

function dealMeleeDamage(boss: Types.BossData, player: Player)
    local damage = BossConfig.movement.meleeDamage
    local knockback = BossConfig.movement.meleeKnockback
    
    -- Apply damage directly to avoid circular dependency
    if player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid") :: Humanoid?
        if humanoid then
            humanoid.Health = math.max(0, humanoid.Health - damage)
            print(player.Name, "took", damage, "melee damage from boss")
        end
    end
    
    -- Apply knockback
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local playerRootPart = player.Character:FindFirstChild("HumanoidRootPart") :: BasePart
        local bossPosition = boss.rootPart.Position
        local playerPosition = playerRootPart.Position
        
        local knockbackDirection = (playerPosition - bossPosition).Unit
        local knockbackForce = Instance.new("BodyVelocity")
        knockbackForce.MaxForce = Vector3.new(4000, 0, 4000)
        knockbackForce.Velocity = knockbackDirection * knockback
        knockbackForce.Parent = playerRootPart
        
        -- Remove knockback after short duration
        game:GetService("Debris"):AddItem(knockbackForce, 0.5)
    end
    
    print("Boss dealt melee damage to", player.Name)
end

-- Public functions
function BossMovement.moveToRandomPlayer(boss: Types.BossData)
    local targetPlayer = getRandomPlayer()
    if not targetPlayer then
        warn("No active players found for boss to target")
        return
    end
    
    boss.currentTarget = targetPlayer
    print("Boss is now targeting:", targetPlayer.Name, "(no movement logic)")
end

function BossMovement.updateMovement(boss: Types.BossData, deltaTime: number)
    -- No movement logic - boss just stands still
    if boss.state ~= "Moving" then return end
    
    -- If boss has no target, try to find one
    if not boss.currentTarget then
        print("Boss has no target, trying to find one...")
        BossMovement.moveToRandomPlayer(boss)
    end
    
    -- Check if current target is still valid
    if boss.currentTarget and (not boss.currentTarget.Character or not boss.currentTarget.Character:FindFirstChild("HumanoidRootPart")) then
        print("Current target is no longer valid, finding new target...")
        BossMovement.moveToRandomPlayer(boss)
    end
end

function BossMovement.stopMovement(boss: Types.BossData)
    local humanoid = boss.humanoid
    local rootPart = boss.rootPart
    
    if humanoid and rootPart then
        -- Stop the humanoid by making it move to its current position
        humanoid:MoveTo(rootPart.Position)
        humanoid.WalkSpeed = 0
    end
    
    print("Boss movement stopped")
end

function BossMovement.resumeMovement(boss: Types.BossData)
    local humanoid = boss.humanoid
    
    if humanoid then
        -- Restore movement speed
        humanoid.WalkSpeed = BossConfig.movement.speed
    end
    
    -- Select new random player target (but don't move)
    BossMovement.moveToRandomPlayer(boss)
end

function BossMovement.isCloseToTarget(boss: Types.BossData): boolean
    if not boss.currentTarget or not boss.currentTarget.Character then
        return false
    end
    
    local targetRootPart = boss.currentTarget.Character:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then 
        return false 
    end
    
    local distance = (boss.rootPart.Position - (targetRootPart :: BasePart).Position).Magnitude
    local isClose = distance <= BossConfig.movement.stoppingDistance
    
    -- Only print debug when boss first gets close (state change)
    if isClose and not boss.wasCloseToTarget then
        print("Boss is now close to target! Distance:", math.floor(distance), "/ Required:", BossConfig.movement.stoppingDistance)
        boss.wasCloseToTarget = true
    elseif not isClose and boss.wasCloseToTarget then
        boss.wasCloseToTarget = false
    end
    
    return isClose
end

function BossMovement.getCurrentTarget(boss: Types.BossData): Player?
    return boss.currentTarget
end

function BossMovement.getDistanceToTarget(boss: Types.BossData): number?
    if not boss.currentTarget or not boss.currentTarget.Character then
        return nil
    end
    
    local targetRootPart = boss.currentTarget.Character:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then return nil end
    
    return (boss.rootPart.Position - targetRootPart.Position).Magnitude
end

function BossMovement.setupMeleeTouchDetection(boss: Types.BossData)
    return setupMeleeTouchDetection(boss)
end

-- Legacy compatibility functions (keeping the same interface)
function BossMovement.updatePathToTarget(boss: Types.BossData)
    -- No pathfinding logic
end

return BossMovement ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="62">
          <Properties>
            <string name="Name">MissilePhysics</string>
            <string name="Source"><![CDATA[-- Missile Physics System - Server-side authoritative missile simulation
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)
local Types = require(ReplicatedStorage.Shared.Types)
local FrameBudgetManager = require(ReplicatedStorage.Shared.FrameBudgetManager)
local RemoteEventBatcher = require(ReplicatedStorage.Shared.RemoteEventBatcher)

local MissilePhysics = {}

-- Types
type MissileData = {
    id: string,
    position: Vector3,
    velocity: Vector3,
    target: Player,
    bossPosition: Vector3,
    spawnTime: number,
    lastUpdateTime: number,
    isActive: boolean
}

-- Private variables
local activeMissiles: {[string]: MissileData} = {}
local missileUpdateConnection: RBXScriptConnection?
local nextMissileId = 1

-- Get the RemoteEvent for client communication
local function getBossAbilitiesRemote(): RemoteEvent
    return _G.BossAbilitiesRemote or ReplicatedStorage:FindFirstChild("BossAbilities")
end

-- Private functions
local function generateMissileId(): string
    local id = "missile_" .. tostring(nextMissileId)
    nextMissileId = nextMissileId + 1
    return id
end

local function sendMissileUpdate(missileId: string, updateType: string, data: {[string]: any})
    local remote = getBossAbilitiesRemote()
    if not remote then
        warn("BossAbilities RemoteEvent not found!")
        return
    end
    
    local updateData = {
        abilityType = "trackingShot",
        phase = "missile",
        updateType = updateType,
        missileId = missileId
    }
    
    -- Add missile-specific data
    for key, value in pairs(data) do
        updateData[key] = value
    end
    
    -- PERFORMANCE OPTIMIZATION: Batch position updates but send critical events immediately
    if updateType == "update" then
        RemoteEventBatcher.queueEvent(remote, updateData)
    else
        -- Immediate for spawn, explode, destroy
        remote:FireAllClients(updateData)
    end
end

local function calculateSteering(missile: MissileData, deltaTime: number): Vector3
    if not missile.target.Character or not missile.target.Character:FindFirstChild("HumanoidRootPart") then
        return missile.velocity -- Continue straight if no target
    end
    
    local targetRootPart = missile.target.Character:FindFirstChild("HumanoidRootPart") :: BasePart
    local targetPosition = targetRootPart.Position
    
    -- Aim for a point slightly above the player for better visibility and gameplay
    local adjustedTarget = targetPosition + Vector3.new(0, 2, 0)
    
    local toTarget = (adjustedTarget - missile.position)
    local distance = toTarget.Magnitude
    
    if distance < 0.1 then
        return missile.velocity -- Continue straight if very close
    end
    
    local desiredDirection = toTarget.Unit
    local currentDirection = missile.velocity.Unit
    
    -- Calculate maximum turn angle per frame based on turn rate
    local config = BossConfig.abilities.trackingShot
    local maxTurnAngle = config.missileTurnRate * deltaTime -- radians per frame
    
    -- Calculate angle between current and desired direction
    local dot = currentDirection:Dot(desiredDirection)
    local angle = math.acos(math.clamp(dot, -1, 1))
    
    -- Limit turning to realistic amounts
    if angle > maxTurnAngle then
        -- Can't turn all the way to target in one frame, turn partially
        local turnAxis = currentDirection:Cross(desiredDirection).Unit
        local partialRotation = CFrame.fromAxisAngle(turnAxis, maxTurnAngle)
        local newDirection = partialRotation:VectorToWorldSpace(currentDirection)
        return newDirection * config.missileSpeed
    else
        -- Can reach desired direction this frame
        return desiredDirection * config.missileSpeed
    end
end

local function checkEnvironmentCollision(missile: MissileData, newPosition: Vector3): (boolean, Vector3?)
    local rayDirection = newPosition - missile.position
    local distance = rayDirection.Magnitude
    
    if distance < 0.1 then
        return false, nil
    end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {}
    
    -- Filter out boss
    local boss = workspace:FindFirstChild("Boss")
    if boss then
        table.insert(raycastParams.FilterDescendantsInstances, boss)
    end
    
    -- Filter out all player characters (we handle player collision separately)
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            table.insert(raycastParams.FilterDescendantsInstances, player.Character)
        end
    end
    
    -- Filter out missile visual models (client-side only, shouldn't affect server raycasting)
    
    local raycastResult = workspace:Raycast(missile.position, rayDirection, raycastParams)
    
    if raycastResult then
        print("Missile", missile.id, "hit environment:", raycastResult.Instance.Name, "at", raycastResult.Position)
        return true, raycastResult.Position
    end
    
    return false, nil
end

local function checkPlayerCollision(missile: MissileData): Player?
    local config = BossConfig.abilities.trackingShot
    local missileRadius = math.max(config.missileSize.X, config.missileSize.Y, config.missileSize.Z) / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local playerRootPart = player.Character:FindFirstChild("HumanoidRootPart") :: BasePart
            local playerPosition = playerRootPart.Position
            local distance = (missile.position - playerPosition).Magnitude
            
            if distance <= (missileRadius + 1.5) then -- 1.5 stud player collision radius (reduced)
                return player
            end
        end
    end
    
    return nil
end

local function createMissileExplosion(missileId: string, position: Vector3, hitPlayer: Player?)
    local config = BossConfig.abilities.trackingShot
    
    -- Deal damage to all players in radius
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local playerRootPart = player.Character:FindFirstChild("HumanoidRootPart") :: BasePart
            local playerPosition = playerRootPart.Position
            local distance = (position - playerPosition).Magnitude
            
            if distance <= config.explosionRadius then
                local humanoid = player.Character:FindFirstChild("Humanoid") :: Humanoid?
                if humanoid then
                    humanoid.Health = math.max(0, humanoid.Health - config.damage)
                    print(player.Name, "took", config.damage, "damage from missile explosion")
                end
            end
        end
    end
    
    -- Send explosion event to clients for visual effects
    sendMissileUpdate("explosion_" .. tostring(math.random(1000, 9999)), "explode", {
        position = position,
        hitPlayer = hitPlayer and hitPlayer.UserId or nil
    })
    
    -- Send destroy event to clean up the missile visual
    sendMissileUpdate(missileId, "destroy", {})
end

local function updateMissilePhysics(deltaTime: number)
    local config = BossConfig.abilities.trackingShot
    local currentTime = tick()
    
    -- PERFORMANCE OPTIMIZATION: Batch missile updates with frame budgeting
    local missileOperations = {}
    
    for missileId, missile in pairs(activeMissiles) do
        if not missile.isActive then
            continue
        end
        
        table.insert(missileOperations, function()
            -- Check lifetime
            if currentTime - missile.spawnTime > config.missileLifetime then
                -- Self-destruct
                createMissileExplosion(missileId, missile.position, nil)
                missile.isActive = false
                activeMissiles[missileId] = nil
                return
            end
            
            -- Calculate new velocity with realistic steering
            missile.velocity = calculateSteering(missile, deltaTime)
            
            -- Calculate new position
            local newPosition = missile.position + (missile.velocity * deltaTime)
            
            -- Check environment collision (throttle to every other frame if many missiles)
            local shouldCheckEnvironment = true
            local missileCount = 0
            for _ in pairs(activeMissiles) do missileCount += 1 end
            
            if missileCount > 3 then
                -- For performance, only check environment collision every other frame when many missiles
                shouldCheckEnvironment = (currentTime * 10) % 2 < 1
            end
            
            if shouldCheckEnvironment then
                local hitEnvironment, hitPosition = checkEnvironmentCollision(missile, newPosition)
                if hitEnvironment and hitPosition then
                    createMissileExplosion(missileId, hitPosition, nil)
                    missile.isActive = false
                    activeMissiles[missileId] = nil
                    return
                end
            end
            
            -- Update position
            missile.position = newPosition
            
            -- Check player collision (always check for fairness)
            local hitPlayer = checkPlayerCollision(missile)
            if hitPlayer then
                print("Missile", missileId, "hit player:", hitPlayer.Name, "at position:", missile.position)
                createMissileExplosion(missileId, missile.position, hitPlayer)
                missile.isActive = false
                activeMissiles[missileId] = nil
                return
            end
            
            -- Send periodic updates to clients (reduced frequency for performance)
            local updateFreq = missileCount > 3 and (config.updateRate * 0.6) or config.updateRate
            if currentTime - missile.lastUpdateTime >= (1 / updateFreq) then
                sendMissileUpdate(missileId, "update", {
                    position = missile.position,
                    velocity = missile.velocity,
                    targetId = missile.target.UserId
                })
                missile.lastUpdateTime = currentTime
                
                -- Debug: Print missile position occasionally (reduced frequency)
                if math.random() < 0.01 then -- 1% chance (reduced from 2%)
                    print("Missile", missileId, "at position:", 
                        math.floor(missile.position.X), math.floor(missile.position.Y), math.floor(missile.position.Z),
                        "targeting", missile.target.Name)
                end
            end
        end)
    end
    
    -- Execute missile updates with frame budgeting (max 3 missiles per frame)
    FrameBudgetManager.executeWithLimit(missileOperations, 3)
    
    -- Clean up finished missiles
    if next(activeMissiles) == nil and missileUpdateConnection then
        missileUpdateConnection:Disconnect()
        missileUpdateConnection = nil
        print("All missiles finished - stopping physics updates")
    end
end

-- Public functions
function MissilePhysics.spawnMissile(bossPosition: Vector3, target: Player): string?
    print("MissilePhysics.spawnMissile called for", target.Name)
    
    if not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
        print("Failed to spawn missile - target has no character or HumanoidRootPart")
        return nil
    end
    
    local config = BossConfig.abilities.trackingShot
    local missileId = generateMissileId()
    
    -- Calculate initial velocity towards target
    local targetRootPart = target.Character:FindFirstChild("HumanoidRootPart") :: BasePart
    local targetPosition = targetRootPart.Position
    local direction = (targetPosition - bossPosition).Unit
    local initialVelocity = direction * config.missileSpeed
    
    -- Create missile data
    local spawnOffset = direction * 8 + Vector3.new(0, 2, 0) -- Spawn 8 studs in front of boss, 2 studs up
    local missile: MissileData = {
        id = missileId,
        position = bossPosition + spawnOffset,
        velocity = initialVelocity,
        target = target,
        bossPosition = bossPosition,
        spawnTime = tick(),
        lastUpdateTime = tick(),
        isActive = true
    }
    
    activeMissiles[missileId] = missile
    
    -- Start physics updates if not already running
    if not missileUpdateConnection then
        missileUpdateConnection = RunService.Heartbeat:Connect(updateMissilePhysics)
        print("Started missile physics updates")
    end
    
    -- Send spawn event to clients
    sendMissileUpdate(missileId, "spawn", {
        position = missile.position,
        velocity = missile.velocity,
        targetId = target.UserId,
        bossPosition = bossPosition
    })
    
    print("Spawned missile", missileId, "targeting", target.Name)
    return missileId
end

function MissilePhysics.destroyMissile(missileId: string)
    local missile = activeMissiles[missileId]
    if missile then
        missile.isActive = false
        activeMissiles[missileId] = nil
        
        -- Send destroy event to clients
        sendMissileUpdate(missileId, "destroy", {})
    end
end

function MissilePhysics.destroyAllMissiles()
    for missileId, _ in pairs(activeMissiles) do
        MissilePhysics.destroyMissile(missileId)
    end
    
    if missileUpdateConnection then
        missileUpdateConnection:Disconnect()
        missileUpdateConnection = nil
    end
end

function MissilePhysics.getActiveMissileCount(): number
    local count = 0
    for _, missile in pairs(activeMissiles) do
        if missile.isActive then
            count = count + 1
        end
    end
    return count
end

function MissilePhysics.cleanup()
    MissilePhysics.destroyAllMissiles()
end

return MissilePhysics ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="63">
          <Properties>
            <string name="Name">TemplateManager</string>
            <string name="Source"><![CDATA[-- Template Manager - Handles loading and validation of R6 character templates
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)
local FrameBudgetManager = require(ReplicatedStorage.Shared.FrameBudgetManager)

local TemplateManager = {}

-- Private functions
local function validateR6Character(template: Model): boolean
    -- Check if it's a valid R6 character
    local requiredParts = {
        "Humanoid",
        "HumanoidRootPart", 
        "Head",
        "Torso",
        "Left Arm",
        "Right Arm",
        "Left Leg",
        "Right Leg"
    }
    
    for _, partName in pairs(requiredParts) do
        if not template:FindFirstChild(partName) then
            warn("Template", template.Name, "missing required part:", partName)
            return false
        end
    end
    
    -- Check humanoid type
    local humanoid = template:FindFirstChild("Humanoid") :: Humanoid?
    if humanoid and humanoid.RigType ~= Enum.HumanoidRigType.R6 then
        warn("Template", template.Name, "is not R6 rig type")
        return false
    end
    
    return true
end

-- Public functions
function TemplateManager.validateTemplates(): boolean
    local success = true
    
    -- Check boss template
    local bossTemplate = ServerStorage:FindFirstChild(BossConfig.templates.bossName)
    if not bossTemplate then
        error("BossTemplate not found in ServerStorage! Please create a Dummy named '" .. BossConfig.templates.bossName .. "'")
        return false
    end
    
    if not validateR6Character(bossTemplate) then
        error("BossTemplate is not a valid R6 character!")
        return false
    end
    
    -- Check enemy template (optional - only needed if you add abilities that spawn enemies)
    local enemyTemplate = ServerStorage:FindFirstChild(BossConfig.templates.enemyName)
    if enemyTemplate and not validateR6Character(enemyTemplate) then
        warn("EnemyTemplate exists but is not a valid R6 character!")
    end
    
    print("✅ Boss template validated successfully!")
    print("  - Boss template:", bossTemplate.Name)
    if enemyTemplate then
        print("  - Enemy template:", enemyTemplate.Name, "(optional)")
    end
    
    return true
end

function TemplateManager.loadBossTemplate(): Model
    local template = ServerStorage:FindFirstChild(BossConfig.templates.bossName)
    if not template then
        error("BossTemplate not found! Did you create it in ServerStorage?")
    end
    
    -- PERFORMANCE OPTIMIZATION: The original synchronous clone was causing lag
    -- We still need to return synchronously for compatibility, but we'll optimize the process
    
    local boss = template:Clone()
    
    -- Ensure proper setup (no longer setting health - using custom health system)
    local humanoid = boss:FindFirstChild("Humanoid") :: Humanoid
    if humanoid then
        -- Set to very high health to prevent accidental death from Roblox systems
        humanoid.MaxHealth = math.huge
        humanoid.Health = math.huge
        humanoid.WalkSpeed = BossConfig.boss.walkSpeed
        humanoid.JumpPower = 0 -- Prevent jumping
        humanoid.PlatformStand = false -- Allow normal movement
        -- Disable default health bar and nametag
        humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
    end
    
    -- Set default properties but DON'T set position (will be set by caller)
    local rootPart = boss:FindFirstChild("HumanoidRootPart") :: BasePart
    if rootPart then
        rootPart.Anchored = false
        -- Position will be set by BossController.spawnBoss()
    end
    
    return boss
end

-- ENHANCED: Robust async boss template loading with better error handling
function TemplateManager.loadBossTemplateAsync(callback: (Model?) -> ())
    print("TEMPLATE DEBUG: Starting async boss template load")
    
    local template = ServerStorage:FindFirstChild(BossConfig.templates.bossName)
    if not template then
        local errorMsg = "BossTemplate '" .. BossConfig.templates.bossName .. "' not found in ServerStorage!"
        warn("TEMPLATE ERROR:", errorMsg)
        callback(nil)
        return
    end
    
    print("TEMPLATE DEBUG: Boss template found:", template.Name)
    
    task.spawn(function()
        local startTime = tick()
        
        -- ENHANCED: Better error handling and validation
        local success, result = pcall(function()
            -- Yield to prevent frame drop during clone operation
            FrameBudgetManager.yieldIfNeeded(0.010) -- 10ms estimate for model cloning
            
            print("TEMPLATE DEBUG: Cloning boss template...")
            local boss = template:Clone()
            
            if not boss then
                error("Failed to clone boss template")
            end
            
            -- Validate cloned model
            local humanoid = boss:FindFirstChild("Humanoid")
            local rootPart = boss:FindFirstChild("HumanoidRootPart")
            
            if not humanoid then
                error("Cloned boss missing Humanoid")
            end
            
            if not rootPart then
                error("Cloned boss missing HumanoidRootPart")
            end
            
            print("TEMPLATE DEBUG: Boss model validation passed")
            
            -- Yield again before property setup
            FrameBudgetManager.yieldIfNeeded(0.005) -- 5ms estimate for property setup
            
            -- ENHANCED: Setup with validation (no longer setting health - using custom health system)
            print("TEMPLATE DEBUG: Setting up boss properties...")
            -- Set to very high health to prevent accidental death from Roblox systems
            humanoid.MaxHealth = math.huge
            humanoid.Health = math.huge
            humanoid.WalkSpeed = BossConfig.boss.walkSpeed
            humanoid.JumpPower = 0 -- Prevent jumping
            humanoid.PlatformStand = false -- Allow normal movement
            -- Disable default health bar and nametag
            humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
            
            print("TEMPLATE DEBUG: Boss humanoid configured - Speed:", humanoid.WalkSpeed, "DisplayDistance: None (Health handled by custom system)")
            
            -- Set default properties but DON'T set position (will be set by caller)
            rootPart.Anchored = false
            print("TEMPLATE DEBUG: Boss root part configured - Anchored:", rootPart.Anchored)
            
            return boss
        end)
        
        local loadTime = tick() - startTime
        
        if success and result then
            print("TEMPLATE DEBUG: Boss template loaded successfully in", math.floor(loadTime * 1000), "ms")
            callback(result)
        else
            warn("TEMPLATE ERROR: Failed to load boss template:", result)
            print("TEMPLATE DEBUG: Load failed after", math.floor(loadTime * 1000), "ms")
            callback(nil)
        end
    end)
end

function TemplateManager.loadEnemyTemplate(spawnPosition: Vector3, enemyConfig: any?): Model
    local template = ServerStorage:FindFirstChild(BossConfig.templates.enemyName)
    if not template then
        error("EnemyTemplate not found! Did you create it in ServerStorage?")
    end
    
    local enemy = template:Clone()
    
    -- Setup enemy properties (use provided config or defaults)
    local humanoid = enemy:FindFirstChild("Humanoid") :: Humanoid
    if humanoid and enemyConfig then
        humanoid.MaxHealth = enemyConfig.health or 30
        humanoid.Health = enemyConfig.health or 30
        humanoid.WalkSpeed = enemyConfig.speed or 8
        humanoid.JumpPower = 0
        humanoid.PlatformStand = false
    end
    
    -- Set spawn position
    local rootPart = enemy:FindFirstChild("HumanoidRootPart") :: BasePart
    if rootPart then
        rootPart.Position = spawnPosition
        rootPart.Anchored = false
    end
    
    return enemy
end

function TemplateManager.getBossTemplate(): Model?
    return ServerStorage:FindFirstChild(BossConfig.templates.bossName)
end

function TemplateManager.getEnemyTemplate(): Model?
    return ServerStorage:FindFirstChild(BossConfig.templates.enemyName)
end

-- Initialize template validation
function TemplateManager.initialize()
    if BossConfig.templates.validateOnStart then
        return TemplateManager.validateTemplates()
    end
    return true
end

return TemplateManager ]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="64">
        <Properties>
          <string name="Name">DialogueHandler</string>
          <string name="Source"><![CDATA[-- DialogueHandler.luau
-- Processes dialogue choices and executes actions

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local DialogueData = require(ReplicatedStorage.Shared.DialogueData)
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local DialogueHandler = {}

-- Track active dialogues {[player] = {npcId, startTime}}
DialogueHandler.activeDialogues = {}

-- ENHANCED: Track RunService connection for cleanup
local distanceMonitorConnection = nil

local NPCManager -- Will be set from init.server.luau

function DialogueHandler:SetNPCManager(manager)
	NPCManager = manager
end

-- Get dialogue data for an NPC based on current state
function DialogueHandler:GetDialogueForNPC(npcId, player)
	-- Handle wise man state changes
	if npcId == "wise_man" then
		if NPCManager.questActive then
			return DialogueData.NPCDialogues.wise_man_quest_active
		else
			return DialogueData.NPCDialogues.wise_man_default
		end
	end
	
	-- Return dialogue for other NPCs
	return DialogueData.NPCDialogues[npcId]
end

-- Start dialogue with an NPC
function DialogueHandler:StartDialogue(player, npcId)
	print("StartDialogue called by", player.Name, "for NPC:", npcId)
	
	-- Check if NPC exists
	if not NPCManager.spawnedNPCs[npcId] then
		print("NPC", npcId, "does not exist")
		local availableNPCs = {}
		for npcName, _ in pairs(NPCManager.spawnedNPCs) do
			table.insert(availableNPCs, npcName)
		end
		print("Available NPCs:", table.concat(availableNPCs, ", "))
		return
	end
	
	-- Get dialogue data
	local dialogueData = self:GetDialogueForNPC(npcId, player)
	if not dialogueData then
		print("No dialogue data for", npcId)
		return
	end
	
	print("Found dialogue data for", npcId, "- sending to client")
	
	-- Track active dialogue
	self.activeDialogues[player] = {
		npcId = npcId,
		startTime = tick()
	}
	
	-- Send dialogue to client
	RemoteEvents.DisplayDialogue:FireClient(player, npcId, dialogueData)
	print("Started dialogue between", player.Name, "and", npcId)
end

-- Process a dialogue choice
function DialogueHandler:ProcessChoice(player, npcId, choiceIndex)
	-- Validate active dialogue
	local activeDialogue = self.activeDialogues[player]
	if not activeDialogue or activeDialogue.npcId ~= npcId then
		print("Invalid dialogue state for", player.Name)
		return
	end
	
	-- Get dialogue data and action
	local dialogueData = self:GetDialogueForNPC(npcId, player)
	if not dialogueData or not dialogueData.actions[choiceIndex] then
		print("Invalid choice", choiceIndex, "for", npcId)
		return
	end
	
	local action = dialogueData.actions[choiceIndex]
	print("Processing action:", action, "for player", player.Name)
	
	-- Execute the action
	self:ExecuteAction(player, npcId, action)
end

-- Execute a dialogue action
function DialogueHandler:ExecuteAction(player, npcId, action)
	local responseDialogue = DialogueData.ResponseDialogues[action]
	
	if action == "start_quest" then
		-- Start the quest (spawn princess)
		NPCManager:StartQuest()
		if responseDialogue then
			-- Show response, then auto-end dialogue after delay
			RemoteEvents.DisplayDialogue:FireClient(player, npcId, responseDialogue)
			task.spawn(function()
				task.wait(3)
				self:EndDialogue(player)
			end)
		else
			self:EndDialogue(player)
		end
		
	elseif action == "show_lore" then
		-- Show lore text
		if responseDialogue then
			-- Show response, then auto-end dialogue after delay
			RemoteEvents.DisplayDialogue:FireClient(player, npcId, responseDialogue)
			task.spawn(function()
				task.wait(4) -- Longer delay for lore text
				self:EndDialogue(player)
			end)
		end
		
	elseif action == "quest_info" then
		-- Show quest information
		if responseDialogue then
			-- Show response, then auto-end dialogue after delay
			RemoteEvents.DisplayDialogue:FireClient(player, npcId, responseDialogue)
			task.spawn(function()
				task.wait(3)
				self:EndDialogue(player)
			end)
		end
		
	elseif action == "become_companion" then
		-- Make princess follow player
		NPCManager:MakePrincessFollow(player)
		if responseDialogue then
			-- Show response, then auto-end dialogue after delay
			RemoteEvents.DisplayDialogue:FireClient(player, npcId, responseDialogue)
			task.spawn(function()
				task.wait(3)
				self:EndDialogue(player)
			end)
		else
			self:EndDialogue(player)
		end
		
	elseif action == "enable_combat" then
		-- Enable princess combat mode
		NPCManager:EnablePrincessCombat()
		if responseDialogue then
			-- Show response, then auto-end dialogue after delay
			RemoteEvents.DisplayDialogue:FireClient(player, npcId, responseDialogue)
			task.spawn(function()
				task.wait(3)
				self:EndDialogue(player)
			end)
		else
			self:EndDialogue(player)
		end
		
	elseif action == "open_trade" then
		-- End dialogue immediately to prevent cursor conflicts with trader shop
		self:EndDialogue(player)
		
		-- Use new trader system instead of old trade menu
		local TraderHandler = require(script.Parent.TraderHandler)
		TraderHandler:OpenShop(player, npcId)
		
	elseif action == "tell_story" then
		-- Tell story
		if responseDialogue then
			-- Show response, then auto-end dialogue after delay
			RemoteEvents.DisplayDialogue:FireClient(player, npcId, responseDialogue)
			task.spawn(function()
				task.wait(5) -- Longer delay for story
				self:EndDialogue(player)
			end)
		end
		
	elseif action == "goodbye" then
		-- End dialogue immediately without showing response
		self:EndDialogue(player)
	elseif action == "end_dialogue" then
		-- Simply end the dialogue without showing any response
		self:EndDialogue(player)
	end
end

-- End dialogue for a player
function DialogueHandler:EndDialogue(player)
	if self.activeDialogues[player] then
		print("Ending dialogue for", player.Name)
		self.activeDialogues[player] = nil
		RemoteEvents.EndDialogue:FireClient(player)
	end
end

-- Monitor dialogue distances
function DialogueHandler:MonitorDistances()
	-- Clean up existing connection first
	if distanceMonitorConnection then
		distanceMonitorConnection:Disconnect()
	end
	
	-- Create new connection with tracking
	distanceMonitorConnection = RunService.Heartbeat:Connect(function()
		for player, dialogueInfo in pairs(self.activeDialogues) do
			if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
				local npc = NPCManager.spawnedNPCs[dialogueInfo.npcId]
				if npc and npc:FindFirstChild("HumanoidRootPart") then
					local distance = (player.Character.HumanoidRootPart.Position - npc.HumanoidRootPart.Position).Magnitude
					
					-- End dialogue if too far (20 studs)
					if distance > 20 then
						self:EndDialogue(player)
					end
				end
			end
		end
	end)
end

-- Add cleanup method
function DialogueHandler:Cleanup()
	-- Clean up distance monitor connection
	if distanceMonitorConnection then
		distanceMonitorConnection:Disconnect()
		distanceMonitorConnection = nil
	end
	
	-- End all active dialogues
	for player, dialogueInfo in pairs(self.activeDialogues) do
		RemoteEvents.EndDialogue:FireClient(player)
	end
	self.activeDialogues = {}
end

-- Initialize the dialogue handler
function DialogueHandler:Initialize()
	-- Set up RemoteEvent connections
	RemoteEvents.StartDialogue.OnServerEvent:Connect(function(player, npcId)
		self:StartDialogue(player, npcId)
	end)
	
	RemoteEvents.ProcessChoice.OnServerEvent:Connect(function(player, npcId, choiceIndex)
		self:ProcessChoice(player, npcId, choiceIndex)
	end)
	
	-- Start distance monitoring
	self:MonitorDistances()
	
	print("DialogueHandler initialized")
end

return DialogueHandler ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="65">
        <Properties>
          <string name="Name">EnemySystemInitializer</string>
          <string name="Source"><![CDATA[-- EnemySystemInitializer.luau
-- Initialize enemy systems for godslayer while preserving existing functionality
-- This mirrors the stayalive-1 initialization but integrates with godslayer

print("🎮 Enemy System Initializer Starting...")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Import enemy ECS modules (with error handling)
local EntityManager
local EnemySystemManager  
local EnemyComponents

-- Check if modules exist first and list what's available
print("🔍 Checking ReplicatedStorage.Shared contents:")
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    print("   - " .. child.Name .. " (" .. child.ClassName .. ")")
end

if ReplicatedStorage.Shared:FindFirstChild("EntityManager") then
    local success, result = pcall(function()
        return require(ReplicatedStorage.Shared.EntityManager)
    end)
    if success then
        EntityManager = result
        print("✅ EntityManager loaded successfully")
    else
        error("❌ Failed to load EntityManager: " .. tostring(result))
    end
else
    error("❌ EntityManager module not found in ReplicatedStorage.Shared")
end

if ReplicatedStorage.Shared:FindFirstChild("EnemySystemManager") then
    local success, result = pcall(function()
        return require(ReplicatedStorage.Shared.EnemySystemManager)
    end)
    if success then
        EnemySystemManager = result
        print("✅ EnemySystemManager loaded successfully")
    else
        error("❌ Failed to load EnemySystemManager: " .. tostring(result))
    end
else
    error("❌ EnemySystemManager module not found in ReplicatedStorage.Shared")
end

-- Find EnemyComponents ModuleScript specifically (avoid folder conflict)
local enemyComponentsModule = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        enemyComponentsModule = child
        break
    end
end

if enemyComponentsModule then
    print("🔍 Found EnemyComponents ModuleScript:", enemyComponentsModule.Name)
    local success, result = pcall(function()
        return require(enemyComponentsModule)
    end)
    if success then
        EnemyComponents = result
        print("✅ EnemyComponents loaded successfully")
    else
        error("❌ Failed to load EnemyComponents: " .. tostring(result))
    end
else
    error("❌ EnemyComponents ModuleScript not found in ReplicatedStorage.Shared")
end

-- Import enemy systems (with error handling)
local EnemySystems = script.Parent.EnemySystems
local EnemySpawnSystem, EnemyAISystem, EnemyCombatSystem, EnemyModelSystem, EnemyChatSystem

local success, result = pcall(function()
    return require(EnemySystems.EnemySpawnSystem)
end)
if success then
    EnemySpawnSystem = result
    print("✅ EnemySpawnSystem loaded successfully")
else
    error("❌ Failed to load EnemySpawnSystem: " .. tostring(result))
end

local success, result = pcall(function()
    return require(EnemySystems.AISystem)
end)
if success then
    EnemyAISystem = result
    print("✅ EnemyAISystem loaded successfully")
else
    error("❌ Failed to load EnemyAISystem: " .. tostring(result))
end

local success, result = pcall(function()
    return require(EnemySystems.CombatSystem)
end)
if success then
    EnemyCombatSystem = result
    print("✅ EnemyCombatSystem loaded successfully")
else
    error("❌ Failed to load EnemyCombatSystem: " .. tostring(result))
end

local success, result = pcall(function()
    return require(EnemySystems.ModelCreationSystem)
end)
if success then
    EnemyModelSystem = result
    print("✅ EnemyModelSystem loaded successfully")
else
    error("❌ Failed to load EnemyModelSystem: " .. tostring(result))
end

local success, result = pcall(function()
    return require(EnemySystems.EnemyChatSystem)
end)
if success then
    EnemyChatSystem = result
    print("✅ EnemyChatSystem loaded successfully")
else
    error("❌ Failed to load EnemyChatSystem: " .. tostring(result))
end

-- Test enemy ECS core
print("📦 Enemy ECS loaded: EntityManager, EnemySystemManager, EnemyComponents")

-- Only register systems if all modules loaded successfully
if EntityManager and EnemySystemManager and EnemyComponents and 
   EnemySpawnSystem and EnemyAISystem and EnemyCombatSystem and EnemyModelSystem and EnemyChatSystem then
   
    -- Register enemy systems
    EnemySystemManager.registerSystem(EnemySpawnSystem)
    EnemySystemManager.registerSystem(EnemyAISystem)
    EnemySystemManager.registerSystem(EnemyCombatSystem)
    EnemySystemManager.registerSystem(EnemyModelSystem)
    EnemySystemManager.registerSystem(EnemyChatSystem)

    -- Start enemy system game loop
    EnemySystemManager.startGameLoop()
    
    print("✅ All enemy systems registered and started")
else
    warn("❌ Some enemy systems failed to load - enemy system disabled")
    return {initialized = false, error = "Failed to load enemy modules"}
end

print("✅ Enemy System initialization complete")
print("🔧 Enemy ECS Status: Custom Enemy ECS Active")

-- NOTE: Spawner creation is now handled by SpawnerSetup.luau
-- This allows for visual placement of spawners in Roblox Studio using tagged parts
-- Fallback spawners will be created automatically if no tagged parts are found
print("🎯 Spawner creation delegated to SpawnerSetup system")

-- Player management for enemy spawning
Players.PlayerAdded:Connect(function(player)
    print("🎯 Player joined (enemy system):", player.Name)
    -- Enemy spawners already exist, enemies will spawn for any player to battle
end)

-- Return module data
return {
    initialized = true,
    systems = {
        EnemySpawnSystem,
        EnemyAISystem,
        EnemyCombatSystem,
        EnemyModelSystem,
        EnemyChatSystem
    }
} ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="66">
        <Properties>
          <string name="Name">EnemySystems</string>
          <string name="Source"><![CDATA[-- Systems/init.lua
-- Exports all ECS systems for the StayAlive game

local Systems = {
	AISystem = require(script.AISystem),
	CombatSystem = require(script.CombatSystem),
	EnemyChatSystem = require(script.EnemyChatSystem),
	ModelCreationSystem = require(script.ModelCreationSystem),
	EnemySpawnSystem = require(script.EnemySpawnSystem),
	VisualEffectsSystem = require(script.VisualEffectsSystem),
}

return Systems ]]></string>
        </Properties>
        <Item class="ModuleScript" referent="67">
          <Properties>
            <string name="Name">AISystem</string>
            <string name="Source"><![CDATA[--[[
AISystem.lua

Core AI State Machine System for processing entities with EnemyAI components.
Manages state transitions between idle, patrol, chase, attack, and dead states.
Pure ECS with no external system dependencies.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

-- Event for player death/respawn
local PlayerStateEvent = Instance.new("BindableEvent")
PlayerStateEvent.Name = "PlayerStateEvent"
PlayerStateEvent.Parent = ReplicatedStorage

-- Listen for Dead tag changes on all players
local function onPlayerAdded(player)
    CollectionService:GetInstanceAddedSignal("Dead"):Connect(function(inst)
        if inst == player then
            PlayerStateEvent:Fire("Dead", player)
        end
    end)
    CollectionService:GetInstanceRemovedSignal("Dead"):Connect(function(inst)
        if inst == player then
            PlayerStateEvent:Fire("Alive", player)
        end
    end)
end
for _, player in ipairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)

-- Import custom ECS modules
local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Import Components from our custom ECS (find ModuleScript specifically to avoid folder conflict)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("AISystem: Could not find EnemyComponents ModuleScript")
end

-- Import modular chase handlers
local MeleeChaseHandler = require(script.Parent.MeleeChaseHandler)
local RangedChaseHandler = require(script.Parent.RangedChaseHandler)
local SpecialChaseHandler = require(script.Parent.SpecialChaseHandler)

local AISystem = {}
AISystem.name = "AISystem"

-- Configuration
local CONFIG = {
	UPDATE_INTERVAL_IDLE = 1/8, -- 8 FPS for idle/patrol states (increased from 6 FPS)
	UPDATE_INTERVAL_CHASE = 1/20, -- 20 FPS for chase/attack states (increased from 15 FPS for smoother movement)
	PLAYER_UPDATE_INTERVAL = 0.05, -- Update player positions every 0.05 seconds (increased from 0.1)
	MAX_ENTITIES_PER_FRAME = 12,
	MAX_AI_DISTANCE = 150, -- Only process AI within this distance of players
	
	-- AI ranges
	DETECTION_RANGE = 30,
	ATTACK_RANGE = 5,
	CHASE_TIMEOUT = 10, -- Give up chase after this many seconds
	PLAYER_MOVE_THRESHOLD = 2, -- Only call MoveTo if player moved >2 studs (reduced from 5 for smoother following)
	STUCK_TIMEOUT = 2, -- Force new MoveTo if no movement for 2 seconds (reduced from 3 for more responsive unstuck)
	
	-- State timeouts
	IDLE_MIN_TIME = 2,
	IDLE_MAX_TIME = 6,
	PATROL_TIME = 3
}

-- System state
local lastUpdate = 0
local playerPositions = {}
local lastPlayerScan = 0
local entityLastPlayerPositions = {} -- Track last known player position per entity

-- AI States
local AI_STATES = {
	IDLE = "idle",
	PATROL = "patrol", 
	CHASE = "chase",  -- Now handles both chasing and attacking
	DEAD = "dead"
}

-- Initialize system
function AISystem.initialize()
	lastUpdate = 0
	playerPositions = {}
	lastPlayerScan = 0
	return true
end

-- Main update function
function AISystem.update(deltaTime)
	local currentTime = tick()
	
	-- Update player positions periodically
	if currentTime - lastPlayerScan > CONFIG.PLAYER_UPDATE_INTERVAL then
		AISystem._updatePlayerPositions()
		lastPlayerScan = currentTime
	end
	
	local entitiesProcessed = 0
	
	-- Get all entities with EnemyAI and Model components (enemies use Humanoid.Health directly)
	local aiEntities = EntityManager.getEntitiesWithAll({"EnemyAI", "Model"})

	for _, entityId in ipairs(aiEntities) do
		if entitiesProcessed >= CONFIG.MAX_ENTITIES_PER_FRAME then
			break
		end
		
		local enemyAI = EntityManager.getComponent(entityId, "EnemyAI")
		local model = EntityManager.getComponent(entityId, "Model")
		
		if not enemyAI or not model or not model.part then
			-- Skip this entity
		else
			-- Get position directly from the model
			local currentPosition = model.part.Position
			
			-- Skip if too far from players
			if not AISystem._isNearPlayer(currentPosition) then
				-- Skip this entity
			elseif model.humanoid and model.humanoid.Health <= 0 then
				-- Skip if dead (check Humanoid.Health directly)
				AISystem._setState(entityId, enemyAI, AI_STATES.DEAD)
			else
				-- Check if we should update this entity based on its state
				local shouldUpdate = AISystem._shouldUpdateEntity(entityId, enemyAI, currentTime)
				if shouldUpdate then
					AISystem._updateEntityAI(entityId, enemyAI, model, currentTime)
					entitiesProcessed = entitiesProcessed + 1
				end
			end
		end
	end
end

-- Update AI for a single entity
function AISystem._updateEntityAI(entityId, enemyAI, model, currentTime)
	-- Update the last update time
	enemyAI.lastUpdateTime = currentTime
	
	local currentState = enemyAI.state or AI_STATES.IDLE
	local currentPosition = model.part.Position
	local closestPlayer, distance = AISystem._findClosestPlayer(currentPosition)
	-- Early exit if closestPlayer is dead or invalid
	if closestPlayer and CollectionService:HasTag(closestPlayer.player, "Dead") then
		enemyAI.target = nil
		AISystem._setState(entityId, enemyAI, AI_STATES.IDLE)
		EntityManager.addComponent(entityId, "EnemyAI", enemyAI)
		return
	end
	
	-- State machine
	if currentState == AI_STATES.IDLE then
		AISystem._handleIdleState(entityId, enemyAI, model, closestPlayer, distance, currentTime)
		
	elseif currentState == AI_STATES.PATROL then
		AISystem._handlePatrolState(entityId, enemyAI, model, closestPlayer, distance, currentTime)
		
	elseif currentState == AI_STATES.CHASE then
		-- Use appropriate chase handler based on enemy type
		local result = AISystem._handleChaseWithModularHandlers(entityId, enemyAI, model, closestPlayer, distance, currentTime)
		
	elseif currentState == AI_STATES.DEAD then
		-- Dead entities don't do anything
		return
	end
	
	-- Save the updated AI component
	EntityManager.addComponent(entityId, "EnemyAI", enemyAI)
end

-- Listen for player death/respawn events to clear targets
PlayerStateEvent.Event:Connect(function(state, player)
    print("[PlayerStateEvent] Fired for state:", state, "player:", player and player.Name or tostring(player))
    for _, entityId in ipairs(EntityManager.getEntitiesWith("EnemyAI")) do
        local enemyAI = EntityManager.getComponent(entityId, "EnemyAI")
        print("[PlayerStateEvent] Entity", entityId, "current target:", enemyAI and enemyAI.target and enemyAI.target.Name or tostring(enemyAI and enemyAI.target))
        if enemyAI and enemyAI.target == player then
            print("[PlayerStateEvent] Affecting entity", entityId, "(target matched)")
            if state == "Dead" then
                enemyAI.target = nil
                AISystem._setState(entityId, enemyAI, AI_STATES.PATROL)
                -- Immediately assign a random patrol target (same as idle->patrol)
                local model = EntityManager.getComponent(entityId, "Model")
                if model and model.part then
                    AISystem._setRandomPatrolTarget(entityId, model.part.Position)
                end
            elseif state == "Alive" then
                -- Optionally, force reacquire target
                -- enemyAI.target = nil
            end
            EntityManager.addComponent(entityId, "EnemyAI", enemyAI)
        end
    end
end)

-- Handle idle state
function AISystem._handleIdleState(entityId, enemyAI, model, closestPlayer, distance, currentTime)
	-- Use per-enemy detection range, fallback to config
	local detectionRange = enemyAI.detectionRange or CONFIG.DETECTION_RANGE
	-- Check for player
	if closestPlayer and distance <= detectionRange then
		AISystem._setState(entityId, enemyAI, AI_STATES.CHASE)
		enemyAI.target = closestPlayer.player
		print("[AI] Entity", entityId, "set target to", closestPlayer.player.Name)
		EntityManager.addComponent(entityId, "EnemyAI", enemyAI)
		return
	end
	-- Transition to patrol after random time
	local stateTime = currentTime - (enemyAI.stateStartTime or currentTime)
	local idleTime = math.random(CONFIG.IDLE_MIN_TIME, CONFIG.IDLE_MAX_TIME)
	if stateTime >= idleTime then
		AISystem._setState(entityId, enemyAI, AI_STATES.PATROL)
		AISystem._setRandomPatrolTarget(entityId, model.part.Position)
		enemyAI.target = nil
		print("[AI] Entity", entityId, "cleared target (idle->patrol)")
		EntityManager.addComponent(entityId, "EnemyAI", enemyAI)
	end
end

-- Handle patrol state
function AISystem._handlePatrolState(entityId, enemyAI, model, closestPlayer, distance, currentTime)
	-- Use per-enemy detection range, fallback to config
	local detectionRange = enemyAI.detectionRange or CONFIG.DETECTION_RANGE
	-- Check for player
	if closestPlayer and distance <= detectionRange then
		AISystem._setState(entityId, enemyAI, AI_STATES.CHASE)
		enemyAI.target = closestPlayer.player
		print("[AI] Entity", entityId, "set target to", closestPlayer.player.Name)
		EntityManager.addComponent(entityId, "EnemyAI", enemyAI)
		return
	end
	-- Return to idle after patrol time
	local stateTime = currentTime - (enemyAI.stateStartTime or currentTime)
	if stateTime >= CONFIG.PATROL_TIME then
		AISystem._setState(entityId, enemyAI, AI_STATES.IDLE)
		enemyAI.target = nil
		print("[AI] Entity", entityId, "cleared target (patrol->idle)")
		EntityManager.addComponent(entityId, "EnemyAI", enemyAI)
	end
end

-- Handle chase state using modular chase handlers
function AISystem._handleChaseWithModularHandlers(entityId, enemyAI, model, closestPlayer, distance, currentTime)
	-- Get enemy type to determine which handler to use
	local enemyType = EntityManager.getComponent(entityId, "EnemyType")
	if not enemyType then
		warn("No EnemyType component found for entity", entityId, "- defaulting to melee behavior")
		enemyType = {enemyType = "melee"}
	end
	
	local result = "chase"  -- Default to continue chasing
	
	-- Route to appropriate chase handler based on enemy type
	if enemyType.enemyType == "melee" then
		result = MeleeChaseHandler.handleChase(entityId, enemyAI, model, closestPlayer, distance, currentTime, entityLastPlayerPositions, CONFIG)
	elseif enemyType.enemyType == "ranged" then
		result = RangedChaseHandler.handleChase(entityId, enemyAI, model, closestPlayer, distance, currentTime, entityLastPlayerPositions, CONFIG)
	elseif enemyType.enemyType == "special" then
		result = SpecialChaseHandler.handleChase(entityId, enemyAI, model, closestPlayer, distance, currentTime, entityLastPlayerPositions, CONFIG)
	else
		warn("Unknown enemy type:", enemyType.enemyType, "for entity", entityId, "- using melee handler")
		result = MeleeChaseHandler.handleChase(entityId, enemyAI, model, closestPlayer, distance, currentTime, entityLastPlayerPositions, CONFIG)
	end
	
	-- Handle state transitions returned by chase handlers
	if result == "idle" then
		AISystem._setState(entityId, enemyAI, AI_STATES.IDLE)
	elseif result == "patrol" then
		AISystem._setState(entityId, enemyAI, AI_STATES.PATROL)
	-- If result is "chase", stay in chase state
	end
end

-- NOTE: Attack handling functions moved to individual chase handlers for modularity

-- Set AI state
function AISystem._setState(entityId, enemyAI, newState)
	if enemyAI.state ~= newState then
		enemyAI.state = newState
		enemyAI.stateStartTime = tick()
		
		-- Clean up tracking when leaving chase state
		if enemyAI.state ~= AI_STATES.CHASE and entityLastPlayerPositions[entityId] then
			entityLastPlayerPositions[entityId] = nil
		end
		
		-- Play appropriate animation for the new state
		AISystem._playAnimationForState(entityId, newState)
		
		EntityManager.addComponent(entityId, "EnemyAI", enemyAI)
	end
end

-- Play appropriate animation for AI state (respects movement detection priority)
function AISystem._playAnimationForState(entityId, state)
	local animationSet = EntityManager.getComponent(entityId, "AnimationSet")
	if not animationSet then
		return -- No animations loaded for this entity
	end
	
	-- Priority system: Attack > Movement Detection > State-based
	-- Movement detection only controls walk animations, AI controls everything else
	
	-- Note: Attack animations are now handled as overlays in the new system
	-- This section is no longer needed since attacks happen during chase state
		
	if state == AI_STATES.DEAD then
		-- Dead state: stop all animations
		if animationSet.current then
			animationSet.current:Stop()
			animationSet.current = nil
		end
		animationSet.animationSource = "state"
		print("🎭 Entity", entityId, "stopped all animations (dead)")
		
	else
		-- For IDLE, PATROL, CHASE states: play appropriate animations
		-- Don't override movement-driven walk animations, but do play idle/other states
		
		if animationSet.animationSource == "movement" then
			-- Movement detection is controlling - don't override walk animations
			return
		end
		
		-- Play state-based animations
		if animationSet.current then
			animationSet.current:Stop()
			animationSet.current = nil
		end
		
		local newAnimation = nil
		if state == AI_STATES.IDLE and animationSet.idle then
			newAnimation = animationSet.idle
		elseif (state == AI_STATES.PATROL or state == AI_STATES.CHASE) and animationSet.walk then
			newAnimation = animationSet.walk
		end
		
		if newAnimation then
			newAnimation:Play()
			animationSet.current = newAnimation
			animationSet.animationSource = "state"
			print("🎭 Entity", entityId, "playing", state, "animation (state-driven)")
		end
	end
	
	-- Save updated animation state
	EntityManager.addComponent(entityId, "AnimationSet", animationSet)
end

-- Move enemy to player using Roblox's built-in movement
function AISystem._moveToPlayer(entityId, playerData)
	local model = EntityManager.getComponent(entityId, "Model")
	if not model or not model.humanoid or not model.humanoid.Parent then
		return
	end
	
	-- Use Roblox's MoveTo with the actual player part for real-time following
	if playerData.player.Character and playerData.player.Character:FindFirstChild("HumanoidRootPart") then
		model.humanoid:MoveTo(playerData.player.Character.HumanoidRootPart.Position)
		-- REMOVED: Position component sync - we get position directly from model now
	end
end

-- Move enemy to player with zone-based speed adjustment (princess-like movement)
function AISystem._moveToPlayerWithZones(entityId, playerData, currentDistance, slowZoneDistance)
	local model = EntityManager.getComponent(entityId, "Model")
	if not model or not model.humanoid or not model.humanoid.Parent then
		return
	end
	
	-- Use Roblox's MoveTo with the actual player part for real-time following
	if playerData.player.Character and playerData.player.Character:FindFirstChild("HumanoidRootPart") then
		local humanoid = model.humanoid
		local targetPosition = playerData.player.Character.HumanoidRootPart.Position
		
		-- Zone-based speed adjustment for smoother movement
		-- Get base speed from EnemyAI component, fallback to current humanoid speed
		local enemyAI = EntityManager.getComponent(entityId, "EnemyAI")
		local baseSpeed = (enemyAI and enemyAI.speed) or humanoid.WalkSpeed or 16
		local newSpeed = baseSpeed
		
		if currentDistance <= slowZoneDistance then
			-- In slow zone: reduce speed for smoother approach
			local slowFactor = math.max(0.4, currentDistance / slowZoneDistance) -- 40% to 100% speed
			newSpeed = baseSpeed * slowFactor
			print("🐌 Entity", entityId, "in slow zone - speed:", math.floor(newSpeed))
		end
		
		-- Apply speed adjustment
		humanoid.WalkSpeed = newSpeed
		
		-- Move to target
		humanoid:MoveTo(targetPosition)
		
		print("🎯 Entity", entityId, "moving to player at speed", newSpeed, "distance:", math.floor(currentDistance))
	end
end

-- Set random patrol target (constrained to home position radius)
function AISystem._setRandomPatrolTarget(entityId, currentPos)
	local model = EntityManager.getComponent(entityId, "Model")
	local enemyAI = EntityManager.getComponent(entityId, "EnemyAI")
	if not model or not model.humanoid or not model.humanoid.Parent or not enemyAI then
		return
	end
	
	-- Get home position (spawner location) and patrol radius
	local homePosition = enemyAI.homePosition or currentPos
	local patrolRadius = enemyAI.patrolRadius or 30 -- Default 30 studs from spawner
	
	-- Generate random patrol target within patrol radius of home position
	local angle = math.random() * 2 * math.pi
	local distance = math.random(5, patrolRadius) -- Random distance within patrol radius
	local targetPos = homePosition + Vector3.new(
		math.cos(angle) * distance,
		0,
		math.sin(angle) * distance
	)
	
	model.humanoid:MoveTo(targetPos)
	
	print("🚶 Entity", entityId, "patrolling to", tostring(targetPos), "within", patrolRadius, "studs of home", tostring(homePosition))
end

-- Update player positions
function AISystem._updatePlayerPositions()
	playerPositions = {}
	
	for _, player in pairs(Players:GetPlayers()) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			table.insert(playerPositions, {
				player = player,
				position = player.Character.HumanoidRootPart.Position,
				entity = player.Character
			})
		end
	end
end

-- Find closest player to position
function AISystem._findClosestPlayer(position)
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, playerData in ipairs(playerPositions) do
        local player = playerData.player
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if not CollectionService:HasTag(player, "Dead") then
                local distance = (position - playerData.position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = playerData
                end
            end
        end
    end

    return closestPlayer, closestDistance
end

-- Check if position is near any player
function AISystem._isNearPlayer(position)
    for _, playerData in ipairs(playerPositions) do
        local player = playerData.player
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if not CollectionService:HasTag(player, "Dead") then
                if (position - playerData.position).Magnitude <= CONFIG.MAX_AI_DISTANCE then
                    return true
                end
            end
        end
    end
    return false
end

-- Clean up tracking data when entity is destroyed
function AISystem.cleanup(entityId)
	entityLastPlayerPositions[entityId] = nil
end

-- Determine if entity should be updated based on state and timing
function AISystem._shouldUpdateEntity(entityId, enemyAI, currentTime)
	local state = enemyAI.state or AI_STATES.IDLE
	local lastUpdateTime = enemyAI.lastUpdateTime or 0
	
	-- Use different update intervals based on state
	local updateInterval
	if state == AI_STATES.CHASE then
		updateInterval = CONFIG.UPDATE_INTERVAL_CHASE -- 20 FPS for active states (chase now includes attacking)
	else
		updateInterval = CONFIG.UPDATE_INTERVAL_IDLE -- 8 FPS for passive states
	end
	
	return (currentTime - lastUpdateTime) >= updateInterval
end

return AISystem
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="68">
          <Properties>
            <string name="Name">CombatSystem</string>
            <string name="Source"><![CDATA[--[[
CombatSystem.lua

Core Combat System for processing combat interactions between entities.
Handles damage calculation, application, and basic visual effects.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

-- Import custom ECS modules
local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Import Components from our custom ECS (find ModuleScript specifically to avoid folder conflict)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("CombatSystem: Could not find EnemyComponents ModuleScript")
end

local CombatSystem = {}
CombatSystem.name = "CombatSystem"

-- Configuration
local CONFIG = {
	UPDATE_INTERVAL = 1/8, -- 8 FPS updates (much slower for performance)
	MAX_COMBATS_PER_FRAME = 8,
	
	-- Combat settings
	ATTACK_COOLDOWN = 1.5, -- Seconds between attacks
	INVINCIBILITY_TIME = 0.3, -- Invincibility after taking damage
	MAX_COMBAT_DISTANCE = 8, -- Max distance for melee attacks
	
	-- Visual effects
	DAMAGE_TEXT_LIFETIME = 2,
	HIT_EFFECT_DURATION = 0.5
}

-- System state
local lastUpdate = 0
local invincibilityTimers = {} -- [entityId] = endTime

-- Initialize system
function CombatSystem.initialize()
	print("⚔️ CombatSystem initializing...")
	
	lastUpdate = 0
	invincibilityTimers = {}
	
	print("✅ CombatSystem ready")
	return true
end

-- Main update function
function CombatSystem.update(deltaTime)
	local currentTime = tick()
	if currentTime - lastUpdate < CONFIG.UPDATE_INTERVAL then
		return
	end
	lastUpdate = currentTime
	
	-- Clean up expired invincibility timers
	for entityId, endTime in pairs(invincibilityTimers) do
		if currentTime >= endTime then
			invincibilityTimers[entityId] = nil
		end
	end
	
	local combatsProcessed = 0
	
	-- Get all entities with Combat and Model components (removed Position dependency)
	-- Note: Melee enemies are skipped in _processCombat to avoid duplicate damage
	local combatEntities = EntityManager.getEntitiesWithAll({"Combat", "Model"})
	
	for _, entityId in ipairs(combatEntities) do
		if combatsProcessed >= CONFIG.MAX_COMBATS_PER_FRAME then
			break
		end
		
		local combat = EntityManager.getComponent(entityId, "Combat")
		local model = EntityManager.getComponent(entityId, "Model")
		
		if combat and model and model.part then
			CombatSystem._processCombat(entityId, combat, model, currentTime)
			combatsProcessed = combatsProcessed + 1
		end
	end
	
	-- Process health regeneration (simple)
	CombatSystem._processHealthRegen(currentTime)
	
	-- Perform maintenance every 60 seconds
	if currentTime % 60 < CONFIG.UPDATE_INTERVAL then
		CombatSystem.performMaintenance()
	end
	
	-- Remove dead entities
	CombatSystem._removeDeadEntities()
end

-- Process a single combat interaction
function CombatSystem._processCombat(attackerEntityId, combat, attackerModel, currentTime)
	-- Skip melee enemies - they are handled by MeleeChaseHandler
	local enemyType = EntityManager.getComponent(attackerEntityId, "EnemyType")
	if enemyType and enemyType.enemyType == "melee" then
		-- Melee enemies are handled by MeleeChaseHandler, so we skip them here
		-- to avoid duplicate damage application
		return
	end
	
	-- Check attack cooldown (use per-enemy cooldown, fallback to global config)
	local attackCooldown = combat.attackCooldown or CONFIG.ATTACK_COOLDOWN
	if combat.lastAttackTime and (currentTime - combat.lastAttackTime) < attackCooldown then
		-- Debug: Show when attacks are blocked by cooldown
		local timeRemaining = attackCooldown - (currentTime - combat.lastAttackTime)
		if math.random() < 0.05 then -- Only print 5% of the time to avoid spam
			print("⏰ Entity", attackerEntityId, "attack on cooldown -", string.format("%.1f", timeRemaining), "seconds remaining")
		end
		return
	end
	
	print("🗡️ Entity", attackerEntityId, "ATTEMPTING ATTACK on target", combat.target)
	
	-- Get target entity
	local target = combat.target
	if not target then
		-- No target, remove combat component
		EntityManager.removeComponent(attackerEntityId, "Combat")
		return
	end
	
	-- Check if target is a player (has Character) or an entity (has Health component)
	local targetHealth = EntityManager.getComponent(target, "Health")
	local targetModel = EntityManager.getComponent(target, "Model")
	local isPlayer = false
	local playerHealth = nil
	
	-- Handle player targets - target is always a Character model from AISystem
	if not targetHealth then
		-- Target should be a Character model (has Humanoid directly)
		local humanoid = target:FindFirstChildOfClass("Humanoid")
		if humanoid then
			isPlayer = true
			playerHealth = {current = humanoid.Health, max = humanoid.MaxHealth}
			targetModel = {part = target:FindFirstChild("HumanoidRootPart")}
			print("🎯 Player target detected - Character:", target.Name, "Health:", humanoid.Health)
			-- Check if player has Dead tag, if so, remove Combat and skip
			local player = game.Players:GetPlayerFromCharacter(target)
			if player then
				local CollectionService = game:GetService("CollectionService")
				print("[CombatSystem] Checking Dead tag for player:", player.Name, CollectionService:HasTag(player, "Dead"))
				if CollectionService:HasTag(player, "Dead") then
					print("[CombatSystem] Target player is dead, removing Combat for entity", attackerEntityId)
					EntityManager.removeComponent(attackerEntityId, "Combat")
					return
				end
			end
		else
			-- Not a valid player target
			print("⚠️ Invalid player target (no humanoid), removing Combat for entity", attackerEntityId)
			EntityManager.removeComponent(attackerEntityId, "Combat")
			return
		end
	end
	
	-- More lenient validation - don't remove combat component as aggressively
	if not isPlayer and not targetHealth then
		-- For entity targets, only remove if entity no longer exists
		print("⚠️ Entity target lost Health component, removing Combat for entity", attackerEntityId)
		EntityManager.removeComponent(attackerEntityId, "Combat")
		return
	end
	
	if not targetModel or not targetModel.part then
		-- Target lost model/part, but don't remove combat immediately for players
		if isPlayer then
			print("⏳ Player target has no model/part yet, keeping Combat component")
			return
		else
			print("❌ Entity target lost model/part, removing Combat for entity", attackerEntityId)
			EntityManager.removeComponent(attackerEntityId, "Combat")
			return
		end
	end
	
	-- Use appropriate health values
	local healthToCheck = isPlayer and playerHealth or targetHealth
	
	-- Check distance using model positions
	local attackerPosition = attackerModel.part.Position
	local targetPosition = targetModel.part.Position
	local distance = (attackerPosition - targetPosition).Magnitude
	
	-- Use per-enemy attack range if available, fallback to config
	local maxAttackDistance = combat.attackRange or CONFIG.MAX_COMBAT_DISTANCE
	
	if distance > maxAttackDistance then
		print("❌ Entity", attackerEntityId, "TOO FAR to attack:", math.floor(distance), "vs max", maxAttackDistance)
		return -- Too far to attack
	end
	
	print("✅ Entity", attackerEntityId, "WITHIN RANGE to attack - distance:", math.floor(distance))
	
	-- Check invincibility
	if invincibilityTimers[target] and currentTime < invincibilityTimers[target] then
		return -- Target is invincible
	end
	
	-- Apply damage to target
	local damage = combat.damage or 10
	
	if isPlayer then
		-- Apply damage to player using DamageSystem
		local humanoid = target:FindFirstChildOfClass("Humanoid")
		if humanoid then
			-- Import DamageSystem here to avoid circular dependencies
			local DamageSystem = require(script.Parent.Parent.Systems.DamageSystem)
			DamageSystem:ApplyDamage(humanoid, damage, nil, "EnemyMeleeAttack")
		end
	else
		-- Apply damage to enemy using Humanoid.Health directly
		local humanoid = target:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.Health = math.max(0, humanoid.Health - damage)
		end
	end
	
	print("🎯 ATTACK EXECUTED! Entity", attackerEntityId, "attacked", target.Name, "(damage:", damage, ")")
	
	-- Set invincibility
	invincibilityTimers[target] = currentTime + CONFIG.INVINCIBILITY_TIME
	
	-- Update attack time
	combat.lastAttackTime = currentTime
	EntityManager.addComponent(attackerEntityId, "Combat", combat)
	
	-- Create visual effects
	CombatSystem._createDamageEffect(targetPosition, damage)
	CombatSystem._createHitEffect(targetModel)
	
	-- Check if target died
	if isPlayer then
		local humanoid = target:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.Health <= 0 then
			print("💀 Player", target.Name, "defeated by entity", attackerEntityId)
		end
	else
		-- For enemies, let the Humanoid.Died event handle death/ragdoll
		local humanoid = target:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.Health <= 0 then
			print("💀 Enemy", target.Name, "defeated by entity", attackerEntityId)
			-- Let ModelCreationSystem handle ragdoll via Humanoid.Died event
		end
	end
end

-- Simple health regeneration (removed for enemies - they use Humanoid.Health)
function CombatSystem._processHealthRegen(currentTime)
	-- Health regeneration removed for enemies
	-- Enemies now use Humanoid.Health directly, no custom Health component needed
end

-- Remove dead entities (only for players now, enemies handled by Humanoid.Died)
function CombatSystem._removeDeadEntities()
	-- This function is now only for cleanup, not entity removal
	-- Enemies are handled by ModelCreationSystem ragdoll system
	-- Players are handled by PlayerRagdollSystem
end

-- Clean up when entity is destroyed (called by external systems)
function CombatSystem.cleanup(entityId)
	invincibilityTimers[entityId] = nil
end

-- Perform maintenance to prevent memory leaks
function CombatSystem.performMaintenance()
	local currentTime = tick()
	
	-- Limit invincibility timers table size
	local timerCount = 0
	for _ in pairs(invincibilityTimers) do
		timerCount = timerCount + 1
	end
	
	if timerCount > 200 then -- Max 200 invincibility timers
		-- Remove expired timers more aggressively
		for entityId, endTime in pairs(invincibilityTimers) do
			if currentTime >= endTime then
				invincibilityTimers[entityId] = nil
			end
		end
	end
end

-- Create floating damage text
function CombatSystem._createDamageEffect(position, damage)
	local gui = Instance.new("BillboardGui")
	gui.Size = UDim2.new(2, 0, 1, 0)
	gui.Adornee = nil
	gui.StudsOffset = Vector3.new(0, 3, 0)
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "-" .. tostring(damage)
	label.TextColor3 = Color3.new(1, 0.2, 0.2)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.Parent = gui
	
	-- Create a part to attach the GUI to
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.1, 0.1, 0.1)
	part.Position = position
	part.Anchored = true
	part.CanCollide = false
	part.Transparency = 1
	part.Parent = workspace
	
	gui.Adornee = part
	gui.Parent = workspace
	
	-- Animate
	local tween = TweenService:Create(part, 
		TweenInfo.new(CONFIG.DAMAGE_TEXT_LIFETIME, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
		{Position = position + Vector3.new(0, 8, 0)}
	)
	
	local fadeTween = TweenService:Create(label,
		TweenInfo.new(CONFIG.DAMAGE_TEXT_LIFETIME, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
		{TextTransparency = 1}
	)
	
	tween:Play()
	fadeTween:Play()
	
	-- Clean up
	Debris:AddItem(gui, CONFIG.DAMAGE_TEXT_LIFETIME)
	Debris:AddItem(part, CONFIG.DAMAGE_TEXT_LIFETIME)
end

-- Create hit effect on model
function CombatSystem._createHitEffect(model)
	if not model or not model.part then
		return
	end
	
	-- Flash red
	local originalColor = model.part.Color
	model.part.Color = Color3.new(1, 0.3, 0.3)
	
	-- Restore color after brief flash
	spawn(function()
		wait(CONFIG.HIT_EFFECT_DURATION)
		if model.part and model.part.Parent then
			model.part.Color = originalColor
		end
	end)
end

-- Create death effect
function CombatSystem._createDeathEffect(model)
	if not model or not model.part then
		return
	end
	
	-- Fade out the model
	local tween = TweenService:Create(model.part,
		TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
		{Transparency = 1}
	)
	
	tween:Play()
end

return CombatSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="69">
          <Properties>
            <string name="Name">EnemyChatSystem</string>
            <string name="Source"><![CDATA[-- EnemyChatSystem.luau
-- Handles enemy-to-enemy chat when they're close during idle/patrol states

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Import ECS modules
local EntityManager = require(ReplicatedStorage.Shared.EntityManager)
local EnemyChatData = require(ReplicatedStorage.Shared.EnemyChatData)

-- Import Components from our custom ECS (find ModuleScript specifically to avoid folder conflict)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("EnemyChatSystem: Could not find EnemyComponents ModuleScript")
end

local EnemyChatSystem = {}
EnemyChatSystem.name = "EnemyChatSystem"

-- Configuration
local CONFIG = {
    UPDATE_INTERVAL = 2.0, -- Check for chat opportunities every 2 seconds
    MAX_CHATS_PER_FRAME = 1, -- Limit concurrent chats to prevent spam
    DEFAULT_CHAT_RANGE = 5, -- Default chat range in studs (changed from 12 to 5)
    CHAT_CHANCE = 0.3, -- 30% chance to chat when conditions are met
}

-- System state
local lastUpdate = 0

-- Initialize system
function EnemyChatSystem.initialize()
    lastUpdate = 0
    return true
end

-- Main update function
function EnemyChatSystem.update(deltaTime)
    local currentTime = tick()
    if currentTime - lastUpdate < CONFIG.UPDATE_INTERVAL then
        return
    end
    lastUpdate = currentTime
    
    local chatsTriggered = 0
    
    -- Get all entities with EnemyAI, Model, EnemyType, and EnemyChat components
    local chatEntities = EntityManager.getEntitiesWithAll({"EnemyAI", "Model", "EnemyType", "EnemyChat"})
    
    for i, entityId1 in ipairs(chatEntities) do
        if chatsTriggered >= CONFIG.MAX_CHATS_PER_FRAME then
            break
        end
        
        local enemyAI1 = EntityManager.getComponent(entityId1, "EnemyAI")
        local model1 = EntityManager.getComponent(entityId1, "Model")
        local enemyType1 = EntityManager.getComponent(entityId1, "EnemyType")
        local enemyChat1 = EntityManager.getComponent(entityId1, "EnemyChat")
        
        -- Check if this enemy can chat
        if enemyAI1 and model1 and enemyType1 and enemyChat1 and 
           model1.part and enemyChat1.canChat and
           (enemyAI1.state == "idle" or enemyAI1.state == "patrol") and
           (currentTime - enemyChat1.lastChatTime >= enemyChat1.chatCooldown) then
            
            -- Look for nearby chat partners
            for j = i + 1, #chatEntities do
                local entityId2 = chatEntities[j]
                
                local enemyAI2 = EntityManager.getComponent(entityId2, "EnemyAI")
                local model2 = EntityManager.getComponent(entityId2, "Model")
                local enemyType2 = EntityManager.getComponent(entityId2, "EnemyType")
                local enemyChat2 = EntityManager.getComponent(entityId2, "EnemyChat")
                
                -- Check if partner can chat
                if enemyAI2 and model2 and enemyType2 and enemyChat2 and 
                   model2.part and enemyChat2.canChat and
                   (enemyAI2.state == "idle" or enemyAI2.state == "patrol") and
                   (currentTime - enemyChat2.lastChatTime >= enemyChat2.chatCooldown) and
                   not EnemyChatSystem._haveChattedRecently(entityId1, entityId2, enemyChat1, enemyChat2, currentTime) then
                    
                    -- Check distance
                    local distance = (model1.part.Position - model2.part.Position).Magnitude
                    local chatRange = math.min(enemyChat1.chatRange or CONFIG.DEFAULT_CHAT_RANGE, 
                                             enemyChat2.chatRange or CONFIG.DEFAULT_CHAT_RANGE)
                    
                    if distance <= chatRange then
                        -- Roll for chat chance
                        if math.random() <= CONFIG.CHAT_CHANCE then
                            -- Trigger chat!
                            EnemyChatSystem._triggerChat(entityId1, entityId2, enemyAI1, enemyAI2, 
                                                       enemyType1, enemyType2, enemyChat1, enemyChat2, currentTime)
                            chatsTriggered = chatsTriggered + 1
                            break -- Only one chat per entity per frame
                        end
                    end
                end
            end
        end
    end
end

-- Check if two enemies have chatted recently with each other
function EnemyChatSystem._haveChattedRecently(entityId1, entityId2, enemyChat1, enemyChat2, currentTime)
    -- Check if entity1 has chatted with entity2 recently
    local lastChatTime1 = enemyChat1.chattedWith[entityId2]
    if lastChatTime1 and (currentTime - lastChatTime1) < enemyChat1.partnerCooldown then
        return true
    end
    
    -- Check if entity2 has chatted with entity1 recently
    local lastChatTime2 = enemyChat2.chattedWith[entityId1]
    if lastChatTime2 and (currentTime - lastChatTime2) < enemyChat2.partnerCooldown then
        return true
    end
    
    return false
end

-- Trigger a chat between two enemies
function EnemyChatSystem._triggerChat(entityId1, entityId2, enemyAI1, enemyAI2, 
                                     enemyType1, enemyType2, enemyChat1, enemyChat2, currentTime)
    -- Randomly decide who speaks first
    local firstId, firstAI, firstType, firstChat
    local secondId, secondAI, secondType, secondChat
    if math.random() < 0.5 then
        firstId, firstAI, firstType, firstChat = entityId1, enemyAI1, enemyType1, enemyChat1
        secondId, secondAI, secondType, secondChat = entityId2, enemyAI2, enemyType2, enemyChat2
    else
        firstId, firstAI, firstType, firstChat = entityId2, enemyAI2, enemyType2, enemyChat2
        secondId, secondAI, secondType, secondChat = entityId1, enemyAI1, enemyType1, enemyChat1
    end

    -- Get chat phrases
    local firstPhrase = EnemyChatData:GetRandomPhrase(firstType.enemyType, firstAI.state)
    local secondPhrase = EnemyChatData:GetRandomPhrase(secondType.enemyType, secondAI.state)
    if not firstPhrase or not secondPhrase then
        return -- No appropriate phrase found
    end

    -- Get models
    local firstModel = EntityManager.getComponent(firstId, "Model")
    local secondModel = EntityManager.getComponent(secondId, "Model")
    if not firstModel or not firstModel.part or not secondModel or not secondModel.part then
        return
    end

    -- First enemy chats immediately
    EnemyChatSystem._displayChatBubble(firstModel.part, firstPhrase)
    print("💬 Enemy", firstId, "said to", secondId, ":", firstPhrase)

    -- Second enemy chats after 0.5s delay
    task.delay(0.5, function()
        EnemyChatSystem._displayChatBubble(secondModel.part, secondPhrase)
        print("💬 Enemy", secondId, "responded to", firstId, ":", secondPhrase)
    end)

    -- Update chat cooldowns and tracking for both
    firstChat.lastChatTime = currentTime
    secondChat.lastChatTime = currentTime
    firstChat.chattedWith[secondId] = currentTime
    secondChat.chattedWith[firstId] = currentTime
    EntityManager.addComponent(firstId, "EnemyChat", firstChat)
    EntityManager.addComponent(secondId, "EnemyChat", secondChat)
end

-- Display chat bubble using Roblox's built-in chat system
function EnemyChatSystem._displayChatBubble(characterPart, message)
    local ChatService = game:GetService("Chat")
    local character = characterPart.Parent
    if character then
        local Head = character:FindFirstChild("Head")
        if Head then
            ChatService:Chat(Head, message)
        end
    end
end

-- Clean up tracking data when entity is destroyed
function EnemyChatSystem.cleanup(entityId)
    -- Clean up any references to this entity in other entities' chattedWith tables
    local allChatEntities = EntityManager.getEntitiesWithAll({"EnemyChat"})
    
    for _, otherEntityId in ipairs(allChatEntities) do
        if otherEntityId ~= entityId then
            local otherChat = EntityManager.getComponent(otherEntityId, "EnemyChat")
            if otherChat and otherChat.chattedWith[entityId] then
                otherChat.chattedWith[entityId] = nil
                EntityManager.addComponent(otherEntityId, "EnemyChat", otherChat)
            end
        end
    end
end

return EnemyChatSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="70">
          <Properties>
            <string name="Name">EnemyRotationUtility</string>
            <string name="Source"><![CDATA[--[[
EnemyRotationUtility.luau

Utility module for handling enemy rotation to face targets.
Provides smooth rotation functions for different enemy types.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Import custom ECS modules
local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

local EnemyRotationUtility = {}

-- Configuration
local ROTATION_CONFIG = {
    ROTATION_SPEED = 5, -- Radians per second
    SMOOTH_ROTATION = true, -- Use tweening for smooth rotation
    ROTATION_THRESHOLD = 0.1, -- Minimum angle difference to trigger rotation
    MAX_ROTATION_DISTANCE = 50 -- Only rotate if target is within this distance
}

-- Rotate enemy to face target position
function EnemyRotationUtility.rotateToFaceTarget(entityId, targetPosition, instant)
    local model = EntityManager.getComponent(entityId, "Model")
    if not model or not model.part then
        return false
    end
    
    local enemyPosition = model.part.Position
    local distance = (enemyPosition - targetPosition).Magnitude
    
    -- Don't rotate if target is too far away
    if distance > ROTATION_CONFIG.MAX_ROTATION_DISTANCE then
        return false
    end
    
    -- Calculate the direction to face (only on X and Z axis - no Y rotation)
    local direction = (targetPosition - enemyPosition).Unit
    -- Zero out the Y component to keep enemy upright
    direction = Vector3.new(direction.X, 0, direction.Z).Unit
    local targetCFrame = CFrame.lookAt(enemyPosition, enemyPosition + direction)
    
    -- Get current rotation
    local currentCFrame = model.part.CFrame
    local currentLookVector = currentCFrame.LookVector
    local targetLookVector = targetCFrame.LookVector
    
    -- Check if rotation is needed (avoid unnecessary rotations)
    local dotProduct = currentLookVector:Dot(targetLookVector)
    local angleDifference = math.acos(math.clamp(dotProduct, -1, 1))
    
    if angleDifference < ROTATION_CONFIG.ROTATION_THRESHOLD then
        return false -- Already facing target
    end
    
    if instant then
        -- Instant rotation
        model.part.CFrame = targetCFrame
        return true
    elseif ROTATION_CONFIG.SMOOTH_ROTATION then
        -- Smooth rotation using tweening
        local tweenInfo = TweenInfo.new(
            angleDifference / ROTATION_CONFIG.ROTATION_SPEED,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.Out
        )
        
        local tween = TweenService:Create(model.part, tweenInfo, {
            CFrame = targetCFrame
        })
        
        tween:Play()
        return true
    else
        -- Direct rotation without tweening
        model.part.CFrame = targetCFrame
        return true
    end
end

-- Rotate enemy to face player during attack
function EnemyRotationUtility.rotateForAttack(entityId, playerData, instant)
    if not playerData or not playerData.player or not playerData.player.Character then
        return false
    end
    
    local humanoidRootPart = playerData.player.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        return false
    end
    
    return EnemyRotationUtility.rotateToFaceTarget(entityId, humanoidRootPart.Position, instant)
end

-- Rotate enemy to face player during chase (smoother)
function EnemyRotationUtility.rotateForChase(entityId, playerData)
    return EnemyRotationUtility.rotateForAttack(entityId, playerData, false)
end

-- Rotate enemy to face player during attack (instant for responsiveness)
function EnemyRotationUtility.rotateForAttackInstant(entityId, playerData)
    return EnemyRotationUtility.rotateForAttack(entityId, playerData, true)
end

-- Check if enemy is facing target (for debugging)
function EnemyRotationUtility.isFacingTarget(entityId, targetPosition, tolerance)
    tolerance = tolerance or 0.3 -- Default tolerance in radians
    
    local model = EntityManager.getComponent(entityId, "Model")
    if not model or not model.part then
        return false
    end
    
    local enemyPosition = model.part.Position
    local direction = (targetPosition - enemyPosition).Unit
    -- Zero out the Y component to match the rotation logic
    direction = Vector3.new(direction.X, 0, direction.Z).Unit
    local currentLookVector = model.part.CFrame.LookVector
    
    local dotProduct = currentLookVector:Dot(direction)
    local angleDifference = math.acos(math.clamp(dotProduct, -1, 1))
    
    return angleDifference <= tolerance
end

return EnemyRotationUtility ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="71">
          <Properties>
            <string name="Name">EnemySpawnSystem</string>
            <string name="Source"><![CDATA[-- src/server/systems/EnemySpawnSystem.lua
--[[
	This system queries for entities with Spawner components
	and spawns enemies based on the rules defined in the Spawner.
	Only spawns when players are within activation range.
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Import custom ECS modules
local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Import Components from our custom ECS (find ModuleScript specifically to avoid folder conflict)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("EnemySpawnSystem: Could not find EnemyComponents ModuleScript")
end

local EnemyDefinitions = require(ReplicatedStorage.Shared.EnemyDefinitions)

local EnemySpawnSystem = {}
EnemySpawnSystem.name = "EnemySpawnSystem"

-- Configuration
local CONFIG = {
	UPDATE_INTERVAL = 3.0, -- Check spawns every 3 seconds - much less frequent
	MAX_SPAWNS_PER_FRAME = 2 -- Reduce concurrent spawns for performance
}

-- System state
local lastUpdate = 0

-- Initialize system
function EnemySpawnSystem.initialize()
	lastUpdate = 0
	return true
end

-- Check if any player is within activation range of the spawner
local function isAnyPlayerNearSpawner(spawnerPosition, activationRange)
	for _, player in pairs(Players:GetPlayers()) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local playerPosition = player.Character.HumanoidRootPart.Position
			local distance = (playerPosition - spawnerPosition).Magnitude
			if distance <= activationRange then
				return true
			end
		end
	end
	return false
end

local function getRandomPositionInRadius(center, radius)
	local angle = math.random() * 2 * math.pi
	local dist = math.random() * radius
	return center + Vector3.new(dist * math.cos(angle), 0, dist * math.sin(angle))
end

function EnemySpawnSystem.update(deltaTime)
	local currentTime = tick()
	if currentTime - lastUpdate < CONFIG.UPDATE_INTERVAL then
		return
	end
	lastUpdate = currentTime
	
	local spawnsProcessed = 0
	
	-- Get all entities with Spawner components
	local spawnerEntities = EntityManager.getEntitiesWith("Spawner")
	
	-- Debug: Print spawner count every 10 seconds
	if currentTime % 10 < 3.1 then -- Will print roughly every 10 seconds due to UPDATE_INTERVAL
		print("🎯 EnemySpawnSystem: Found", #spawnerEntities, "spawners")
	end
	
	for _, entityId in ipairs(spawnerEntities) do
		if spawnsProcessed >= CONFIG.MAX_SPAWNS_PER_FRAME then
			break
		end
		
		local spawner = EntityManager.getComponent(entityId, "Spawner")
		
		if not spawner or not spawner.centerPosition then
			-- Skip this entity - no spawner or missing center position
		else
			-- CHECK: Only proceed if a player is within activation range
			local activationRange = spawner.activationRange or 60 -- Default 60 studs
			local anyPlayerNearby = isAnyPlayerNearSpawner(spawner.centerPosition, activationRange)
			
			if not anyPlayerNearby then
				-- Skip this spawner - no players nearby
			elseif spawner.spawnType == "once" and spawner.hasSpawned then
				-- Skip this spawner - one-time spawner has already activated
			elseif spawner.spawnType == "continuous" and os.clock() - spawner.lastSpawnTime < spawner.cooldown then
				-- Skip this spawner - continuous spawner still in cooldown
			else

		-- Clear out any dead entities from the spawner's list
		for i = #spawner.spawnedEntities, 1, -1 do
			local spawnedEntityId = spawner.spawnedEntities[i]
			-- Check if entity still exists (check for Model component)
			local model = EntityManager.getComponent(spawnedEntityId, "Model")
			if not model or not model.model or not model.model.Parent then
				table.remove(spawner.spawnedEntities, i)
			end
		end

		local enemiesToSpawn = math.random(spawner.countRange.min, spawner.countRange.max)
		local spawnedCount = 0

		if #spawner.spawnedEntities >= spawner.countRange.max then
			-- Skip this entity - already at max spawns
		else

		for i = 1, enemiesToSpawn do
			if #spawner.spawnedEntities >= spawner.countRange.max then
				break
			end

			local enemyId
			if #spawner.enemies == 1 and spawner.enemies[1] == "random" then
				-- Use EnemyDefinitions to get a random enemy
				enemyId = EnemyDefinitions:GetRandomEnemy()
			elseif #spawner.enemies == 1 and spawner.enemies[1]:find("_type_") then
				-- Handle type-based spawning (e.g., "melee_type_random")
				local enemyType = spawner.enemies[1]:match("(%w+)_type_")
				if enemyType then
					enemyId = EnemyDefinitions:GetRandomEnemyOfType(enemyType)
				end
			else
				-- Use specific enemy from spawner list
				local spawnChoice = spawner.enemies[math.random(#spawner.enemies)]
				-- Validate that the enemy exists in definitions
				if EnemyDefinitions:GetEnemy(spawnChoice) then
					enemyId = spawnChoice
				else
					-- Fallback to random if enemy doesn't exist
					warn("Enemy not found in definitions: " .. tostring(spawnChoice) .. ". Using random enemy.")
					enemyId = EnemyDefinitions:GetRandomEnemy()
				end
			end

			if enemyId then
				local spawnPosition = getRandomPositionInRadius(spawner.centerPosition, spawner.radius)
				
				-- Create enemy using EnemyDefinitions
				local enemyComponents = EnemyDefinitions:CreateEnemyComponents(enemyId)
				if enemyComponents then
					-- Create new entity
					local newEnemyId = EntityManager.createEntity()
					
					-- Add temporary spawn position component (ModelCreationSystem will use and remove this)
					EntityManager.addComponent(newEnemyId, "SpawnPosition", 
						{value = spawnPosition})
					
					-- Set homePosition to spawner center for patrol boundaries
					if enemyComponents.EnemyAI then
						enemyComponents.EnemyAI.homePosition = spawner.centerPosition
					end
					
					-- Add EnemyChat component for enemy chat functionality
					enemyComponents.EnemyChat = Components.create("EnemyChat")
					
					-- Add all enemy components
					print("🔧 Adding components for entity", newEnemyId, ":")
					for componentType, componentData in pairs(enemyComponents) do
						EntityManager.addComponent(newEnemyId, componentType, componentData)
						print("   ✅ Added component:", componentType)
					end
					
					table.insert(spawner.spawnedEntities, newEnemyId)
					spawnedCount = spawnedCount + 1
					
					print(string.format("🎯 Spawned %s (%s) at %s (spawner type: %s)", 
						enemyId, 
						enemyComponents.enemyType or "unknown",
						tostring(spawnPosition),
						spawner.spawnType or "unknown"))
					
					-- Debug: Print enemy stats for verification
					local enemyDef = EnemyDefinitions:GetEnemy(enemyId)
					if enemyDef and enemyDef.customConfig then
						local cfg = enemyDef.customConfig
						print(string.format("   📊 Stats: Speed=%d, Damage=%d, AttackSpeed=%.1f, DetectRange=%d", 
							cfg.moveSpeed or 16,
							cfg.damage or 10,
							cfg.attackSpeed or 1,
							cfg.detectionRange or 30))
					end
				else
					warn("Failed to create components for enemy: " .. tostring(enemyId))
				end
			end
		end

		if spawnedCount > 0 then
			-- Update spawner state based on type
			if spawner.spawnType == "once" then
				-- Mark one-time spawner as having spawned
				spawner.hasSpawned = true
				print("🎯 One-time spawner", entityId, "has completed spawning and is now inactive")
			elseif spawner.spawnType == "continuous" then
				-- Update continuous spawner's last spawn time
				spawner.lastSpawnTime = os.clock()
			end
			
			EntityManager.addComponent(entityId, "Spawner", spawner)
			spawnsProcessed = spawnsProcessed + 1
		end
		end -- Close the else block for max spawns check
		end -- Close the else block for cooldown/proximity check
		end -- Close the else block for spawner validation
	end
end

return EnemySpawnSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="72">
          <Properties>
            <string name="Name">MeleeChaseHandler</string>
            <string name="Source"><![CDATA[-- MeleeChaseHandler.luau
-- Handles chase behavior specifically for melee enemies
-- Melee enemies are aggressive and persistent, focusing on getting close to attack

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")

-- Import Components (find ModuleScript specifically)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("MeleeChaseHandler: Could not find EnemyComponents ModuleScript")
end

local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Rotation utility removed for melee enemies (only ranged enemies rotate)

local MeleeChaseHandler = {}

-- Attack tracking
local attackUpdateConnection = nil

-- Configuration specific to melee enemies
local ATTACK_DURATION = 0.2 -- Duration of moving shapecast attack
local MELEE_CONFIG = {
    STOPPING_ZONE_MULTIPLIER = 0.8,    -- Stop at 80% of attack range
    SLOW_ZONE_MULTIPLIER = 2.0,        -- Slow down at 2x attack range
    PERSISTENCE_MULTIPLIER = 1.5,      -- Chase until 1.5x detection range
    MOVE_THRESHOLD_MULTIPLIER = 0.5,   -- More responsive movement (50% of normal threshold)
    ATTACK_WHILE_MOVING = true,        -- Can attack while moving
}

-- Handle melee enemy chase behavior
function MeleeChaseHandler.handleChase(entityId, enemyAI, model, closestPlayer, distance, currentTime, entityLastPlayerPositions, CONFIG)
    -- Check if closestPlayer is dead, if so, stop targeting
    if closestPlayer and closestPlayer.player then
        local CollectionService = game:GetService("CollectionService")
        print("[MeleeChaseHandler] (handleChase) Checking Dead tag for player:", closestPlayer.player.Name, CollectionService:HasTag(closestPlayer.player, "Dead"))
        if CollectionService:HasTag(closestPlayer.player, "Dead") then
            return "idle" -- Stop targeting dead players
        end
    end
    -- Get enemy-specific ranges
    local attackRange = enemyAI.attackRange or CONFIG.ATTACK_RANGE
    local detectionRange = enemyAI.detectionRange or CONFIG.DETECTION_RANGE
    
    -- Ensure Combat component exists when chasing
    local combat = EntityManager.getComponent(entityId, "Combat")
    if not combat then
        -- Try to get config from EnemyType or EnemyAI
        local enemyType = EntityManager.getComponent(entityId, "EnemyType")
        local damage = (enemyType and enemyType.config and enemyType.config.damage) or 10
        local attackCooldown = (enemyType and enemyType.config and enemyType.config.attackSpeed) and (1 / enemyType.config.attackSpeed) or 1
        local attackRangeVal = (enemyType and enemyType.config and enemyType.config.attackRange) or attackRange or 5
        EntityManager.addComponent(entityId, "Combat", Components.create("Combat", {
            damage = damage,
            attackCooldown = attackCooldown,
            attackRange = attackRangeVal
        }))
        -- Optionally, debug print
        -- print("[Debug] Created Combat component for entity", entityId, "on chase start")
    end
    
    -- Check if we should give up chase (melee enemies are more persistent)
    if not closestPlayer then
        return "idle"  -- Lost target
    end
    
    local maxChaseDistance = detectionRange * MELEE_CONFIG.PERSISTENCE_MULTIPLIER
    if distance > maxChaseDistance then
        return "idle"  -- Target too far, give up
    end
    
    -- Check chase timeout
    local chaseTime = currentTime - (enemyAI.stateStartTime or currentTime)
    if chaseTime >= CONFIG.CHASE_TIMEOUT then
        return "idle"  -- Timeout
    end
    
    -- === ATTACK LOGIC (continuous during chase) ===
    local inAttackRange = distance <= attackRange
    if inAttackRange then
        -- Handle shapecast-based attacking while in range
        MeleeChaseHandler._handleContinuousAttack(entityId, closestPlayer, currentTime)
    end
    
    -- === MOVEMENT LOGIC (independent of attacking) ===
    -- Zone-based movement logic for smooth approach
    local STOPPING_ZONE = attackRange * MELEE_CONFIG.STOPPING_ZONE_MULTIPLIER
    local SLOW_ZONE = attackRange * MELEE_CONFIG.SLOW_ZONE_MULTIPLIER
    
    -- Continuous player tracking (melee enemies are more responsive)
    local lastKnownPlayerPos = entityLastPlayerPositions[entityId]
    local currentPlayerPos = closestPlayer.position
    local shouldUpdateMoveTo = false

    if not lastKnownPlayerPos then
        shouldUpdateMoveTo = true
    else
        local playerMovedDistance = (currentPlayerPos - lastKnownPlayerPos).Magnitude
        local moveThreshold = CONFIG.PLAYER_MOVE_THRESHOLD * MELEE_CONFIG.MOVE_THRESHOLD_MULTIPLIER
        if playerMovedDistance > moveThreshold then
            shouldUpdateMoveTo = true
        end
    end

    -- Basic stuck detection
    local lastMoveToTime = enemyAI.lastMoveToTime or 0
    if not shouldUpdateMoveTo and (currentTime - lastMoveToTime) > CONFIG.STUCK_TIMEOUT then
        shouldUpdateMoveTo = true
    end

    -- Movement behavior (happens regardless of attack state)
    if distance <= STOPPING_ZONE then
        -- Close enough - don't move closer, just attack if in range
        if inAttackRange then
            print("⚔️ Melee enemy", entityId, "in optimal attack position")
        end
    elseif shouldUpdateMoveTo then
        -- Move toward player with zone-based speed adjustment
        MeleeChaseHandler._moveToPlayerWithZones(entityId, closestPlayer, distance, SLOW_ZONE, enemyAI, CONFIG)
        entityLastPlayerPositions[entityId] = currentPlayerPos
        enemyAI.lastMoveToTime = currentTime
        
        if inAttackRange then
            print("🏃‍♂️⚔️ Melee enemy", entityId, "attacking while moving toward player")
        end
    end
    
    return "chase"  -- Continue chasing
end

-- Handle continuous attacking during chase with shapecast
function MeleeChaseHandler._handleContinuousAttack(entityId, closestPlayer, currentTime)
    local combat = EntityManager.getComponent(entityId, "Combat")
    if not combat then
        -- Create fallback combat component silently (no warning)
        local enemyAI = EntityManager.getComponent(entityId, "EnemyAI")
        local enemyType = EntityManager.getComponent(entityId, "EnemyType")
        local attackRange = (enemyType and enemyType.config and enemyType.config.attackRange) or (enemyAI and enemyAI.attackRange) or 5
        local damage = (enemyType and enemyType.config and enemyType.config.damage) or 10
        local attackCooldown = (enemyType and enemyType.config and enemyType.config.attackSpeed) and (1 / enemyType.config.attackSpeed) or 1
        EntityManager.addComponent(entityId, "Combat", Components.create("Combat", {
            target = closestPlayer.entity,
            damage = damage,
            lastAttackTime = currentTime,
            attackRange = attackRange,
            attackCooldown = attackCooldown
        }))
        -- Optionally, debug print
        -- print("[Debug] Silently created fallback Combat component for entity", entityId)
        combat = EntityManager.getComponent(entityId, "Combat")
    end
    
    -- Check attack cooldown
    local timeSinceLastAttack = currentTime - (combat.lastAttackTime or 0)
    local attackCooldown = combat.attackCooldown or 1.5
    
    if timeSinceLastAttack >= attackCooldown then
        -- Perform shapecast attack
        MeleeChaseHandler._performShapecastAttack(entityId, closestPlayer, combat, currentTime)
        
        -- Update attack time
        combat.lastAttackTime = currentTime
        EntityManager.addComponent(entityId, "Combat", combat)
    end
end

-- Start moving shapecast attack (attack animation + begin tracking)
function MeleeChaseHandler._performShapecastAttack(entityId, closestPlayer, combat, currentTime)
    local model = EntityManager.getComponent(entityId, "Model")
    if not model or not model.part then
        return
    end
    
    -- Play attack animation
    MeleeChaseHandler._playAttackAnimationOverlay(entityId, model)
    
    -- Set up attack state for moving shapecast
    combat.isAttacking = true
    combat.attackStartTime = currentTime
    combat.attackTargetPlayer = closestPlayer.player
    
    -- Start the moving shapecast update loop if not already running
    MeleeChaseHandler._ensureAttackUpdateLoop()
    
    print("⚔️ Melee enemy", entityId, "started moving shapecast attack on", closestPlayer.player.Name)
end

-- Play attack animation overlay for melee attacks
function MeleeChaseHandler._playAttackAnimationOverlay(entityId, model)
    local animationSet = EntityManager.getComponent(entityId, "AnimationSet")
    if not animationSet or not model.humanoid then
        return
    end
    
    -- Play attack animation as overlay (higher priority than movement)
    if animationSet.attack and not animationSet.attack.IsPlaying then
        animationSet.attack.Priority = Enum.AnimationPriority.Action
        animationSet.attack:Play()
        print("⚔️ Playing melee attack animation overlay for entity", entityId)
    end
end

-- Move enemy toward player with zone-based speed adjustment
function MeleeChaseHandler._moveToPlayerWithZones(entityId, playerData, currentDistance, slowZoneDistance, enemyAI, CONFIG)
    local model = EntityManager.getComponent(entityId, "Model")
    if not model or not model.humanoid or not model.humanoid.Parent then
        return
    end
    
    if playerData.player.Character and playerData.player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoid = model.humanoid
        local targetPosition = playerData.player.Character.HumanoidRootPart.Position
        
        -- Zone-based speed adjustment for smoother movement
        local baseSpeed = enemyAI.speed or humanoid.WalkSpeed or 16
        local newSpeed = baseSpeed
        
        if currentDistance <= slowZoneDistance then
            -- In slow zone: reduce speed for smoother approach
            local slowFactor = math.max(0.4, currentDistance / slowZoneDistance)
            newSpeed = baseSpeed * slowFactor
            print("🐌 Melee entity", entityId, "in slow zone - speed:", math.floor(newSpeed))
        end
        
        -- Apply speed adjustment
        humanoid.WalkSpeed = newSpeed
        
        -- Move to target
        humanoid:MoveTo(targetPosition)
        
        print("🎯 Melee entity", entityId, "moving to player at speed", newSpeed, "distance:", math.floor(currentDistance))
    end
end

-- Deal damage to player from shapecast
function MeleeChaseHandler._dealShapecastDamage(entityId, player, damage)
    if not player.Character or not player.Character:FindFirstChild("Humanoid") then
        return
    end
    -- Prevent damage to dead players
    local CollectionService = game:GetService("CollectionService")
    print("[MeleeChaseHandler] Checking Dead tag for player:", player.Name, CollectionService:HasTag(player, "Dead"))
    if CollectionService:HasTag(player, "Dead") then
        print("[MeleeChaseHandler] Player is dead, not applying shapecast damage.")
        return
    end
    -- Simple damage application (you can integrate with your existing damage system)
    local humanoid = player.Character.Humanoid
    humanoid:TakeDamage(damage)
    
    print("💥 Shapecast damage:", player.Name, "took", damage, "damage from melee enemy", entityId)
end

-- Create visual feedback for attack (for debugging)
function MeleeChaseHandler._createAttackVisual(centerPosition, size, hit)
    local visual = Instance.new("Part")
    visual.Name = "MeleeAttackVisual"
    visual.Size = size
    visual.Position = centerPosition
    visual.Anchored = true
    visual.CanCollide = false
    visual.Transparency = 0.7
    visual.Color = hit and Color3.new(0, 1, 0) or Color3.new(1, 0, 0)  -- Green for hit, red for miss
    visual.Material = Enum.Material.Neon
    visual.Parent = workspace
    
    -- Remove after short duration
    Debris:AddItem(visual, 0.2)
end

-- Ensure the attack update loop is running
function MeleeChaseHandler._ensureAttackUpdateLoop()
    if attackUpdateConnection then
        return -- Already running
    end
    
    attackUpdateConnection = RunService.Heartbeat:Connect(function()
        MeleeChaseHandler._updateActiveAttacks()
    end)
    
    print("🔄 Started melee attack update loop")
end

-- Update all active moving shapecasts
function MeleeChaseHandler._updateActiveAttacks()
    local currentTime = tick()
    local activeAttacks = 0
    
    -- Iterate through all entities with Combat components to find active attacks
    local entitiesWithCombat = EntityManager.getEntitiesWith("Combat")
    for _, entityId in ipairs(entitiesWithCombat) do
        local combat = EntityManager.getComponent(entityId, "Combat")
        
        if combat and combat.isAttacking then
            activeAttacks = activeAttacks + 1
            MeleeChaseHandler._updateSingleAttack(entityId, combat, currentTime)
        end
    end
    
    -- Stop the update loop if no active attacks
    if activeAttacks == 0 and attackUpdateConnection then
        attackUpdateConnection:Disconnect()
        attackUpdateConnection = nil
        print("🛑 Stopped melee attack update loop - no active attacks")
    end
end

-- Update a single entity's moving shapecast attack
function MeleeChaseHandler._updateSingleAttack(entityId, combat, currentTime)
    local model = EntityManager.getComponent(entityId, "Model")
    if not model or not model.part then
        -- Entity no longer exists, end attack
        combat.isAttacking = false
        return
    end
    
    -- Check if attack duration has expired
    local attackElapsed = currentTime - combat.attackStartTime
    if attackElapsed >= ATTACK_DURATION then
        -- Attack duration ended - create miss visual and end attack
        MeleeChaseHandler._endAttack(entityId, combat, false)
        return
    end
    
    -- Perform moving shapecast at current enemy position
    local enemyPosition = model.part.Position
    local enemyLookVector = model.part.CFrame.LookVector
    
    -- Shapecast configuration
    local shapecastDistance = 1.0  -- 1 stud in front (closer for more precise combat)
    local shapecastSize = Vector3.new(1.5, 1.5, 1.5)  -- 1.5x1.5x1.5 detection box
    
    -- Calculate current shapecast center position (moves with enemy)
    local shapecastCenter = enemyPosition + enemyLookVector * shapecastDistance
    
    -- Perform the shapecast using GetPartBoundsInBox
    -- Create CFrame oriented to face the same direction as the enemy
    local enemyCFrame = model.part.CFrame
    local orientedCFrame = CFrame.new(shapecastCenter, shapecastCenter + enemyCFrame.LookVector)
    local detectedParts = workspace:GetPartBoundsInBox(orientedCFrame, shapecastSize)
    
    -- Check if we hit the target player
    local targetPlayer = combat.attackTargetPlayer
    if targetPlayer and targetPlayer.Character then
        for _, part in ipairs(detectedParts) do
            -- Check if this part belongs to the target player
            if part:IsDescendantOf(targetPlayer.Character) then
                -- Hit! Deal damage and end attack
                MeleeChaseHandler._dealShapecastDamage(entityId, targetPlayer, combat.damage or 10)
                MeleeChaseHandler._endAttack(entityId, combat, true, shapecastCenter, shapecastSize)
                return
            end
        end
    end
end

-- End an attack with visual feedback
function MeleeChaseHandler._endAttack(entityId, combat, hit, centerPosition, size)
    -- Reset attack state
    combat.isAttacking = false
    combat.attackStartTime = 0
    combat.attackTargetPlayer = nil
    
    -- Create visual feedback
    if hit and centerPosition and size then
        MeleeChaseHandler._createAttackVisual(centerPosition, size, true)
        print("⚔️ Melee enemy", entityId, "HIT with moving shapecast!")
    else
        -- Miss - create visual at current position for feedback
        local model = EntityManager.getComponent(entityId, "Model")
        if model and model.part then
            local enemyPosition = model.part.Position
            local enemyLookVector = model.part.CFrame.LookVector
            local missCenter = enemyPosition + enemyLookVector * 1.0  -- Match the shapecast distance
            MeleeChaseHandler._createAttackVisual(missCenter, Vector3.new(1.5, 1.5, 1.5), false)
        end
        print("⚔️ Melee enemy", entityId, "MISSED with moving shapecast")
    end
    
    -- Update the combat component
    EntityManager.addComponent(entityId, "Combat", combat)
end

return MeleeChaseHandler ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="73">
          <Properties>
            <string name="Name">ModelCreationSystem</string>
            <string name="Source"><![CDATA[-- ModelCreationSystem.lua
-- ECS System for creating and managing 3D models for spawned entities
-- Simplified version focused on enemy model creation

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Import custom ECS modules
local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Import Components from our custom ECS (find ModuleScript specifically to avoid folder conflict)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("ModelCreationSystem: Could not find EnemyComponents ModuleScript")
end

local PrefabLibrary = require(ReplicatedStorage.Shared.PrefabLibrary)
local PhysicsService = game:GetService("PhysicsService")

local ModelCreationSystem = {}
ModelCreationSystem.name = "ModelCreationSystem"

-- Configuration
local CONFIG = {
	UPDATE_INTERVAL = 0.5, -- seconds between model updates
	MAX_MODELS_PER_FRAME = 10, -- limit model creation to maintain performance
	MODEL_PARENT_NAME = "GameEntities", -- workspace folder for all entity models
}

-- System state
local lastUpdate = 0
local modelParent = nil

-- Animation state storage by model (like princess system)
local enemyAnimations = {} -- {[model] = {animState}}

-- Initialize system
function ModelCreationSystem.initialize()
	print("🎨 ModelCreationSystem: Initializing...")
	
	-- Create model parent folder in workspace
	modelParent = Workspace:FindFirstChild(CONFIG.MODEL_PARENT_NAME)
	if not modelParent then
		modelParent = Instance.new("Folder")
		modelParent.Name = CONFIG.MODEL_PARENT_NAME
		modelParent.Parent = Workspace
	end
	
	-- Clear animation state on restart
	enemyAnimations = {}
	
	print("✅ ModelCreationSystem: Initialized successfully")
	return true
end

-- Main update function
function ModelCreationSystem.update(deltaTime)
	local currentTime = tick()
	if currentTime - lastUpdate < CONFIG.UPDATE_INTERVAL then
		return
	end
	lastUpdate = currentTime
	
	local modelsProcessed = 0
	
	-- Find entities that need models created (enemies use Humanoid.Health directly)
	local enemyEntities = EntityManager.getEntitiesWithAll({"EnemyType"})
	
	for _, entityId in ipairs(enemyEntities) do
		if modelsProcessed >= CONFIG.MAX_MODELS_PER_FRAME then
			break
		end
		
		-- Skip if entity already has a model
		local existingModel = EntityManager.getComponent(entityId, "Model")
		if existingModel then
			-- Model already exists, skip
		else
			-- Create model for this entity
			ModelCreationSystem._createModelForEntity(entityId)
			modelsProcessed = modelsProcessed + 1
		end
	end
	
	-- REMOVED: _updateModelPositions() - Let Roblox MoveTo handle positioning!
	-- ModelCreationSystem should only CREATE models, not continuously move them
end

-- Create a 3D model for an entity
function ModelCreationSystem._createModelForEntity(entityId)
	local enemyType = EntityManager.getComponent(entityId, "EnemyType")
	
	if not enemyType then
		error("ModelCreationSystem: Entity " .. entityId .. " missing EnemyType component")
		return
	end
	
	-- Get the specific model name from EnemyDefinitions
	local modelName = ModelCreationSystem._getModelNameForEntity(entityId)
	if not modelName then
		error("ModelCreationSystem: Could not determine model name for entity " .. entityId)
		return
	end
	
	-- Create model from ReplicatedStorage.EnemyModels using specific model name
	local model = ModelCreationSystem._createModelFromReplicatedStorage(modelName)
	if not model then
		error("ModelCreationSystem: Required model '" .. modelName .. "' not found in ReplicatedStorage.EnemyModels")
		return
	end
	
	if model then
		-- Get spawn position from temporary component (set by EnemySpawnSystem) or use default
		local spawnPosComponent = EntityManager.getComponent(entityId, "SpawnPosition")
		local spawnPosition = spawnPosComponent and spawnPosComponent.value or Vector3.new(0, 0, 0)
		
		-- Remove the temporary spawn position component
		if spawnPosComponent then
			EntityManager.removeComponent(entityId, "SpawnPosition")
		end
		
		-- Find proper ground position using raycast
		local groundPosition = ModelCreationSystem._findGroundPosition(spawnPosition)
		
		if model.PrimaryPart then
			model.PrimaryPart.Position = groundPosition
			model.PrimaryPart.Anchored = false
			model.PrimaryPart.CanCollide = false -- HRP shouldn't collide
		elseif model:FindFirstChildWhichIsA("BasePart") then
			local mainPart = model:FindFirstChildWhichIsA("BasePart")
			mainPart.Position = groundPosition
			mainPart.Anchored = false
			mainPart.CanCollide = false
		end
		
		-- Parent to workspace for visibility
		model.Parent = workspace
		
			-- Add Model component to entity
	EntityManager.addComponent(entityId, "Model", Components.create("Model", {
		model = model,
		part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart"),
		humanoid = model:FindFirstChildOfClass("Humanoid")
	}))

    -- Apply enemy-specific speed to humanoid
    ModelCreationSystem._applyEnemyStatsToHumanoid(entityId, model)

    -- Load animations for the enemy
    ModelCreationSystem._loadAnimationsForEntity(entityId, model)

    -- Ragdoll system: connect Humanoid.Died event for all enemies
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if humanoid then
        -- Tutorial: Set BreakJointsOnDeath and RequiresNeck to false for basic ragdoll
        humanoid.BreakJointsOnDeath = false
        humanoid.RequiresNeck = false
        humanoid.Died:Connect(function()
            onDeathOfTheEnemy(model)
        end)
    end

    -- Assign all parts to 'Enemies' collision group
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CollisionGroup = "Enemies"
        end
    end

    print("🎨 Created model '" .. modelName .. "' for", enemyType.enemyId, "entity", entityId, "at", groundPosition)
	end
end



-- REMOVED: _updateModelPositions function - Position updates now handled by Roblox MoveTo only

-- Get the specific model name for an entity from EnemyDefinitions
function ModelCreationSystem._getModelNameForEntity(entityId)
	local enemyType = EntityManager.getComponent(entityId, "EnemyType")
	if not enemyType or not enemyType.enemyId then
		return nil
	end
	
	-- Get the enemy definition using the stored enemy ID
	local EnemyDefinitions = require(ReplicatedStorage.Shared.EnemyDefinitions)
	local enemyDef = EnemyDefinitions:GetEnemy(enemyType.enemyId)
	
	if enemyDef and enemyDef.model then
		return enemyDef.model
	end
	
	return nil
end

-- Create model from ReplicatedStorage.EnemyModels using specific model name
function ModelCreationSystem._createModelFromReplicatedStorage(modelName)
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	-- Check if EnemyModels folder exists
	local enemyModelsFolder = ReplicatedStorage:FindFirstChild("EnemyModels")
	if not enemyModelsFolder then
		error("❌ EnemyModels folder not found in ReplicatedStorage")
		return nil
	end
	
	-- Find the specific model in the folder
	local originalModel = enemyModelsFolder:FindFirstChild(modelName)
	if not originalModel then
		error("❌ Model '" .. modelName .. "' not found in EnemyModels folder")
		return nil
	end
	
	-- Clone the model
	local model = originalModel:Clone()
	
	print("✅ Using specific model '" .. modelName .. "' from EnemyModels folder")
	return model
end

-- Find proper ground position using raycast
function ModelCreationSystem._findGroundPosition(spawnPosition)
	local rayOrigin = spawnPosition + Vector3.new(0, 50, 0) -- Start 50 studs above
	local rayDirection = Vector3.new(0, -100, 0) -- Cast 100 studs down
	
	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude
	raycastParams.FilterDescendantsInstances = {} -- Don't filter anything for now
	
	local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
	
	if result then
		-- Position slightly above the ground (2 studs for humanoid height)
		return result.Position + Vector3.new(0, 2, 0)
	else
		-- Fallback: use original position with small offset
		return spawnPosition + Vector3.new(0, 2, 0)
	end
end

-- Apply enemy-specific stats to humanoid (speed, health, etc.)
function ModelCreationSystem._applyEnemyStatsToHumanoid(entityId, model)
	local humanoid = model:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		warn("⚠️ No humanoid found for entity " .. entityId .. ", skipping stat application")
		return
	end
	
	-- Apply speed from EnemyAI component
	local enemyAI = EntityManager.getComponent(entityId, "EnemyAI")
	if enemyAI and enemyAI.speed then
		humanoid.WalkSpeed = enemyAI.speed
		print("🏃 Set entity", entityId, "WalkSpeed to", enemyAI.speed)
	else
		humanoid.WalkSpeed = 16 -- Fallback to default
		warn("⚠️ No EnemyAI speed found for entity " .. entityId .. ", using default speed 16")
	end
	
	-- Apply health from EnemyDefinitions
	local enemyType = EntityManager.getComponent(entityId, "EnemyType")
	if enemyType and enemyType.enemyId then
		local EnemyDefinitions = require(ReplicatedStorage.Shared.EnemyDefinitions)
		local enemyDef = EnemyDefinitions:GetEnemy(enemyType.enemyId)
		if enemyDef and enemyDef.health then
			humanoid.MaxHealth = enemyDef.health
			humanoid.Health = enemyDef.health
			print("❤️ Set entity", entityId, "health to", enemyDef.health .. "/" .. enemyDef.health)
		else
			-- Fallback to default health
			humanoid.MaxHealth = 100
			humanoid.Health = 100
			print("❤️ Set entity", entityId, "health to default 100/100")
		end
	else
		-- Fallback to default health
		humanoid.MaxHealth = 100
		humanoid.Health = 100
		print("❤️ Set entity", entityId, "health to default 100/100")
	end
end

-- Update humanoid speed when EnemyAI component changes (for dynamic speed changes)
function ModelCreationSystem.updateHumanoidSpeed(entityId)
	local model = EntityManager.getComponent(entityId, "Model")
	local enemyAI = EntityManager.getComponent(entityId, "EnemyAI")
	
	if model and model.humanoid and enemyAI and enemyAI.speed then
		model.humanoid.WalkSpeed = enemyAI.speed
		print("🔄 Updated entity", entityId, "WalkSpeed to", enemyAI.speed)
		return true
	end
	
	return false
end

-- Clean up when entity is destroyed
function ModelCreationSystem.cleanup(entityId)
	-- Clean up animation state by finding the model
	local model = EntityManager.getComponent(entityId, "Model")
	if model and model.model and enemyAnimations[model.model] then
		enemyAnimations[model.model] = nil
		print("🧹 Cleaned up animation state for entity", entityId)
	end
	
	-- Check if the enemy is dead (ragdolled) - if so, preserve the model
	if model and model.model and model.model.Parent then
		local humanoid = model.model:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.Health <= 0 then
			-- Enemy is dead/ragdolled - preserve the model for ragdoll physics
			print("💀 Entity", entityId, "is dead/ragdolled - preserving model for ragdoll physics")
			-- Remove the model component but keep the actual model in workspace
			EntityManager.removeComponent(entityId, "Model")
		else
			-- Enemy is alive - destroy the model normally
			print("🧹 Entity", entityId, "is alive - destroying model")
			model.model:Destroy()
		end
	end
end

-- Load animations for an entity's model
function ModelCreationSystem._loadAnimationsForEntity(entityId, model)
	local humanoid = model:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		warn("⚠️ No humanoid found for entity " .. entityId .. ", skipping animations")
		return
	end
	
	-- Animation IDs
	local ANIMATION_IDS = {
		idle = "rbxassetid://90478240073535",
		walk = "rbxassetid://180426354",  -- Default R6 walk animation
		attack = "rbxassetid://136814345857964",
		aim = "rbxassetid://135648359564667"  -- Aiming animation for ranged enemies
	}
	
	local animationSet = Components.create("AnimationSet", {})
	
	-- Load idle animation
	if ANIMATION_IDS.idle then
		local idleAnimation = Instance.new("Animation")
		idleAnimation.AnimationId = ANIMATION_IDS.idle
		animationSet.idle = humanoid:LoadAnimation(idleAnimation)
	end
	
	-- Load walk animation
	if ANIMATION_IDS.walk then
		local walkAnimation = Instance.new("Animation")
		walkAnimation.AnimationId = ANIMATION_IDS.walk
		animationSet.walk = humanoid:LoadAnimation(walkAnimation)
	end
	
	-- Load attack animation
	if ANIMATION_IDS.attack then
		local attackAnimation = Instance.new("Animation")
		attackAnimation.AnimationId = ANIMATION_IDS.attack
		animationSet.attack = humanoid:LoadAnimation(attackAnimation)
	end
	
	-- Load aim animation
	if ANIMATION_IDS.aim then
		local aimAnimation = Instance.new("Animation")
		aimAnimation.AnimationId = ANIMATION_IDS.aim
		animationSet.aim = humanoid:LoadAnimation(aimAnimation)
	end
	
	-- Set up movement detection for real-time animation sync
	ModelCreationSystem._setupMovementDetection(entityId, humanoid, animationSet)
	
	-- Add AnimationSet component to entity
	EntityManager.addComponent(entityId, "AnimationSet", animationSet)
	
	print("🎬 Loaded animations for entity", entityId)
end

-- Set up movement detection for real-time animation synchronization
function ModelCreationSystem._setupMovementDetection(entityId, humanoid, animationSet)
	local model = EntityManager.getComponent(entityId, "Model")
	if not model or not model.model then
		return
	end
	
	-- Store animation state by model (like princess system)
	local animState = {
		isMoving = false,
		entityId = entityId
	}
	enemyAnimations[model.model] = animState
	
	-- Simple movement detection exactly like princess
	humanoid.Running:Connect(function(speed)
		if speed > 0.1 and not animState.isMoving then
			-- Started moving - play walk animation
			animState.isMoving = true
			ModelCreationSystem._playEnemyAnimation(model.model, "walk")
		elseif speed <= 0.1 and animState.isMoving then
			-- Stopped moving - DON'T play idle, let AI system handle it
			animState.isMoving = false
			-- Just stop the current animation if it's movement-driven
			local animationSet = EntityManager.getComponent(animState.entityId, "AnimationSet")
			if animationSet and animationSet.animationSource == "movement" and animationSet.current then
				animationSet.current:Stop()
				animationSet.current = nil
				animationSet.animationSource = "state"
				EntityManager.addComponent(animState.entityId, "AnimationSet", animationSet)
				print("🎭 Entity", animState.entityId, "stopped movement animation - AI will take over")
			end
		end
	end)
	
	print("🎯 Set up movement detection for entity", entityId, "- Princess-style system")
end

-- Play animation for an enemy (like princess system)
function ModelCreationSystem._playEnemyAnimation(model, animName)
	local animState = enemyAnimations[model]
	if not animState then
		return
	end
	
	-- Get current animation set from entity
	local animationSet = EntityManager.getComponent(animState.entityId, "AnimationSet")
	if not animationSet then
		return
	end
	
	-- Stop current animation
	if animationSet.current then
		animationSet.current:Stop()
	end
	
	-- Play new animation
	local newAnimation = animationSet[animName]
	if newAnimation then
		newAnimation:Play()
		animationSet.current = newAnimation
		animationSet.animationSource = "movement"
		
		-- Update component
		EntityManager.addComponent(animState.entityId, "AnimationSet", animationSet)
		
		print("🎭 Entity", animState.entityId, "playing", animName, "animation (movement-driven)")
	end
end

-- Public function to play animation for an entity (used by other systems)
function ModelCreationSystem.playAnimationForEntity(entityId, animName)
	local model = EntityManager.getComponent(entityId, "Model")
	if not model or not model.model then
		return
	end
	
	ModelCreationSystem._playEnemyAnimation(model.model, animName)
end

-- Add ragdoll logic for all enemies
local CollectionService = game:GetService("CollectionService")
local PhysicsService = game:GetService("PhysicsService")

-- Ensure collision groups are set up
local function setupCollisionGroups()
    -- Register groups if they don't exist (using new API)
    pcall(function() PhysicsService:RegisterCollisionGroup("Enemies") end)
    pcall(function() PhysicsService:RegisterCollisionGroup("Ragdolls") end)
    pcall(function() PhysicsService:RegisterCollisionGroup("Items") end)
    -- Enemies ignore ragdolls and items
    PhysicsService:CollisionGroupSetCollidable("Enemies", "Ragdolls", false)
    PhysicsService:CollisionGroupSetCollidable("Enemies", "Items", false)
    -- Ragdolls and items still collide with Default (ground, walls, etc.)
end
setupCollisionGroups()

function onDeathOfTheEnemy(enemy)
    local humanoid = enemy:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Find the entity ID for this enemy model
    local entityId = nil
    for _, id in ipairs(EntityManager.getEntitiesWith("Model")) do
        local model = EntityManager.getComponent(id, "Model")
        if model and model.model == enemy then
            entityId = id
            break
        end
    end
    
    if entityId then
        print("💀 Enemy entity", entityId, "died - removing AI/combat components, preserving ragdoll")
        
        -- Remove all enemy functionality components while preserving ragdoll physics
        EntityManager.removeComponent(entityId, "EnemyAI")
        EntityManager.removeComponent(entityId, "Combat") 
        EntityManager.removeComponent(entityId, "EnemyType")
        EntityManager.removeComponent(entityId, "CombatStats")
        EntityManager.removeComponent(entityId, "EnemyChat")
        EntityManager.removeComponent(entityId, "AnimationSet")
        
        -- Remove the Model component but keep the actual model in workspace for ragdoll
        EntityManager.removeComponent(entityId, "Model")
        
        print("🧹 Removed all enemy functionality components for entity", entityId)
    end
    
    -- Hide health bar
    humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
    -- Disable state machine to allow falling over
    humanoid.EvaluateStateMachine = false
    -- Prevent standing up
    humanoid.PlatformStand = true
    
    -- Set CanCollide = true and assign to Ragdolls group for all limb parts
    for _, part in ipairs(enemy:GetChildren()) do
        if part:IsA("BasePart") and (part.Name:find("Arm") or part.Name:find("Leg") or part.Name == "Torso" or part.Name == "Head") then
            part.CanCollide = true
            PhysicsService:SetPartCollisionGroup(part, "Ragdolls")
        end
    end
    
    -- Replace Motor6Ds with BallSocketConstraints (except Neck)
    local torso = enemy:FindFirstChild("Torso")
    if torso then
        for _, joint in ipairs(torso:GetChildren()) do
            if joint:IsA("Motor6D") and joint.Name ~= "Neck" then
                createSocket(torso, joint.Part1, joint.C0, joint.C1)
                joint:Destroy()
            end
        end
    end
    -- Tag as Draggable
    CollectionService:AddTag(enemy, "Draggable")
    
    -- Tag as Sacrifice for altar system
    CollectionService:AddTag(enemy, "Sacrifice")
    
    print("✅ Ragdoll physics preserved for enemy:", enemy.Name)
end

function createSocket(torso, part, c0, c1)
    local ballSocket = Instance.new("BallSocketConstraint")
    ballSocket.Name = part.Name .. "Socket"
    -- Attachments
    local attachment0 = createAttachment(torso, c0)
    local attachment1 = createAttachment(part, c1)
    ballSocket.Attachment0 = attachment0
    ballSocket.Attachment1 = attachment1
    -- Optionally configure limits here if desired
    ballSocket.Parent = torso
end

function createAttachment(part, cframeOffset)
    local attachment = Instance.new("Attachment")
    attachment.Name = part.Name .. "Attachment"
    attachment.CFrame = cframeOffset
    attachment.Parent = part
    return attachment
end

return ModelCreationSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="74">
          <Properties>
            <string name="Name">RangedChaseHandler</string>
            <string name="Source"><![CDATA[-- RangedChaseHandler.luau
-- Handles chase behavior specifically for ranged enemies
-- Ranged enemies use tactical positioning, aiming, and projectile bursts

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

-- Import Components (find ModuleScript specifically)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("RangedChaseHandler: Could not find EnemyComponents ModuleScript")
end

local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Import rotation utility
local EnemyRotationUtility = require(script.Parent.EnemyRotationUtility)

-- Import DamageSystem for applying damage
local DamageSystem = require(script.Parent.Parent.Systems.DamageSystem)

local RangedChaseHandler = {}

-- Default configuration for ranged enemies (fallback values)
local DEFAULT_RANGED_CONFIG = {
    BURST_SIZE = 3,
    SHOT_INTERVAL = 0.25,           -- 0.25 seconds between shots in burst
    AIM_TIME = 0.2,                 -- 0.2 seconds to aim and capture target
    POST_BURST_PAUSE = 0.5,         -- pause after burst before next action
    REPOSITION_THRESHOLD = 8,        -- studs player must move to trigger reposition
    OPTIMAL_DISTANCE = 25,           -- preferred shooting distance
    
    -- Projectile settings
    PROJECTILE_SPEED = 70,           -- studs per second
    PROJECTILE_DAMAGE = 15,          -- damage per projectile (45 total per burst)
    PROJECTILE_SIZE = Vector3.new(0.2, 0.2, 0.2),
    PROJECTILE_COLOR = Color3.fromRGB(255, 100, 50),  -- Orange-red
    PROJECTILE_LIFETIME = 3,         -- seconds before cleanup
}

-- Store ranged enemy state data
local rangedEnemyStates = {}  -- {[entityId] = {phase, burstCount, lastShotTime, targetedPlayerPosition, aimStartTime, activeProjectiles, firingAnimationTrack}}

-- Helper function to get enemy-specific ranged configuration
local function getEnemyRangedConfig(entityId)
    local enemyType = EntityManager.getComponent(entityId, "EnemyType")
    if not enemyType or not enemyType.config then
        return DEFAULT_RANGED_CONFIG
    end
    
    local config = enemyType.config
    return {
        BURST_SIZE = config.burstSize or DEFAULT_RANGED_CONFIG.BURST_SIZE,
        SHOT_INTERVAL = config.shotInterval or DEFAULT_RANGED_CONFIG.SHOT_INTERVAL,
        AIM_TIME = config.aimTime or DEFAULT_RANGED_CONFIG.AIM_TIME,
        POST_BURST_PAUSE = config.postBurstPause or DEFAULT_RANGED_CONFIG.POST_BURST_PAUSE,
        REPOSITION_THRESHOLD = config.repositionThreshold or DEFAULT_RANGED_CONFIG.REPOSITION_THRESHOLD,
        OPTIMAL_DISTANCE = config.optimalDistance or DEFAULT_RANGED_CONFIG.OPTIMAL_DISTANCE,
        
        -- Projectile settings
        PROJECTILE_SPEED = config.projectileSpeed or DEFAULT_RANGED_CONFIG.PROJECTILE_SPEED,
        PROJECTILE_DAMAGE = config.damage or DEFAULT_RANGED_CONFIG.PROJECTILE_DAMAGE,
        PROJECTILE_SIZE = config.projectileSize or DEFAULT_RANGED_CONFIG.PROJECTILE_SIZE,
        PROJECTILE_COLOR = config.projectileColor or DEFAULT_RANGED_CONFIG.PROJECTILE_COLOR,
        PROJECTILE_LIFETIME = config.projectileLifetime or DEFAULT_RANGED_CONFIG.PROJECTILE_LIFETIME,
        PROJECTILE_TYPE = config.projectileType or "default",
    }
end

-- Handle ranged enemy chase behavior
function RangedChaseHandler.handleChase(entityId, enemyAI, model, closestPlayer, distance, currentTime, entityLastPlayerPositions, CONFIG)
    -- Get or create ranged state for this entity
    local rangedState = rangedEnemyStates[entityId]
    if not rangedState then
        rangedState = {
            phase = "positioning",
            burstCount = 0,
            lastShotTime = 0,
            targetedPlayerPosition = nil,
            aimStartTime = 0,
            activeProjectiles = {}
        }
        rangedEnemyStates[entityId] = rangedState
    end
    
    -- Get enemy-specific ranges
    local attackRange = enemyAI.attackRange or CONFIG.ATTACK_RANGE
    local detectionRange = enemyAI.detectionRange or CONFIG.DETECTION_RANGE
    
    -- Check if we should give up chase
    if not closestPlayer then
        rangedEnemyStates[entityId] = nil  -- Clean up state
        return "idle"
    end
    
    if distance > detectionRange then
        rangedEnemyStates[entityId] = nil  -- Clean up state
        return "idle"
    end
    
    -- Check chase timeout
    local chaseTime = currentTime - (enemyAI.stateStartTime or currentTime)
    if chaseTime >= CONFIG.CHASE_TIMEOUT then
        rangedEnemyStates[entityId] = nil  -- Clean up state
        return "idle"
    end
    
    -- Handle different phases of ranged combat
    if rangedState.phase == "positioning" then
        return RangedChaseHandler._handlePositioning(entityId, enemyAI, model, closestPlayer, distance, currentTime, rangedState, entityLastPlayerPositions, CONFIG)
    elseif rangedState.phase == "aiming" then
        return RangedChaseHandler._handleAiming(entityId, enemyAI, model, closestPlayer, distance, currentTime, rangedState)
    elseif rangedState.phase == "shooting" then
        return RangedChaseHandler._handleShooting(entityId, enemyAI, model, closestPlayer, distance, currentTime, rangedState)
    elseif rangedState.phase == "repositioning" then
        return RangedChaseHandler._handleRepositioning(entityId, enemyAI, model, closestPlayer, distance, currentTime, rangedState, entityLastPlayerPositions, CONFIG)
    end
    
    return "chase"
end

-- Phase 1: Positioning - Move closer if player is out of range
function RangedChaseHandler._handlePositioning(entityId, enemyAI, model, closestPlayer, distance, currentTime, rangedState, entityLastPlayerPositions, CONFIG)
    local attackRange = enemyAI.attackRange or CONFIG.ATTACK_RANGE
    
    -- Simple logic: if player is within attack range, start shooting
    if distance <= attackRange then
        -- Player is in range - transition to aiming
        rangedState.phase = "aiming"
        rangedState.aimStartTime = currentTime
        rangedState.targetedPlayerPosition = closestPlayer.position  -- Capture target position
        print("🎯 Ranged enemy", entityId, "player in range - transitioning to aiming phase")
        return "chase"
    end
    
    -- Player is out of range - move closer
    local shouldUpdateMoveTo = false
    
    -- Calculate if we need to move
    local lastKnownPlayerPos = entityLastPlayerPositions[entityId]
    local currentPlayerPos = closestPlayer.position
    
    if not lastKnownPlayerPos then
        shouldUpdateMoveTo = true
    else
        local playerMovedDistance = (currentPlayerPos - lastKnownPlayerPos).Magnitude
        local enemyConfig = getEnemyRangedConfig(entityId)
        if playerMovedDistance > enemyConfig.REPOSITION_THRESHOLD then
            shouldUpdateMoveTo = true
        end
    end
    
    -- Move toward player (but only when they're out of range)
    if shouldUpdateMoveTo then
        -- Rotate to face player while moving
        EnemyRotationUtility.rotateForChase(entityId, closestPlayer)
        
        RangedChaseHandler._moveToPlayer(entityId, closestPlayer, enemyAI)
        entityLastPlayerPositions[entityId] = currentPlayerPos
        enemyAI.lastMoveToTime = currentTime
        print("📍 Ranged enemy", entityId, "moving closer - player out of range")
    end
    
    return "chase"
end

-- Phase 2: Aiming - Capture target position and prepare to shoot
function RangedChaseHandler._handleAiming(entityId, enemyAI, model, closestPlayer, distance, currentTime, rangedState)
    local enemyConfig = getEnemyRangedConfig(entityId)
    local aimDuration = currentTime - rangedState.aimStartTime
    
    -- Play aiming animation when starting to aim (only once)
    -- This triggers when ranged enemies transition from positioning to aiming phase
    if aimDuration < 0.1 then  -- Just started aiming
        local ModelCreationSystem = require(script.Parent.ModelCreationSystem)
        ModelCreationSystem.playAnimationForEntity(entityId, "aim")
        print("🎯 Ranged enemy", entityId, "started aiming animation")
    end
    
    if aimDuration >= enemyConfig.AIM_TIME then
        -- Aiming complete - transition to shooting
        rangedState.phase = "shooting"
        rangedState.burstCount = 0
        rangedState.lastShotTime = currentTime - enemyConfig.SHOT_INTERVAL  -- Allow immediate first shot
        print("🔫 Ranged enemy", entityId, "aiming complete - starting burst")
        return "chase"
    end
    
    -- Stop movement during aiming - just face the target
    if model.humanoid then
        -- Stop any current movement
        model.humanoid:MoveTo(model.part.Position)
    end
    
    -- Rotate to face player during aiming
    EnemyRotationUtility.rotateForAttackInstant(entityId, closestPlayer)
    
    print("🎯 Ranged enemy", entityId, "aiming... (" .. math.floor((enemyConfig.AIM_TIME - aimDuration) * 10) / 10 .. "s remaining)")
    return "chase"
end

-- Phase 3: Shooting - Fire projectile burst at captured position
function RangedChaseHandler._handleShooting(entityId, enemyAI, model, closestPlayer, distance, currentTime, rangedState)
    local enemyConfig = getEnemyRangedConfig(entityId)
    
    -- Stop movement during shooting
    if model.humanoid then
        model.humanoid:MoveTo(model.part.Position)
    end
    
    -- Rotate to face player during shooting
    EnemyRotationUtility.rotateForAttackInstant(entityId, closestPlayer)
    
    -- Get the animation track from the aiming phase and pause it at the last frame
    if rangedState.burstCount == 0 and not rangedState.firingAnimationTrack then
        local animationSet = EntityManager.getComponent(entityId, "AnimationSet")
        if animationSet and animationSet.aim then
            rangedState.firingAnimationTrack = animationSet.aim
            
            -- Pause the animation at the last frame immediately when shooting starts
            rangedState.firingAnimationTrack:AdjustSpeed(0)
            print("🎭 Ranged enemy", entityId, "paused aiming animation at last frame for firing")
        end
    end
    
    -- Check if we should fire next shot
    local timeSinceLastShot = currentTime - rangedState.lastShotTime
    
    if timeSinceLastShot >= enemyConfig.SHOT_INTERVAL and rangedState.burstCount < enemyConfig.BURST_SIZE then
        -- Fire projectile
        RangedChaseHandler._fireProjectile(entityId, model, rangedState.targetedPlayerPosition)
        rangedState.burstCount = rangedState.burstCount + 1
        rangedState.lastShotTime = currentTime
        print("💥 Ranged enemy", entityId, "fired shot", rangedState.burstCount, "of", enemyConfig.BURST_SIZE)
    end
    
    -- Check if burst is complete
    if rangedState.burstCount >= enemyConfig.BURST_SIZE then
        -- Resume the animation after burst is complete
        if rangedState.firingAnimationTrack then
            -- Resume normal speed immediately
            rangedState.firingAnimationTrack:AdjustSpeed(1)
            print("🎭 Ranged enemy", entityId, "resumed animation after burst")
        end
        
        -- Burst complete - transition to repositioning
        rangedState.phase = "repositioning"
        rangedState.repositionStartTime = currentTime
        rangedState.firingAnimationTrack = nil  -- Clear the track reference
        print("✅ Ranged enemy", entityId, "burst complete - repositioning")
    end
    
    return "chase"
end

-- Phase 4: Repositioning - Brief pause then decide next action
function RangedChaseHandler._handleRepositioning(entityId, enemyAI, model, closestPlayer, distance, currentTime, rangedState, entityLastPlayerPositions, CONFIG)
    local enemyConfig = getEnemyRangedConfig(entityId)
    local pauseDuration = currentTime - (rangedState.repositionStartTime or currentTime)
    local attackRange = enemyAI.attackRange or CONFIG.ATTACK_RANGE
    
    -- Stop movement during repositioning pause
    if model.humanoid then
        model.humanoid:MoveTo(model.part.Position)
    end
    
    if pauseDuration >= enemyConfig.POST_BURST_PAUSE then
        -- Simple logic: if player is in range, shoot again; if not, move closer
        if distance <= attackRange then
            -- Player still in range - start another burst cycle
            rangedState.phase = "aiming"
            rangedState.aimStartTime = currentTime
            rangedState.targetedPlayerPosition = closestPlayer.position
            print("🔄 Ranged enemy", entityId, "player still in range - starting new burst cycle")
        else
            -- Player out of range - go back to positioning to move closer
            rangedState.phase = "positioning"
            print("🔄 Ranged enemy", entityId, "player out of range - repositioning to get closer")
        end
    end
    
    return "chase"
end

-- Move directly toward player (only when out of range)
function RangedChaseHandler._moveToPlayer(entityId, playerData, enemyAI)
    local model = EntityManager.getComponent(entityId, "Model")
    if not model or not model.humanoid or not model.humanoid.Parent then
        return
    end
    
    if playerData.player.Character and playerData.player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoid = model.humanoid
        local playerPosition = playerData.player.Character.HumanoidRootPart.Position
        
        -- Move directly toward player
        local baseSpeed = enemyAI.speed or 16
        humanoid.WalkSpeed = baseSpeed * 0.8  -- Slightly slower for positioning
        
        humanoid:MoveTo(playerPosition)
    end
end

-- Fire a projectile at the target position
function RangedChaseHandler._fireProjectile(entityId, model, targetPosition)
    if not model.part or not targetPosition then
        return
    end
    
    local enemyConfig = getEnemyRangedConfig(entityId)
    
    -- Find the weapon in the enemy's right hand
    local startPosition = model.part.Position + Vector3.new(0, 2, 0)  -- Default fallback
    
    if model.model then
        -- First, try to find the Gun model directly in the enemy model
        local gun = model.model:FindFirstChild("Gun")
        if gun then
            -- Gun is a Model, so we need to find the "Tip" part first, then fallback to other parts
            local tip = gun:FindFirstChild("Tip")
            if tip then
                startPosition = tip.Position
                print("🎯 Found Gun Tip at position:", tip.Position)
            else
                -- Look for other specific parts in the Gun model (like "Barrel" or "Muzzle")
                local barrel = gun:FindFirstChild("Barrel") or gun:FindFirstChild("Muzzle")
                if barrel then
                    startPosition = barrel.Position
                    print("🎯 Found Gun barrel at position:", barrel.Position)
                else
                    -- Fallback: use the PrimaryPart or first part in the Gun model
                    if gun.PrimaryPart then
                        startPosition = gun.PrimaryPart.Position
                        print("🎯 Found Gun model PrimaryPart at position:", gun.PrimaryPart.Position)
                    else
                        local firstPart = gun:FindFirstChildWhichIsA("BasePart")
                        if firstPart then
                            startPosition = firstPart.Position
                            print("🎯 Found Gun part at position:", firstPart.Position)
                        else
                            print("⚠️ Gun model found but no parts inside it")
                        end
                    end
                end
            end
        else
            -- Try to find the weapon in the right hand/arm
            local rightArm = model.model:FindFirstChild("Right Arm") or model.model:FindFirstChild("RightHand")
            if rightArm then
                -- Look for a weapon in the right arm
                local weapon = rightArm:FindFirstChild("Bow") or rightArm:FindFirstChild("Gun") or rightArm:FindFirstChild("Weapon")
                if weapon then
                    -- Use the weapon's position
                    startPosition = weapon.Position
                    print("🎯 Found weapon in right arm at position:", weapon.Position)
                else
                    -- Use the right arm's position
                    startPosition = rightArm.Position
                    print("🎯 Using right arm position:", rightArm.Position)
                end
            else
                -- Fallback: try to find any weapon in the model
                local weapon = model.model:FindFirstChild("Bow") or model.model:FindFirstChild("Gun") or model.model:FindFirstChild("Weapon")
                if weapon then
                    startPosition = weapon.Position
                    print("🎯 Found weapon in model at position:", weapon.Position)
                else
                    print("⚠️ No weapon found, using default position:", startPosition)
                end
            end
        end
    end
    
    -- Create projectile using ProjectileManager (server logic only)
    local ProjectileManager = require(script.Parent.Parent.ProjectileManager)
    local projectileConfig = {
        size = enemyConfig.PROJECTILE_SIZE,
        color = enemyConfig.PROJECTILE_COLOR,
        speed = enemyConfig.PROJECTILE_SPEED,
        damage = enemyConfig.PROJECTILE_DAMAGE,
        lifetime = enemyConfig.PROJECTILE_LIFETIME,
        projectileType = enemyConfig.PROJECTILE_TYPE
    }
    
    print("🎯 DEBUG: Creating projectile with config:", projectileConfig)
    print("🎯 DEBUG: ProjectileType:", enemyConfig.PROJECTILE_TYPE)
    
    ProjectileManager.createProjectile(startPosition, targetPosition, projectileConfig)
    
    print("🚀 Server fired projectile from", startPosition, "to", targetPosition)
end

-- Clean up ranged enemy state when entity is destroyed
function RangedChaseHandler.cleanupEntity(entityId)
    local rangedState = rangedEnemyStates[entityId]
    if rangedState and rangedState.firingAnimationTrack then
        -- Resume normal speed before cleanup
        rangedState.firingAnimationTrack:AdjustSpeed(1)
    end
    rangedEnemyStates[entityId] = nil
end

return RangedChaseHandler ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="75">
          <Properties>
            <string name="Name">SpecialChaseHandler</string>
            <string name="Source"><![CDATA[-- SpecialChaseHandler.luau
-- Handles chase behavior specifically for special enemies
-- Special enemies have unique abilities and behaviors

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Import Components (find ModuleScript specifically)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("SpecialChaseHandler: Could not find EnemyComponents ModuleScript")
end

local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Rotation utility removed for special enemies (only ranged enemies rotate)

local SpecialChaseHandler = {}

-- Configuration specific to special enemies
local SPECIAL_CONFIG = {
    PERSISTENCE_MULTIPLIER = 2.0,      -- Chase until 2x detection range (very persistent)
    MOVE_THRESHOLD_MULTIPLIER = 0.3,   -- Very responsive movement
    ABILITY_COOLDOWN = 5.0,            -- Seconds between special abilities
    TELEPORT_RANGE = 15,               -- Range for teleport abilities
}

-- Store special enemy state data for abilities
local specialEnemyStates = {}  -- {[entityId] = {lastAbilityTime, abilityPhase, ...}}

-- Handle special enemy chase behavior
function SpecialChaseHandler.handleChase(entityId, enemyAI, model, closestPlayer, distance, currentTime, entityLastPlayerPositions, CONFIG)
    -- Get or create special state for this entity
    local specialState = specialEnemyStates[entityId]
    if not specialState then
        specialState = {
            lastAbilityTime = 0,
            abilityPhase = "none"
        }
        specialEnemyStates[entityId] = specialState
    end
    
    -- Get enemy-specific ranges
    local attackRange = enemyAI.attackRange or CONFIG.ATTACK_RANGE
    local detectionRange = enemyAI.detectionRange or CONFIG.DETECTION_RANGE
    
    -- Check if we should give up chase (special enemies are very persistent)
    if not closestPlayer then
        specialEnemyStates[entityId] = nil  -- Clean up state
        return "idle"
    end
    
    local maxChaseDistance = detectionRange * SPECIAL_CONFIG.PERSISTENCE_MULTIPLIER
    if distance > maxChaseDistance then
        specialEnemyStates[entityId] = nil  -- Clean up state
        return "idle"
    end
    
    -- Check chase timeout
    local chaseTime = currentTime - (enemyAI.stateStartTime or currentTime)
    if chaseTime >= CONFIG.CHASE_TIMEOUT then
        specialEnemyStates[entityId] = nil  -- Clean up state
        return "idle"
    end
    
    -- === SPECIAL ABILITIES LOGIC ===
    SpecialChaseHandler._handleSpecialAbilities(entityId, enemyAI, model, closestPlayer, distance, currentTime, specialState)
    
    -- === ATTACK LOGIC (similar to melee but with special effects) ===
    local inAttackRange = distance <= attackRange
    if inAttackRange then
        SpecialChaseHandler._handleContinuousAttack(entityId, closestPlayer, currentTime)
        SpecialChaseHandler._playSpecialAttackAnimation(entityId, model)
    end
    
    -- === MOVEMENT LOGIC (enhanced movement) ===
    local STOPPING_ZONE = attackRange * 0.9  -- Get close for special attacks
    local SLOW_ZONE = attackRange * 2.5      -- Larger slow zone
    
    -- Very responsive player tracking
    local lastKnownPlayerPos = entityLastPlayerPositions[entityId]
    local currentPlayerPos = closestPlayer.position
    local shouldUpdateMoveTo = false

    if not lastKnownPlayerPos then
        shouldUpdateMoveTo = true
    else
        local playerMovedDistance = (currentPlayerPos - lastKnownPlayerPos).Magnitude
        local moveThreshold = CONFIG.PLAYER_MOVE_THRESHOLD * SPECIAL_CONFIG.MOVE_THRESHOLD_MULTIPLIER
        if playerMovedDistance > moveThreshold then
            shouldUpdateMoveTo = true
        end
    end

    -- Basic stuck detection
    local lastMoveToTime = enemyAI.lastMoveToTime or 0
    if not shouldUpdateMoveTo and (currentTime - lastMoveToTime) > CONFIG.STUCK_TIMEOUT then
        shouldUpdateMoveTo = true
    end

    -- Movement behavior
    if distance <= STOPPING_ZONE then
        -- Close enough for special attacks
        if inAttackRange then
            print("✨ Special enemy", entityId, "in optimal special attack position")
        end
    elseif shouldUpdateMoveTo then
        -- Enhanced movement for special enemies
        SpecialChaseHandler._moveToPlayerEnhanced(entityId, closestPlayer, distance, SLOW_ZONE, enemyAI, CONFIG)
        entityLastPlayerPositions[entityId] = currentPlayerPos
        enemyAI.lastMoveToTime = currentTime
        
        if inAttackRange then
            print("🏃‍♂️✨ Special enemy", entityId, "using special attacks while moving")
        end
    end
    
    return "chase"
end

-- Handle special abilities (placeholder for future expansion)
function SpecialChaseHandler._handleSpecialAbilities(entityId, enemyAI, model, closestPlayer, distance, currentTime, specialState)
    local timeSinceLastAbility = currentTime - specialState.lastAbilityTime
    
    if timeSinceLastAbility >= SPECIAL_CONFIG.ABILITY_COOLDOWN then
        -- Example special ability: teleport closer if far away
        if distance > 20 and distance < SPECIAL_CONFIG.TELEPORT_RANGE * 2 then
            SpecialChaseHandler._attemptTeleport(entityId, model, closestPlayer, specialState, currentTime)
        end
        
        -- Add more special abilities here in the future:
        -- - Shadow clone
        -- - Area damage
        -- - Temporary invincibility
        -- - Life drain
        -- - Summon minions
    end
end

-- Example special ability: teleport
function SpecialChaseHandler._attemptTeleport(entityId, model, closestPlayer, specialState, currentTime)
    if not model.part or not closestPlayer.player.Character then
        return
    end
    
    local playerPosition = closestPlayer.player.Character.HumanoidRootPart.Position
    local currentPosition = model.part.Position
    
    -- Calculate teleport position (closer to player but not too close)
    local direction = (playerPosition - currentPosition).Unit
    local teleportPosition = playerPosition - (direction * SPECIAL_CONFIG.TELEPORT_RANGE)
    
    -- Teleport with visual effect
    model.part.CFrame = CFrame.new(teleportPosition)
    
    -- Visual effect (simple for now)
    local effect = Instance.new("Explosion")
    effect.Position = currentPosition
    effect.BlastRadius = 5
    effect.BlastPressure = 0  -- No damage
    effect.Parent = workspace
    
    local effect2 = Instance.new("Explosion")
    effect2.Position = teleportPosition
    effect2.BlastRadius = 5
    effect2.BlastPressure = 0  -- No damage
    effect2.Parent = workspace
    
    specialState.lastAbilityTime = currentTime
    print("⚡ Special enemy", entityId, "teleported closer to player!")
end

-- Handle continuous attacking with special effects
function SpecialChaseHandler._handleContinuousAttack(entityId, closestPlayer, currentTime)
    local combat = EntityManager.getComponent(entityId, "Combat")
    if not combat then
        -- Create special combat component
        local enemyAI = EntityManager.getComponent(entityId, "EnemyAI")
        local attackRange = enemyAI and enemyAI.attackRange or 5
        
        warn("⚠️ No Combat component found for special entity", entityId, "- creating enhanced one")
        EntityManager.addComponent(entityId, "Combat", Components.create("Combat", {
            target = closestPlayer.entity,
            damage = 15,  -- Higher damage for special enemies
            lastAttackTime = currentTime,
            attackRange = attackRange
        }))
        print("✨ Created enhanced Combat component for special entity", entityId)
    else
        -- Update combat target if it changed
        if combat.target ~= closestPlayer.entity then
            combat.target = closestPlayer.entity
            EntityManager.addComponent(entityId, "Combat", combat)
            print("🎯 Updated Combat target for special entity", entityId, "to new target")
        end
    end
end

-- Play special attack animation
function SpecialChaseHandler._playSpecialAttackAnimation(entityId, model)
    local animationSet = EntityManager.getComponent(entityId, "AnimationSet")
    if not animationSet or not model.humanoid then
        return
    end
    
    -- Play attack animation with special effects
    if animationSet.attack and not animationSet.attack.IsPlaying then
        animationSet.attack.Priority = Enum.AnimationPriority.Action
        animationSet.attack:Play()
        print("✨ Playing special attack animation for entity", entityId)
    end
end

-- Enhanced movement for special enemies
function SpecialChaseHandler._moveToPlayerEnhanced(entityId, playerData, currentDistance, slowZoneDistance, enemyAI, CONFIG)
    local model = EntityManager.getComponent(entityId, "Model")
    if not model or not model.humanoid or not model.humanoid.Parent then
        return
    end
    
    if playerData.player.Character and playerData.player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoid = model.humanoid
        local targetPosition = playerData.player.Character.HumanoidRootPart.Position
        
        -- Enhanced speed for special enemies
        local baseSpeed = enemyAI.speed or humanoid.WalkSpeed or 16
        local newSpeed = baseSpeed * 1.2  -- 20% faster than normal
        
        if currentDistance <= slowZoneDistance then
            -- Smooth approach but maintain higher speed
            local slowFactor = math.max(0.6, currentDistance / slowZoneDistance)  -- Don't slow down as much
            newSpeed = newSpeed * slowFactor
            print("✨ Special entity", entityId, "in enhanced approach - speed:", math.floor(newSpeed))
        end
        
        -- Apply enhanced speed
        humanoid.WalkSpeed = newSpeed
        
        -- Move to target
        humanoid:MoveTo(targetPosition)
        
        print("🎯 Special entity", entityId, "moving with enhanced speed", newSpeed, "distance:", math.floor(currentDistance))
    end
end

-- Clean up special enemy state when entity is destroyed
function SpecialChaseHandler.cleanupEntity(entityId)
    specialEnemyStates[entityId] = nil
end

return SpecialChaseHandler ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="76">
          <Properties>
            <string name="Name">TestEnemyRotation</string>
            <string name="Source"><![CDATA[--[[
TestEnemyRotation.luau

Simple test script to verify enemy rotation functionality.
This can be run in Roblox Studio to test the rotation system.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Import the rotation utility
local EnemyRotationUtility = require(script.Parent.EnemyRotationUtility)

local TestEnemyRotation = {}

-- Test function to verify rotation utility works
function TestEnemyRotation.testRotationUtility()
    print("🧪 Testing Enemy Rotation Utility...")
    
    -- Test basic functionality
    local testEntityId = "test_entity"
    local testPlayer = Players.LocalPlayer
    
    if not testPlayer or not testPlayer.Character then
        print("❌ Test failed: No player character found")
        return false
    end
    
    local humanoidRootPart = testPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        print("❌ Test failed: No HumanoidRootPart found")
        return false
    end
    
    -- Create test player data structure
    local testPlayerData = {
        player = testPlayer,
        position = humanoidRootPart.Position,
        entity = testPlayer.Character
    }
    
    -- Test rotation functions (these will fail gracefully if no enemy exists)
    local result1 = EnemyRotationUtility.rotateForAttack(testEntityId, testPlayerData, true)
    local result2 = EnemyRotationUtility.rotateForChase(testEntityId, testPlayerData)
    local result3 = EnemyRotationUtility.rotateForAttackInstant(testEntityId, testPlayerData)
    
    print("✅ Rotation utility functions loaded successfully")
    print("   - rotateForAttack: " .. tostring(result1))
    print("   - rotateForChase: " .. tostring(result2))
    print("   - rotateForAttackInstant: " .. tostring(result3))
    
    return true
end

-- Test function to check if enemies are rotating during gameplay
function TestEnemyRotation.checkEnemyRotation()
    print("🔍 Checking enemy rotation during gameplay...")
    
    -- This would be called during gameplay to verify enemies are rotating
    -- For now, just print a success message
    print("✅ Enemy rotation system is active and ready")
    print("   - Ranged enemies will rotate during aiming and shooting")
    print("   - Ranged enemies will rotate smoothly while chasing players")
    print("   - Melee and special enemies do not rotate (maintain original behavior)")
    print("   - Enemies only rotate horizontally (Y-axis) to stay upright")
    
    return true
end

-- Run tests
function TestEnemyRotation.runTests()
    print("🚀 Starting Enemy Rotation Tests...")
    
    local success1 = TestEnemyRotation.testRotationUtility()
    local success2 = TestEnemyRotation.checkEnemyRotation()
    
    if success1 and success2 then
        print("🎉 All enemy rotation tests passed!")
        return true
    else
        print("❌ Some enemy rotation tests failed!")
        return false
    end
end

return TestEnemyRotation ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="77">
          <Properties>
            <string name="Name">VisualEffectsSystem</string>
            <string name="Source"><![CDATA[-- VisualEffectsSystem.lua
-- Simple ECS System for handling visual effects

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

-- Import custom ECS modules
local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Import Components from our custom ECS (find ModuleScript specifically to avoid folder conflict)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("VisualEffectsSystem: Could not find EnemyComponents ModuleScript")
end

local VisualEffectsSystem = {}
VisualEffectsSystem.name = "VisualEffectsSystem"
VisualEffectsSystem.priority = 9

-- Configuration
local CONFIG = {
	UPDATE_INTERVAL = 1/15, -- Reduced to 15 FPS - visual effects don't need high frequency
	MAX_EFFECTS_PER_FRAME = 10,
	MAX_EFFECT_DISTANCE = 200, -- Only show effects within this distance of players
	DAMAGE_TEXT_LIFETIME = 2,
	HIT_EFFECT_DURATION = 0.5
}

-- System state
local lastUpdate = 0
local playerPositions = {}
local lastPlayerScan = 0

-- Initialize system
function VisualEffectsSystem.initialize()
	lastUpdate = 0
	playerPositions = {}
	lastPlayerScan = 0
	return true
end

-- Main update function (temporarily disabled - needs conversion to custom ECS)
function VisualEffectsSystem.update(deltaTime)
	-- TODO: Convert this system from Matter ECS to custom ECS
	-- For now, visual effects are handled by CombatSystem directly
		return
end

-- Create floating damage text
function VisualEffectsSystem._createDamageEffect(position, damage)
	local gui = Instance.new("BillboardGui")
	gui.Size = UDim2.new(2, 0, 1, 0)
	gui.Adornee = nil
	gui.StudsOffset = Vector3.new(0, 3, 0)
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "-" .. tostring(damage)
	label.TextColor3 = Color3.new(1, 0.2, 0.2)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.Parent = gui
	
	-- Create a part to attach the GUI to
	local part = Instance.new("Part")
	part.Size = Vector3.new(0.1, 0.1, 0.1)
	part.Position = position
	part.Anchored = true
	part.CanCollide = false
	part.Transparency = 1
	part.Parent = workspace
	
	gui.Adornee = part
	gui.Parent = workspace
	
	-- Animate
	local tween = TweenService:Create(part, 
		TweenInfo.new(CONFIG.DAMAGE_TEXT_LIFETIME, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
		{Position = position + Vector3.new(0, 8, 0)}
	)
	
	local fadeTween = TweenService:Create(label,
		TweenInfo.new(CONFIG.DAMAGE_TEXT_LIFETIME, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
		{TextTransparency = 1}
	)
	
	tween:Play()
	fadeTween:Play()
	
	-- Clean up
	Debris:AddItem(gui, CONFIG.DAMAGE_TEXT_LIFETIME)
	Debris:AddItem(part, CONFIG.DAMAGE_TEXT_LIFETIME)
end

-- Create hit effect on model
function VisualEffectsSystem._createHitEffect(model)
	if not model or not model.part then
		return
	end
	
	-- Flash red
	local originalColor = model.part.Color
	model.part.Color = Color3.new(1, 0.3, 0.3)
	
	-- Restore color after brief flash
	spawn(function()
		wait(CONFIG.HIT_EFFECT_DURATION)
		if model.part and model.part.Parent then
			model.part.Color = originalColor
		end
	end)
end

-- Create death effect
function VisualEffectsSystem._createDeathEffect(model)
	if not model or not model.part then
		return
	end
	
	-- Fade out the model
	local tween = TweenService:Create(model.part,
		TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
		{Transparency = 1}
	)
	
	tween:Play()
end

-- Update player positions for spatial partitioning
function VisualEffectsSystem._updatePlayerPositions()
	playerPositions = {}
	
	for _, player in pairs(game:GetService("Players"):GetPlayers()) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			table.insert(playerPositions, player.Character.HumanoidRootPart.Position)
		end
	end
end

-- Check if position is near any player
function VisualEffectsSystem._isNearPlayer(position)
	for _, playerPos in ipairs(playerPositions) do
		if (position - playerPos).Magnitude <= CONFIG.MAX_EFFECT_DISTANCE then
			return true
		end
	end
	return false
end

return VisualEffectsSystem ]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="78">
        <Properties>
          <string name="Name">NPCManager</string>
          <string name="Source"><![CDATA[-- NPCManager.luau
-- Handles NPC spawning and management on server

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local NPCManager = {}

-- Server-wide quest state
NPCManager.questActive = false
NPCManager.spawnedNPCs = {}

-- R6 Default Animation IDs
local R6_ANIMATIONS = {
	idle = "rbxassetid://180435571",
	walk = "rbxassetid://180426354",
	run = "rbxassetid://180426354", -- Same as walk for R6
}

-- Track NPC animations {[npcModel] = {animations = {}, currentAnim = nil, isMoving = false}}
NPCManager.npcAnimations = {}

-- ENHANCED: Track RunService connections for cleanup
NPCManager.followConnections = {} -- {[npcId] = connection}

-- NPC spawn positions (you can adjust these coordinates)
local spawnPositions = {
	wise_man = Vector3.new(0, 5, 0),
	trader = Vector3.new(20, 5, 0),
	regular_npc = Vector3.new(-20, 5, 0),
	princess = Vector3.new(0, 5, 30) -- Tower location
}

-- Create a simple NPC model
function NPCManager:CreateNPCModel(npcId)
	local ServerStorage = game:GetService("ServerStorage")
	local npcModelsFolder = ServerStorage:FindFirstChild("NPCModels")
	local template = npcModelsFolder and npcModelsFolder:FindFirstChild(npcId)
	
	-- Fallback to old PlayerModel system if specific model not found
	if not template then
		template = ServerStorage:FindFirstChild("PlayerModel")
		if not template then
			warn("No model found for NPC:", npcId)
			warn("Please add an R15 or R6 Dummy from the toolbox to ServerStorage and rename it to 'PlayerModel'")
			warn("This is required for NPCs to have proper animations!")
			
			-- Fallback: Create a basic model (but animations won't work)
			local model = Instance.new("Model")
			model.Name = npcId
			
			local part = Instance.new("Part")
			part.Name = "HumanoidRootPart"
			part.Size = Vector3.new(2, 5, 1)
			part.Position = spawnPositions[npcId]
			part.Anchored = true
			part.CanCollide = false
			part.Parent = model
			
			-- Add basic Humanoid (but no animations)
			local humanoid = Instance.new("Humanoid")
			humanoid.Parent = model
			
			warn("Created basic NPC without animations. Add PlayerModel template for full functionality!")
			return model
		end
	end
	
	-- Clone the player model template
	local model = template:Clone()
	model.Name = npcId
	
	-- Position the model
	if model:FindFirstChild("HumanoidRootPart") then
		model.HumanoidRootPart.Position = spawnPositions[npcId]
		model.HumanoidRootPart.Anchored = true
	end
	
	-- Ensure all NPCs have proper Humanoid setup for animations
	local humanoid = model:FindFirstChild("Humanoid")
	if humanoid then
		-- Configure Humanoid for proper NPC behavior
		humanoid.PlatformStand = false -- Allow normal movement
		humanoid.Sit = false -- Don't sit
		humanoid.WalkSpeed = 16 -- Default walking speed
		
		-- Ensure the Humanoid can use animations
		local animator = humanoid:FindFirstChild("Animator")
		if not animator then
			-- Create Animator if missing (needed for animations)
			animator = Instance.new("Animator")
			animator.Parent = humanoid
		end
		
		-- Load R6 animations for this NPC
		self:LoadNPCAnimations(model, humanoid, animator)
	else
		warn(npcId .. " model doesn't have a Humanoid! Make sure you're using an R15/R6 dummy as PlayerModel template.")
	end
	
	-- Special handling for Princess - configure existing Humanoid for mob behavior
	if npcId == "princess" then
		local humanoid = model:FindFirstChild("Humanoid")
		if humanoid then
			-- Configure the existing Humanoid (don't create a new one - this preserves animations)
			humanoid.MaxHealth = 100
			humanoid.Health = 100
			
			-- Handle death
			humanoid.Died:Connect(function()
				wait(2) -- Small delay before removal
				self:RemoveNPC("princess")
				print("Princess has been defeated!")
			end)
		else
			warn("Princess model doesn't have a Humanoid! Make sure you're using an R15/R6 dummy as PlayerModel template.")
		end
		
		-- Keep anchored initially so she doesn't fall before following
		model.HumanoidRootPart.Anchored = true
	end
	
	-- NPCs will use the default appearance from your PlayerModel template
	-- You can customize each NPC manually in Roblox Studio after they spawn
	
	-- Optional: Add accessories to NPCs
	self:AddNPCAccessories(model, npcId)
	
	-- Add ProximityPrompt to HumanoidRootPart
	local rootPart = model:FindFirstChild("HumanoidRootPart")
	if rootPart then
		local prompt = Instance.new("ProximityPrompt")
		prompt.ActionText = "" -- No text shown on prompt
		prompt.ObjectText = "" -- No object text shown
		prompt.MaxActivationDistance = 10
		prompt.RequiresLineOfSight = false
		prompt.HoldDuration = 0.5 -- Require 0.5 second hold
		prompt.Parent = rootPart
	end
	
	return model
end

-- Load R6 animations for an NPC
function NPCManager:LoadNPCAnimations(model, humanoid, animator)
	-- Create animation objects
	local idleAnim = Instance.new("Animation")
	idleAnim.AnimationId = R6_ANIMATIONS.idle
	
	local walkAnim = Instance.new("Animation")
	walkAnim.AnimationId = R6_ANIMATIONS.walk
	
	-- Load animations
	local animations = {}
	animations.idle = animator:LoadAnimation(idleAnim)
	animations.walk = animator:LoadAnimation(walkAnim)
	
	-- Initialize animation state
	local animState = {
		animations = animations,
		currentAnim = nil,
		isMoving = false
	}
	
	-- Store animation state
	self.npcAnimations[model] = animState
	
	-- Set up movement detection
	self:SetupMovementDetection(model, humanoid, animState)
	
	-- Start with idle animation
	self:PlayNPCAnimation(model, "idle")
	
	print("Loaded R6 animations for", model.Name)
end

-- Play animation for an NPC
function NPCManager:PlayNPCAnimation(model, animName)
	local animState = self.npcAnimations[model]
	if not animState or not animState.animations[animName] then
		return
	end
	
	-- Stop current animation
	if animState.currentAnim then
		animState.currentAnim:Stop()
	end
	
	-- Play new animation
	animState.currentAnim = animState.animations[animName]
	animState.currentAnim:Play()
	
	print(model.Name .. " playing " .. animName .. " animation")
end

-- Set up movement detection for animation triggers
function NPCManager:SetupMovementDetection(model, humanoid, animState)
	-- Detect when humanoid starts/stops moving
	humanoid.Running:Connect(function(speed)
		if speed > 0.1 and not animState.isMoving then
			-- Started moving
			animState.isMoving = true
			self:PlayNPCAnimation(model, "walk")
		elseif speed <= 0.1 and animState.isMoving then
			-- Stopped moving
			animState.isMoving = false
			self:PlayNPCAnimation(model, "idle")
		end
	end)
end

-- Clean up animations when NPC is removed
function NPCManager:CleanupNPCAnimations(model)
	local animState = self.npcAnimations[model]
	if animState then
		-- Stop current animation
		if animState.currentAnim then
			animState.currentAnim:Stop()
		end
		
		-- Clean up animation tracks
		for _, anim in pairs(animState.animations) do
			anim:Destroy()
		end
		
		-- Remove from tracking
		self.npcAnimations[model] = nil
		print("Cleaned up animations for", model.Name)
	end
end

-- Optional: Add accessories to NPCs
function NPCManager:AddNPCAccessories(model, npcId)
	local ServerStorage = game:GetService("ServerStorage")
	local accessoriesFolder = ServerStorage:FindFirstChild("NPCAccessories")
	
	if not accessoriesFolder then
		return -- No accessories folder, skip
	end
	
	local npcFolder = accessoriesFolder:FindFirstChild(npcId)
	if not npcFolder then
		return -- No accessories for this NPC
	end
	
	-- Add each accessory to the model
	for _, accessory in pairs(npcFolder:GetChildren()) do
		if accessory:IsA("Accessory") then
			local clonedAccessory = accessory:Clone()
			clonedAccessory.Parent = model
		end
	end
end

-- Spawn an NPC
function NPCManager:SpawnNPC(npcId)
	if self.spawnedNPCs[npcId] then
		print("NPC", npcId, "already spawned")
		return
	end
	
	local npcModel = self:CreateNPCModel(npcId)
	npcModel.Parent = workspace
	self.spawnedNPCs[npcId] = npcModel
	
	print("Spawned NPC:", npcId)
	return npcModel
end

-- Remove an NPC
function NPCManager:RemoveNPC(npcId)
	if self.spawnedNPCs[npcId] then
		-- Clean up RunService connections before destroying
		if self.followConnections[npcId] then
			self.followConnections[npcId]:Disconnect()
			self.followConnections[npcId] = nil
		end
		
		-- Clean up animations before destroying
		self:CleanupNPCAnimations(self.spawnedNPCs[npcId])
		
		self.spawnedNPCs[npcId]:Destroy()
		self.spawnedNPCs[npcId] = nil
	end
end

-- Cleanup method for all NPCs and connections
function NPCManager:Cleanup()
	-- Clean up all follow connections
	for npcId, connection in pairs(self.followConnections) do
		connection:Disconnect()
	end
	self.followConnections = {}
	
	-- Clean up all NPCs
	for npcId, npcModel in pairs(self.spawnedNPCs) do
		self:CleanupNPCAnimations(npcModel)
		npcModel:Destroy()
	end
	self.spawnedNPCs = {}
	
	-- Clear all state
	self.questActive = false
	self.npcAnimations = {}
end

-- Start the quest (spawn princess)
function NPCManager:StartQuest()
	if not self.questActive then
		self.questActive = true
		self:SpawnNPC("princess")
		print("Quest started! Princess spawned.")
		
		-- Notify all clients that quest is active
		RemoteEvents.ShowOverheadText:FireAllClients("wise_man", "A princess lies trapped by dark magic! Find her in the tower!")
	end
end

-- Make Princess follow a player
function NPCManager:MakePrincessFollow(player)
	local princess = self.spawnedNPCs["princess"]
	if not princess then return end
	
	-- Clean up any existing follow connection first
	if self.followConnections["princess"] then
		self.followConnections["princess"]:Disconnect()
		self.followConnections["princess"] = nil
	end
	
	-- Disable the ProximityPrompt
	local prompt = princess.HumanoidRootPart:FindFirstChild("ProximityPrompt")
	if prompt then
		prompt.Enabled = false
	end
	
	-- Enable physics for walking (unanchor)
	if princess.HumanoidRootPart then
		princess.HumanoidRootPart.Anchored = false
	end
	
	local humanoid = princess:FindFirstChild("Humanoid")
	if not humanoid then
		warn("Princess doesn't have a Humanoid - cannot follow!")
		return
	end
	
	-- Zone-based following system
	local currentZone = "inner" -- Track current zone
	local INNER_ZONE_RADIUS = 12 -- 0-12 studs: don't move
	
	-- Get player's walking speed to match it
	local function getPlayerWalkSpeed()
		if player.Character and player.Character:FindFirstChild("Humanoid") then
			return player.Character.Humanoid.WalkSpeed
		end
		return 16 -- Default fallback
	end
	
	-- Set initial princess speed to match player
	humanoid.WalkSpeed = getPlayerWalkSpeed()
	
	-- Zone-based movement behavior with connection tracking
	local connection
	connection = RunService.Heartbeat:Connect(function()
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and princess.HumanoidRootPart then
			local targetPos = player.Character.HumanoidRootPart.Position
			local currentPos = princess.HumanoidRootPart.Position
			local distance = (targetPos - currentPos).Magnitude
			
			-- Determine current zone
			local newZone
			if distance <= INNER_ZONE_RADIUS then
				newZone = "inner"
			else
				newZone = "follow"
			end
			
			-- Only act when zone changes or when in follow zone
			if newZone ~= currentZone or newZone == "follow" then
				if newZone == "inner" then
					-- Inner zone: Stop moving
					humanoid:MoveTo(currentPos) -- Move to current position (stops movement)
					print("Princess entered inner zone - stopping")
				elseif newZone == "follow" then
					-- Follow zone: Match player speed and move toward player
					humanoid.WalkSpeed = getPlayerWalkSpeed()
					humanoid:MoveTo(targetPos)
					if currentZone ~= newZone then
						print("Princess entered follow zone - following at speed", humanoid.WalkSpeed)
					end
				end
				
				currentZone = newZone
			end
		else
			-- Player left or died, clean up connection properly
			connection:Disconnect()
			self.followConnections["princess"] = nil
			print("Princess follow connection cleaned up - player left or died")
		end
	end)
	
	-- Store connection for cleanup
	self.followConnections["princess"] = connection
	
	print("Princess is now following", player.Name)
end

-- Enable Princess combat mode
function NPCManager:EnablePrincessCombat()
	local princess = self.spawnedNPCs["princess"]
	if not princess then return end
	
	-- DISABLE the ProximityPrompt so she can't be talked to in combat
	local prompt = princess.HumanoidRootPart:FindFirstChild("ProximityPrompt")
	if prompt then
		prompt.Enabled = false
	end
	
	-- Enable physics for combat (unanchor if not already)
	if princess.HumanoidRootPart then
		princess.HumanoidRootPart.Anchored = false
	end
	
	-- Humanoid already exists from spawn, just verify it's there
	local humanoid = princess:FindFirstChild("Humanoid")
	if not humanoid then
		warn("Princess doesn't have a Humanoid - combat mode may not work properly!")
		warn("Make sure you're using an R15/R6 dummy as PlayerModel template in ServerStorage!")
		return
	end
	
	print("Princess is now in combat mode!")
end

-- Initialize the system
function NPCManager:Initialize()
	-- Spawn initial NPCs (not princess)
	self:SpawnNPC("wise_man")
	self:SpawnNPC("trader")
	self:SpawnNPC("regular_npc")
	
	print("NPCManager initialized - 3 NPCs spawned")
end

return NPCManager ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="79">
        <Properties>
          <string name="Name">ProjectileManager</string>
          <string name="Source"><![CDATA[-- ProjectileManager.luau
-- Server-side projectile management system
-- Handles projectile logic, collision detection, and damage while clients handle visuals

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

local ProjectileManager = {}

-- Store active projectiles on server (logic only, no visual parts)
local activeProjectiles = {} -- {[projectileId] = {startPosition, targetPosition, direction, speed, damage, config, startTime, lifetime}}

-- Remote events for client communication
local ProjectileEvents = Instance.new("Folder")
ProjectileEvents.Name = "ProjectileEvents"
ProjectileEvents.Parent = ReplicatedStorage

local SpawnProjectileEvent = Instance.new("RemoteEvent")
SpawnProjectileEvent.Name = "SpawnProjectile"
SpawnProjectileEvent.Parent = ProjectileEvents

local DestroyProjectileEvent = Instance.new("RemoteEvent")
DestroyProjectileEvent.Name = "DestroyProjectile"
DestroyProjectileEvent.Parent = ProjectileEvents

local ProjectileHitEvent = Instance.new("RemoteEvent")
ProjectileHitEvent.Name = "ProjectileHit"
ProjectileHitEvent.Parent = ProjectileEvents

-- Import DamageSystem
local DamageSystem = require(script.Parent.Systems.DamageSystem)

-- Generate unique projectile ID
local projectileIdCounter = 0
local function generateProjectileId()
    projectileIdCounter = projectileIdCounter + 1
    return "projectile_" .. projectileIdCounter
end

-- Create projectile on server (logic only)
function ProjectileManager.createProjectile(startPosition, targetPosition, config)
    local projectileId = generateProjectileId()
    
    -- Calculate projectile trajectory
    local direction = (targetPosition - startPosition).Unit
    local distance = (targetPosition - startPosition).Magnitude
    local speed = config.speed or 70
    local travelTime = distance / speed
    
    -- Store projectile data (no visual part on server)
    activeProjectiles[projectileId] = {
        startPosition = startPosition,
        targetPosition = targetPosition,
        direction = direction,
        speed = speed,
        damage = config.damage or 15,
        config = config,
        startTime = tick(),
        lifetime = config.lifetime or 3,
        travelTime = travelTime
    }
    
    -- Tell all clients to create visual projectile
    SpawnProjectileEvent:FireAllClients(projectileId, startPosition, targetPosition, config)
    
    print("🚀 Server created projectile", projectileId, "from", startPosition, "to", targetPosition, "travel time:", math.floor(travelTime * 100) / 100, "s")
    
    -- Auto cleanup after lifetime
    task.delay(config.lifetime or 3, function()
        ProjectileManager.destroyProjectile(projectileId)
    end)
    
    return projectileId
end

-- Destroy projectile on server
function ProjectileManager.destroyProjectile(projectileId)
    if activeProjectiles[projectileId] then
        activeProjectiles[projectileId] = nil
        
        -- Tell all clients to destroy visual projectile
        DestroyProjectileEvent:FireAllClients(projectileId)
        
        print("🗑️ Server destroyed projectile", projectileId)
    end
end

-- Handle projectile hit (server-side collision detection)
function ProjectileManager.handleProjectileHit(projectileId, hitPosition, hitCharacter)
    local projectileData = activeProjectiles[projectileId]
    if not projectileData then
        return
    end
    
    local humanoid = hitCharacter:FindFirstChild("Humanoid")
    if humanoid and Players:GetPlayerFromCharacter(hitCharacter) then
        -- Hit a player - apply damage
        print("💥 Server: Projectile", projectileId, "hit player:", hitCharacter.Name)
        
        -- Apply damage using DamageSystem
        local damageAmount = projectileData.damage
        DamageSystem:ApplyDamage(humanoid, damageAmount, nil, "RangedEnemyProjectile")
        
        -- Check if this is a pirate buccaneer projectile and apply effects
        print("💥 DEBUG: Projectile config:", projectileData.config and projectileData.config.projectileType or "nil")
        if projectileData.config and projectileData.config.projectileType == "magic_bolt" then
            local player = Players:GetPlayerFromCharacter(hitCharacter)
            print("💥 DEBUG: Found player:", player and player.Name or "nil")
            print("💥 DEBUG: PlayerEffectsSystem available:", _G.PlayerEffectsSystem ~= nil)
            if player and _G.PlayerEffectsSystem then
                -- Apply slow effect (80% speed reduction for 1 second)
                _G.PlayerEffectsSystem:ApplySlowEffect(player, 1.0, 0.8)
                -- Apply jump disable effect for 1 second
                _G.PlayerEffectsSystem:ApplyJumpDisableEffect(player, 1.0)
                print("🐌🚫 Applied slow and jump disable effects to", player.Name, "from pirate buccaneer projectile")
            else
                print("💥 DEBUG: Failed to apply effects - player:", player ~= nil, "PlayerEffectsSystem:", _G.PlayerEffectsSystem ~= nil)
            end
        else
            print("💥 DEBUG: Not a magic_bolt projectile, skipping effects")
        end
        
        -- Tell all clients to create hit effect
        ProjectileHitEvent:FireAllClients(projectileId, hitPosition)
        
        -- Destroy projectile
        ProjectileManager.destroyProjectile(projectileId)
    end
end

-- Update projectile positions and check collisions
function ProjectileManager.updateProjectiles()
    local currentTime = tick()
    
    for projectileId, projectileData in pairs(activeProjectiles) do
        local elapsedTime = currentTime - projectileData.startTime
        
        -- Check if projectile has exceeded lifetime
        if elapsedTime >= projectileData.lifetime then
            ProjectileManager.destroyProjectile(projectileId)
        else
            -- Calculate current position based on time
            local progress = elapsedTime / projectileData.travelTime
            if progress >= 1 then
                -- Projectile reached target - destroy it
                ProjectileManager.destroyProjectile(projectileId)
            else
                local currentPosition = projectileData.startPosition + (projectileData.direction * projectileData.speed * elapsedTime)
                
                -- Check for player collisions by checking distance to all players
                for _, player in pairs(Players:GetPlayers()) do
                    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local playerPosition = player.Character.HumanoidRootPart.Position
                        local distanceToPlayer = (currentPosition - playerPosition).Magnitude
                        
                        -- If projectile is close enough to player (within 3 studs)
                        if distanceToPlayer <= 3 then
                            print("💥 Server: Projectile", projectileId, "hit player:", player.Name, "at distance:", distanceToPlayer)
                            ProjectileManager.handleProjectileHit(projectileId, currentPosition, player.Character)
                            break -- Only hit one player per projectile
                        end
                    end
                end
            end
        end
    end
end

-- Initialize server projectile system
function ProjectileManager.initialize()
    print("🚀 ProjectileManager: Initializing server-side projectile system")
    
    -- Start update loop
    RunService.Heartbeat:Connect(function()
        ProjectileManager.updateProjectiles()
    end)
    
    print("✅ ProjectileManager: Server projectile system initialized")
end

-- Clean up all server projectiles
function ProjectileManager.cleanup()
    for projectileId, _ in pairs(activeProjectiles) do
        ProjectileManager.destroyProjectile(projectileId)
    end
    activeProjectiles = {}
    print("🧹 ProjectileManager: Cleaned up all server projectiles")
end

return ProjectileManager ]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="80">
        <Properties>
          <string name="Name">SpawnerSetup</string>
          <string name="Source"><![CDATA[-- SpawnerSetup.luau
-- Bridge system that converts Studio-placed tagged parts into ECS spawner entities
-- Handles the migration from manual spawner creation to visual Studio-based placement

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

-- Import ECS modules
local EntityManager = require(ReplicatedStorage.Shared.EntityManager)

-- Import Components from our custom ECS (find ModuleScript specifically to avoid folder conflict)
local Components = nil
for _, child in ipairs(ReplicatedStorage.Shared:GetChildren()) do
    if child.Name == "EnemyComponents" and child.ClassName == "ModuleScript" then
        Components = require(child)
        break
    end
end

if not Components then
    error("SpawnerSetup: Could not find EnemyComponents ModuleScript")
end

local EnemyDefinitions = require(ReplicatedStorage.Shared.EnemyDefinitions)

local SpawnerSetup = {}

-- Configuration
local SPAWNER_TAG = "EnemySpawner"

-- Default values for missing attributes
local DEFAULT_VALUES = {
    SpawnerEnemies = "random",
    SpawnerCountMin = 1,
    SpawnerCountMax = 3,
    SpawnerRadius = 25,
    SpawnerCooldown = 15,
    SpawnerActivationRange = 60,
    SpawnerType = "once"  -- Default to one-time spawning
}

-- Parse enemy string into array format
-- Input: "goblin_warrior,skeleton_archer" or "random" or "melee_type_random"
-- Output: {"goblin_warrior", "skeleton_archer"} or {"random"} or {"melee_type_random"}
local function parseEnemyString(enemyString)
    if not enemyString or enemyString == "" then
        return {"random"}
    end
    
    -- Handle single entries (no commas)
    if not string.find(enemyString, ",") then
        return {enemyString}
    end
    
    -- Handle comma-separated list
    local enemies = {}
    for enemy in string.gmatch(enemyString, "([^,]+)") do
        -- Trim whitespace
        enemy = string.match(enemy, "^%s*(.-)%s*$")
        if enemy and enemy ~= "" then
            table.insert(enemies, enemy)
        end
    end
    
    return #enemies > 0 and enemies or {"random"}
end

-- Read and validate attributes from a part
local function readPartAttributes(part)
    local config = {}
    
    -- Read all attributes with defaults
    for attributeName, defaultValue in pairs(DEFAULT_VALUES) do
        local value = part:GetAttribute(attributeName)
        if value ~= nil then
            -- Type validation for numeric attributes
            if type(defaultValue) == "number" and type(value) ~= "number" then
                warn(string.format("⚠️ Part '%s' attribute '%s' should be number but got %s, using default: %s", 
                    part.Name, attributeName, type(value), tostring(defaultValue)))
                config[attributeName] = defaultValue
            elseif type(defaultValue) == "string" and type(value) ~= "string" then
                warn(string.format("⚠️ Part '%s' attribute '%s' should be string but got %s, using default: %s", 
                    part.Name, attributeName, type(value), tostring(defaultValue)))
                config[attributeName] = defaultValue
            else
                config[attributeName] = value
            end
        else
            config[attributeName] = defaultValue
            warn(string.format("⚠️ Part '%s' missing attribute '%s', using default: %s", 
                part.Name, attributeName, tostring(defaultValue)))
        end
    end
    
    return config
end

-- Validate enemy types against EnemyDefinitions
local function validateEnemyTypes(enemies)
    local validEnemies = {}
    
    for _, enemy in ipairs(enemies) do
        if enemy == "random" or 
           enemy:match("^%w+_type_random$") or 
           EnemyDefinitions:GetEnemy(enemy) then
            table.insert(validEnemies, enemy)
        else
            warn(string.format("⚠️ Unknown enemy type '%s', will fallback to random", enemy))
            table.insert(validEnemies, "random")
        end
    end
    
    return #validEnemies > 0 and validEnemies or {"random"}
end

-- Convert a single tagged part into a spawner entity
local function convertPartToSpawner(part)
    -- Read attributes from the part
    local config = readPartAttributes(part)
    
    -- Parse enemy string into array
    local enemies = parseEnemyString(config.SpawnerEnemies)
    enemies = validateEnemyTypes(enemies)
    
    -- Validate spawn type
    local spawnType = config.SpawnerType
    if spawnType ~= "once" and spawnType ~= "continuous" then
        warn(string.format("⚠️ Invalid SpawnerType '%s' for part '%s', using default 'once'", 
            tostring(spawnType), part.Name))
        spawnType = "once"
    end
    
    -- Create spawner entity
    local spawnerId = EntityManager.createEntity()
    
    -- Create Spawner component with part data
    local spawnerComponent = Components.create("Spawner", {
        enemies = enemies,
        countRange = {
            min = math.max(1, config.SpawnerCountMin),
            max = math.max(config.SpawnerCountMin, config.SpawnerCountMax)
        },
        radius = math.max(1, config.SpawnerRadius),
        cooldown = math.max(1, config.SpawnerCooldown),
        lastSpawnTime = 0,
        spawnedEntities = {},
        centerPosition = part.Position,
        activationRange = math.max(10, config.SpawnerActivationRange),
        spawnType = spawnType,
        hasSpawned = false
    })
    
    -- Add component to entity
    EntityManager.addComponent(spawnerId, "Spawner", spawnerComponent)
    
    -- Log successful conversion
    print(string.format("✅ Converted part '%s' to spawner entity %d", part.Name, spawnerId))
    print(string.format("   Position: %s", tostring(part.Position)))
    print(string.format("   Enemies: %s", table.concat(enemies, ", ")))
    print(string.format("   Count: %d-%d, Radius: %d, Cooldown: %ds, Type: %s", 
        spawnerComponent.countRange.min, 
        spawnerComponent.countRange.max,
        spawnerComponent.radius,
        spawnerComponent.cooldown,
        spawnerComponent.spawnType))
    
    return spawnerId
end

-- Scan workspace for all tagged spawner parts
function SpawnerSetup.scanForSpawnerParts()
    local taggedParts = CollectionService:GetTagged(SPAWNER_TAG)
    
    print(string.format("🔍 SpawnerSetup: Found %d parts with tag '%s'", #taggedParts, SPAWNER_TAG))
    
    for i, part in ipairs(taggedParts) do
        print(string.format("   %d. %s at %s", i, part.Name, tostring(part.Position)))
    end
    
    return taggedParts
end

-- Convert all tagged parts to spawner entities
function SpawnerSetup.convertAllTaggedParts()
    local taggedParts = SpawnerSetup.scanForSpawnerParts()
    local spawnerEntities = {}
    
    for _, part in ipairs(taggedParts) do
        local success, result = pcall(function()
            return convertPartToSpawner(part)
        end)
        
        if success then
            table.insert(spawnerEntities, result)
        else
            warn(string.format("❌ Failed to convert part '%s': %s", part.Name, tostring(result)))
        end
    end
    
    print(string.format("✅ Successfully converted %d/%d tagged parts to spawner entities", 
        #spawnerEntities, #taggedParts))
    
    return spawnerEntities
end

-- Create fallback spawners if no tagged parts found (backwards compatibility)
function SpawnerSetup.createFallbackSpawners()
    print("🔄 No tagged parts found, creating fallback spawners...")
    
    local fallbackConfigs = {
        {pos = Vector3.new(0, 0, 100), enemies = {"random"}, radius = 25},
        {pos = Vector3.new(100, 0, 0), enemies = {"random"}, radius = 25},
        {pos = Vector3.new(-100, 0, 0), enemies = {"random"}, radius = 25},
        {pos = Vector3.new(0, 0, -100), enemies = {"random"}, radius = 25}
    }
    
    local spawnerEntities = {}
    
    for i, config in ipairs(fallbackConfigs) do
        local spawnerId = EntityManager.createEntity()
        
        EntityManager.addComponent(spawnerId, "Spawner", Components.create("Spawner", {
            enemies = config.enemies,
            countRange = {min = 2, max = 4},
            radius = config.radius,
            cooldown = 10,
            lastSpawnTime = 0,
            spawnedEntities = {},
            centerPosition = config.pos,
            activationRange = 60,
            spawnType = "continuous",  -- Fallback spawners use continuous for backwards compatibility
            hasSpawned = false
        }))
        
        table.insert(spawnerEntities, spawnerId)
        print(string.format("✅ Created fallback spawner %d at %s", i, tostring(config.pos)))
    end
    
    return spawnerEntities
end

-- Main initialization function
function SpawnerSetup.initializeAllSpawners()
    print("🎯 SpawnerSetup: Initializing spawner system...")
    
    -- Wait a moment for workspace to be fully loaded
    if RunService:IsStudio() then
        wait(0.1) -- Small delay in Studio for parts to load
    end
    
    -- Try to convert tagged parts first
    local spawnerEntities = SpawnerSetup.convertAllTaggedParts()
    
    -- If no tagged parts found, create fallback spawners
    if #spawnerEntities == 0 then
        spawnerEntities = SpawnerSetup.createFallbackSpawners()
    end
    
    print(string.format("🎯 SpawnerSetup: Initialization complete with %d spawners", #spawnerEntities))
    
    return spawnerEntities
end

-- Debug function to list all current spawner entities
function SpawnerSetup.debugListSpawners()
    local spawnerEntities = EntityManager.getEntitiesWith("Spawner")
    
    print(string.format("🔍 Debug: Found %d spawner entities:", #spawnerEntities))
    
    for i, entityId in ipairs(spawnerEntities) do
        local spawner = EntityManager.getComponent(entityId, "Spawner")
        if spawner then
            print(string.format("   %d. Entity %d at %s", 
                i, entityId, tostring(spawner.centerPosition)))
            print(string.format("      Enemies: %s", table.concat(spawner.enemies, ", ")))
        end
    end
end

return SpawnerSetup ]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="81">
        <Properties>
          <string name="Name">Systems</string>
        </Properties>
        <Item class="ModuleScript" referent="82">
          <Properties>
            <string name="Name">AltarSystem</string>
            <string name="Source"><![CDATA[-- AltarSystem.luau
-- Main altar management system for healing altars

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

local AltarConfig = require(ReplicatedStorage.Shared.AltarConfig)
local SacrificeData = require(ReplicatedStorage.Shared.SacrificeData)
local RewardConfig = require(ReplicatedStorage.Shared.RewardConfig)

local AltarSystem = {}

-- Track all altars and their sacrifice data
local altars = {} -- [altar] = SacrificeTracker

-- Track prayer figures
local prayerFigures = {} -- [figure] = altar

function AltarSystem:Initialize()
    print("Initializing AltarSystem...")
    
    -- Find existing altars
    self:ScanForAltars()
    
    -- Find existing prayer figures
    self:ScanForPrayerFigures()
    
    -- Listen for new altars
    CollectionService:GetInstanceAddedSignal("Altar"):Connect(function(altar)
        self:RegisterAltar(altar)
    end)
    
    -- Listen for altar removal
    CollectionService:GetInstanceRemovedSignal("Altar"):Connect(function(altar)
        self:UnregisterAltar(altar)
    end)
    
    -- Listen for new prayer figures
    CollectionService:GetInstanceAddedSignal("Prayer"):Connect(function(figure)
        self:RegisterPrayerFigure(figure)
    end)
    
    -- Listen for prayer figure removal
    CollectionService:GetInstanceRemovedSignal("Prayer"):Connect(function(figure)
        self:UnregisterPrayerFigure(figure)
    end)
    
    print("AltarSystem initialized")
end

-- Scan workspace for existing altars
function AltarSystem:ScanForAltars()
    local taggedAltars = CollectionService:GetTagged("Altar")
    for _, altar in ipairs(taggedAltars) do
        self:RegisterAltar(altar)
    end
    print("Found", #taggedAltars, "existing altars")
end

-- Scan workspace for existing prayer figures
function AltarSystem:ScanForPrayerFigures()
    local taggedFigures = CollectionService:GetTagged("Prayer")
    for _, figure in ipairs(taggedFigures) do
        self:RegisterPrayerFigure(figure)
    end
    print("Found", #taggedFigures, "existing prayer figures")
end

-- Register a new altar
function AltarSystem:RegisterAltar(altar)
    if altars[altar] then
        return -- Already registered
    end
    
    -- Create sacrifice tracker for this altar
    local tracker = SacrificeData.SacrificeTracker.new()
    tracker.altar = altar
    altars[altar] = tracker
    
    -- Set up contact detection
    self:SetupContactDetection(altar, tracker)
    
    print("Registered altar:", altar:GetFullName())
end

-- Unregister an altar
function AltarSystem:UnregisterAltar(altar)
    if altars[altar] then
        altars[altar] = nil
        print("Unregistered altar:", altar:GetFullName())
    end
end

-- Register a new prayer figure
function AltarSystem:RegisterPrayerFigure(figure)
    if prayerFigures[figure] then
        return -- Already registered
    end
    
    -- Get the position of the prayer figure (handle both parts and models)
    local figurePosition
    if figure:IsA("Model") then
        -- For models, use the primary part or first part
        local primaryPart = figure.PrimaryPart
        if primaryPart then
            figurePosition = primaryPart.Position
        else
            -- Find first part in the model
            for _, child in ipairs(figure:GetChildren()) do
                if child:IsA("BasePart") then
                    figurePosition = child.Position
                    break
                end
            end
        end
    else
        -- For parts, use the part position directly
        figurePosition = figure.Position
    end
    
    if not figurePosition then
        print("Could not determine position for prayer figure:", figure:GetFullName())
        return
    end
    
    -- Find the closest altar to associate with this prayer figure
    local closestAltar = self:FindClosestAltar(figurePosition)
    if closestAltar then
        prayerFigures[figure] = closestAltar
        local tracker = altars[closestAltar]
        if tracker then
            tracker:setPrayerFigure(figure)
        end
        print("Registered prayer figure:", figure:GetFullName(), "for altar:", closestAltar:GetFullName())
    else
        print("No altar found for prayer figure:", figure:GetFullName())
    end
end

-- Unregister a prayer figure
function AltarSystem:UnregisterPrayerFigure(figure)
    if prayerFigures[figure] then
        prayerFigures[figure] = nil
        print("Unregistered prayer figure:", figure:GetFullName())
    end
end

-- Find the closest altar to a position
function AltarSystem:FindClosestAltar(position)
    local closestAltar = nil
    local closestDistance = math.huge
    
    for altar, _ in pairs(altars) do
        local distance = (altar.Position - position).Magnitude
        if distance < closestDistance then
            closestDistance = distance
            closestAltar = altar
        end
    end
    
    return closestAltar
end

-- Set up contact detection for an altar
function AltarSystem:SetupContactDetection(altar, tracker)
    -- Listen for parts touching the altar
    altar.Touched:Connect(function(hitPart)
        self:OnPartTouchedAltar(hitPart, altar, tracker)
    end)
    
    -- Listen for parts leaving the altar
    altar.TouchEnded:Connect(function(hitPart)
        self:OnPartLeftAltar(hitPart, altar, tracker)
    end)
end

-- Handle when a part touches the altar
function AltarSystem:OnPartTouchedAltar(hitPart, altar, tracker)
    -- Check if the touching part is a sacrifice ragdoll
    if self:IsValidSacrifice(hitPart) then
        -- Get the actual sacrifice object (whole ragdoll, not individual parts)
        local sacrificeObject = self:GetSacrificeObject(hitPart)
        if sacrificeObject then
            -- Check if it's a player sacrifice
            if CollectionService:HasTag(sacrificeObject, "PlayerSacrifice") then
                local added = tracker:addPlayerSacrifice(sacrificeObject)
                if added then
                    print("Player sacrifice added to altar:", sacrificeObject.Name)
                    self:CheckAltarTrigger(altar, tracker)
                end
            else
                -- Regular enemy sacrifice
                local added = tracker:addSacrifice(sacrificeObject)
                if added then
                    print("Sacrifice added to altar:", sacrificeObject.Name)
                    self:CheckAltarTrigger(altar, tracker)
                end
            end
        end
    end
end

-- Handle when a part leaves the altar
function AltarSystem:OnPartLeftAltar(hitPart, altar, tracker)
    -- Check if the leaving part is a sacrifice ragdoll
    if self:IsValidSacrifice(hitPart) then
        -- Get the actual sacrifice object (whole ragdoll, not individual parts)
        local sacrificeObject = self:GetSacrificeObject(hitPart)
        if sacrificeObject then
            -- Check if it's a player sacrifice
            if CollectionService:HasTag(sacrificeObject, "PlayerSacrifice") then
                tracker:removePlayerSacrifice(sacrificeObject)
                print("Player sacrifice removed from altar:", sacrificeObject.Name)
            else
                -- Regular enemy sacrifice
                tracker:removeSacrifice(sacrificeObject)
                print("Sacrifice removed from altar:", sacrificeObject.Name)
            end
        end
    end
end

-- Check if a part is a valid sacrifice
function AltarSystem:IsValidSacrifice(part)
    -- Check if the part or its parent has the "Sacrifice" tag
    if CollectionService:HasTag(part, "Sacrifice") then
        return true
    end
    
    -- Check if parent is a sacrifice (for model parts)
    if part.Parent and CollectionService:HasTag(part.Parent, "Sacrifice") then
        return true
    end
    
    -- Check if the part or its parent has the "PlayerSacrifice" tag
    if CollectionService:HasTag(part, "PlayerSacrifice") then
        return true
    end
    
    -- Check if parent is a player sacrifice (for model parts)
    if part.Parent and CollectionService:HasTag(part.Parent, "PlayerSacrifice") then
        return true
    end
    
    return false
end

-- Get the actual sacrifice object (handles model parts)
function AltarSystem:GetSacrificeObject(part)
    -- If the part itself is tagged, return it
    if CollectionService:HasTag(part, "Sacrifice") then
        return part
    end
    
    -- If the parent is tagged, return the parent
    if part.Parent and CollectionService:HasTag(part.Parent, "Sacrifice") then
        return part.Parent
    end
    
    -- If the part itself is player sacrifice tagged, return it
    if CollectionService:HasTag(part, "PlayerSacrifice") then
        return part
    end
    
    -- If the parent is player sacrifice tagged, return the parent
    if part.Parent and CollectionService:HasTag(part.Parent, "PlayerSacrifice") then
        return part.Parent
    end
    
    return nil
end

-- Check if altar should trigger reward
function AltarSystem:CheckAltarTrigger(altar, tracker)
    -- Check if altar is on cooldown
    if tracker:isOnCooldown() then
        print("Altar on cooldown, skipping trigger")
        return
    end
    
    -- Check if we have enough sacrifices
    if tracker:hasEnoughSacrifices() then
        print("Altar has enough sacrifices, ready for prayer!")
        -- Don't trigger reward automatically - wait for prayer
    end
end

-- Trigger the reward for an altar
function AltarSystem:TriggerReward(altar, tracker)
    -- Get the reward processor
    local RewardProcessor = require(script.Parent.RewardProcessor)
    
    -- Get all sacrifices (both enemy and player)
    local sacrifices = tracker:getSacrifices()
    local playerSacrifices = tracker:getPlayerSacrifices()
    
    -- Combine all sacrifices for cleanup
    for _, sacrifice in ipairs(playerSacrifices) do
        table.insert(sacrifices, sacrifice)
    end
    
    -- Check if there are any player sacrifices
    local hasPlayerSacrifices = tracker:hasPlayerSacrifices()
    
    -- Spawn reward
    local success = RewardProcessor:SpawnReward(altar, sacrifices, hasPlayerSacrifices)
    
    if success then
        -- Set trigger time for cooldown
        tracker:setTriggerTime()
        
        -- Clear sacrifices
        tracker:clearSacrifices()
        
        print("Reward triggered successfully for altar:", altar:GetFullName())
    else
        print("Failed to spawn reward for altar:", altar:GetFullName())
    end
end

-- Get all registered altars
function AltarSystem:GetAltars()
    return altars
end

-- Get tracker for a specific altar
function AltarSystem:GetTracker(altar)
    return altars[altar]
end

-- Handle prayer to figure
function AltarSystem:HandlePrayer(player, figure)
    local altar = prayerFigures[figure]
    if not altar then
        print("No altar associated with prayer figure")
        return false, "No altar found"
    end
    
    local tracker = altars[altar]
    if not tracker then
        print("No tracker found for altar")
        return false, "Altar not found"
    end
    
    -- Check if altar has enough sacrifices
    if not tracker:hasEnoughSacrifices() then
        print("Not enough sacrifices for prayer")
        return false, "Not enough sacrifices"
    end
    
    -- Check if altar is on cooldown
    if tracker:isOnCooldown() then
        print("Altar on cooldown")
        return false, "Altar on cooldown"
    end
    
    -- Set prayer state and trigger reward
    tracker:setPrayed(true)
    print("Player", player.Name, "prayed to figure, triggering reward!")
    self:TriggerReward(altar, tracker)
    
    return true, "Prayer successful"
end

-- Get prayer figure for an altar
function AltarSystem:GetPrayerFigure(altar)
    for figure, associatedAltar in pairs(prayerFigures) do
        if associatedAltar == altar then
            return figure
        end
    end
    return nil
end

return AltarSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="83">
          <Properties>
            <string name="Name">ArmorServerSystem</string>
            <string name="Source"><![CDATA[-- Server-side armor system (independent from InventoryServerSystem)
local ArmorServerSystem = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)
local ECS = require(ReplicatedStorage.Shared.ECS)
local Categories = require(ReplicatedStorage.Shared.ItemCategory)

local InventoryServerSystem = require(script.Parent.InventoryServerSystem)

-- Player armor storage (server-side, separate from inventory)
local playerArmor = {}

function ArmorServerSystem:Initialize()
    -- Handle armor requests (separate from inventory requests)
    RemoteEvents.ArmorRequest.OnServerInvoke = function(player, action, ...)
        return self:HandleArmorRequest(player, action, ...)
    end
    
    -- Initialize empty armor for existing players
    for _, player in pairs(Players:GetPlayers()) do
        self:InitializePlayerArmor(player)
    end
    
    -- Initialize for new players
    Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerArmor(player)
    end)
    
    -- Clean up when players leave
    Players.PlayerRemoving:Connect(function(player)
        self:CleanupPlayerArmor(player)
    end)
    
    print("Armor server system initialized")
end

function ArmorServerSystem:InitializePlayerArmor(player)
    playerArmor[player] = {
        helmet = nil,
        chestplate = nil,
        boots = nil
    }
    
    print("Initialized armor for player:", player.Name)
end

function ArmorServerSystem:CleanupPlayerArmor(player)
    -- Drop any equipped armor back to world
    if playerArmor[player] then
        for armorSlot, armorItem in pairs(playerArmor[player]) do
            if armorItem then
                self:DropArmorToWorld(player, armorItem.object)
            end
        end
    end
    
    playerArmor[player] = nil
end

function ArmorServerSystem:HandleArmorRequest(player, action, ...)
    local args = {...}
    
    if action == "equip_armor" then
        local armorSlot, hotbarItem = args[1], args[2]
        return self:EquipArmor(player, armorSlot, hotbarItem)
    elseif action == "unequip_armor" then
        local armorSlot = args[1]
        return self:UnequipArmor(player, armorSlot)
    else
        warn("Unknown armor action:", action)
        return false, "Unknown action"
    end
end

function ArmorServerSystem:EquipArmor(player, armorSlot, hotbarItem)
    -- Validate armor slot
    if not self:IsValidArmorSlot(armorSlot) then
        return false, "Invalid armor slot"
    end
    
    -- Check if armor slot is already occupied
    if playerArmor[player][armorSlot] then
        return false, "Armor slot already occupied"
    end
    
    -- Validate hotbar item
    if not hotbarItem or not hotbarItem.object then
        return false, "Invalid hotbar item"
    end
    
    -- Validate that item is compatible armor
    local itemDef = ItemDefinitions:GetItem(hotbarItem.itemId)
    
    if not itemDef then
        return false, "Item definition not found"
    end
    
    if itemDef.category ~= Categories.Armor then
        return false, "Item is not armor"
    end
    
    if itemDef.armorSlot ~= armorSlot then
        return false, "Item is not compatible armor"
    end

    -- Validate that player can equip this item (distance check)
    -- IMPORTANT: Skip distance check if item is already in ReplicatedStorage (i.e., in inventory)
    if hotbarItem.object.Parent ~= ReplicatedStorage then
        local canEquip = self:CanPlayerEquipItem(player, hotbarItem.object)
        
        if not canEquip then
            return false, "Player cannot equip this item"
        end
    end
    
    -- Store armor information
    local armorInfo = {
        object = hotbarItem.object,
        itemName = hotbarItem.itemName,
        itemId = hotbarItem.itemId,
        originalCFrame = hotbarItem.object.CFrame,
        originalParent = hotbarItem.object.Parent
    }
    
    -- Equip armor (move to ReplicatedStorage for safekeeping)
    playerArmor[player][armorSlot] = armorInfo
    hotbarItem.object.Parent = ReplicatedStorage
    hotbarItem.object.Anchored = true

    InventoryServerSystem:RemoveItemByObject(player, hotbarItem.object)

    return true, "Successfully equipped armor"
end

function ArmorServerSystem:UnequipArmor(player, armorSlot)
    -- Validate armor slot
    if not self:IsValidArmorSlot(armorSlot) then
        return false, "Invalid armor slot"
    end
    
    -- Check if armor slot has item
    local armorItem = playerArmor[player][armorSlot]
    if not armorItem then
        return false, "Armor slot is empty"
    end
    
    -- Validate armor object
    if not armorItem.object or not armorItem.object.Parent then
        return false, "Armor object is invalid"
    end
    
    -- Instead of dropping to world, store back into player's inventory

    local success, slotOrMsg = InventoryServerSystem:AddItemToFirstEmptySlot(player, armorItem.object)

    if not success then
        -- If inventory full, fallback to world drop (maintain previous behaviour)
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = character.HumanoidRootPart
            local spawnPosition = humanoidRootPart.CFrame * CFrame.new(0, 0, -3)
            armorItem.object.Parent = workspace
            armorItem.object.CFrame = spawnPosition
            armorItem.object.Anchored = false
        else
            armorItem.object.Parent = workspace
            armorItem.object.CFrame = CFrame.new(0, 10, 0)
            armorItem.object.Anchored = false
        end
        
        -- WorldCleanupSystem removed - no longer needed
        
        playerArmor[player][armorSlot] = nil
        return true, "Inventory full - dropped to world"
    end

    -- Successfully placed back into inventory
    playerArmor[player][armorSlot] = nil
    return true, "Returned to inventory slot " .. tostring(slotOrMsg)
end

function ArmorServerSystem:IsValidArmorSlot(armorSlot)
    return armorSlot == "helmet" or armorSlot == "chestplate" or armorSlot == "boots"
end

function ArmorServerSystem:CanPlayerEquipItem(player, object)
    -- Check if player is close enough to the item
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local humanoidRootPart = character.HumanoidRootPart
    local distance = (humanoidRootPart.Position - object.Position).Magnitude
    
    -- Use same distance limit as inventory system (15 studs)
    return distance <= 15
end

function ArmorServerSystem:DropArmorToWorld(player, armorObject)
    -- Helper function to drop armor back to world when player leaves
    if not armorObject or not armorObject.Parent then
        return
    end
    
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        local dropPosition = humanoidRootPart.CFrame * CFrame.new(0, 0, -3)
        
        armorObject.Parent = workspace
        armorObject.CFrame = dropPosition
        armorObject.Anchored = false
    else
        -- If no character, just drop at world origin
        armorObject.Parent = workspace
        armorObject.CFrame = CFrame.new(0, 10, 0)
        armorObject.Anchored = false
    end
    
    -- WorldCleanupSystem removed - no longer needed
end

-- Public methods for other systems
function ArmorServerSystem:GetPlayerArmor(player)
    return playerArmor[player] or {}
end

function ArmorServerSystem:IsArmorSlotOccupied(player, armorSlot)
    return playerArmor[player] and playerArmor[player][armorSlot] ~= nil
end

return ArmorServerSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="84">
          <Properties>
            <string name="Name">DamageSystem</string>
            <string name="Source"><![CDATA[-- Server-side damage system for handling weapon damage
local DamageSystem = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)
local Categories = require(ReplicatedStorage.Shared.ItemCategory)

-- Anti-cheat configuration
local DAMAGE_CONFIG = {
    MAX_DAMAGE_DISTANCE = 10, -- Maximum distance player can be from target
    DAMAGE_COOLDOWN = 0.1, -- Minimum time between damage applications per player
    MAX_DAMAGE_PER_HIT = 50, -- Maximum damage that can be applied in one hit
}

-- Track last damage time per player for cooldown
local lastDamageTime = {}

function DamageSystem:Initialize()
    -- Handle damage requests from clients
    RemoteEvents.ApplyDamage.OnServerEvent:Connect(function(player, targetPart, weaponName, damageAmount)
        self:ProcessDamageRequest(player, targetPart, weaponName, damageAmount)
    end)
    
    -- Clean up tracking when players leave
    Players.PlayerRemoving:Connect(function(player)
        lastDamageTime[player] = nil
    end)
    
    print("DamageSystem initialized")
end

function DamageSystem:ProcessDamageRequest(player, targetPart, weaponName, damageAmount)
    -- Validate player
    if not player or not player.Character then
        warn("DamageSystem: Invalid player or no character")
        return
    end
    
    -- Validate target
    if not targetPart or not targetPart.Parent then
        warn("DamageSystem: Invalid target part")
        return
    end
    
    -- Anti-cheat: Check cooldown
    local currentTime = tick()
    if lastDamageTime[player] and (currentTime - lastDamageTime[player]) < DAMAGE_CONFIG.DAMAGE_COOLDOWN then
        warn("DamageSystem: Player", player.Name, "is attacking too fast (cooldown)")
        return
    end
    
    -- Anti-cheat: Validate damage amount
    if damageAmount > DAMAGE_CONFIG.MAX_DAMAGE_PER_HIT or damageAmount <= 0 then
        warn("DamageSystem: Invalid damage amount", damageAmount, "from player", player.Name)
        return
    end
    
    -- Anti-cheat: Validate weapon and damage match
    if not self:ValidateWeaponDamage(player, weaponName, damageAmount) then
        warn("DamageSystem: Weapon damage mismatch for player", player.Name)
        return
    end
    
    -- Anti-cheat: Check distance
    if not self:ValidateDistance(player, targetPart) then
        warn("DamageSystem: Player", player.Name, "is too far from target")
        return
    end
    
    -- Find target with Humanoid
    local targetHumanoid = self:FindTargetHumanoid(targetPart)
    if not targetHumanoid then
        print("DamageSystem: Target has no Humanoid, cannot take damage")
        return
    end
    -- Prevent damage to dead players
    local targetPlayer = Players:GetPlayerFromCharacter(targetHumanoid.Parent)
    if targetPlayer then
        local CollectionService = game:GetService("CollectionService")
        print("[DamageSystem] Checking Dead tag for player:", targetPlayer.Name, CollectionService:HasTag(targetPlayer, "Dead"))
        if CollectionService:HasTag(targetPlayer, "Dead") then
            print("DamageSystem: Player ", targetPlayer.Name, " is dead, ignoring damage.")
            return
        end
    end
    
    -- Apply damage
    self:ApplyDamage(targetHumanoid, damageAmount, player, weaponName)
    
    -- Update cooldown
    lastDamageTime[player] = currentTime
end

function DamageSystem:ValidateWeaponDamage(player, weaponName, damageAmount)
    -- Check if player has the weapon equipped
    local character = player.Character
    if not character then return false end
    
    local equippedTool = character:FindFirstChildOfClass("Tool")
    if not equippedTool then
        warn("DamageSystem: Player has no tool equipped")
        return false
    end
    
    -- Check if tool name matches
    if equippedTool.Name ~= weaponName then
        warn("DamageSystem: Tool name mismatch -", equippedTool.Name, "vs", weaponName)
        return false
    end
    
    -- Get item definition and validate damage
    local itemKey = string.lower(weaponName)
    local itemDef = ItemDefinitions:GetItem(itemKey)
    
    if not itemDef then
        warn("DamageSystem: No item definition for weapon", weaponName)
        return false
    end
    
    if itemDef.category ~= Categories.Tool then
        warn("DamageSystem: Item is not a tool category")
        return false
    end
    
    local baseDamage = itemDef.actionData and itemDef.actionData.damage or 10
    local chargeMultiplier = itemDef.actionData and itemDef.actionData.chargeMultiplier or 1.0
    local criticalMultiplier = itemDef.actionData and itemDef.actionData.criticalMultiplier or 3.0
    
    -- Calculate expected damage ranges
    local expectedNormalDamage = baseDamage
    local expectedChargedDamage = math.floor(baseDamage * chargeMultiplier)
    local expectedCriticalDamage = math.floor(baseDamage * criticalMultiplier)
    
    -- Check if damage matches normal, charged, or critical attack
    local isNormalAttack = math.abs(damageAmount - expectedNormalDamage) <= 0.1
    local isChargedAttack = math.abs(damageAmount - expectedChargedDamage) <= 0.1
    local isCriticalAttack = math.abs(damageAmount - expectedCriticalDamage) <= 0.1
    
    if not isNormalAttack and not isChargedAttack and not isCriticalAttack then
        warn("DamageSystem: Damage mismatch -", damageAmount, "vs expected normal", expectedNormalDamage, "charged", expectedChargedDamage, "or critical", expectedCriticalDamage)
        return false
    end
    
    -- Log the attack type for debugging
    if isCriticalAttack then
        print("DamageSystem: Validated CRITICAL attack -", damageAmount, "damage")
    elseif isChargedAttack then
        print("DamageSystem: Validated CHARGED attack -", damageAmount, "damage")
    else
        print("DamageSystem: Validated normal attack -", damageAmount, "damage")
    end
    
    return true
end

function DamageSystem:ValidateDistance(player, targetPart)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local playerPosition = character.HumanoidRootPart.Position
    local targetPosition = targetPart.Position
    
    local distance = (playerPosition - targetPosition).Magnitude
    
    return distance <= DAMAGE_CONFIG.MAX_DAMAGE_DISTANCE
end

function DamageSystem:FindTargetHumanoid(targetPart)
    -- First check if the part itself is a Humanoid
    if targetPart:IsA("Humanoid") then
        return targetPart
    end
    
    -- Check if the part's parent has a Humanoid
    local parent = targetPart.Parent
    if parent then
        local humanoid = parent:FindFirstChild("Humanoid")
        if humanoid then
            return humanoid
        end
    end
    
    -- Check if the part is part of a character model
    -- Look for Humanoid in the model hierarchy
    local model = targetPart.Parent
    while model and model ~= workspace do
        local humanoid = model:FindFirstChild("Humanoid")
        if humanoid then
            return humanoid
        end
        model = model.Parent
    end
    
    return nil
end

function DamageSystem:ApplyDamage(humanoid, damageAmount, attacker, weaponName)
    -- Check if target is already dead
    if humanoid.Health <= 0 then
        return
    end
    
    -- Apply damage
    local newHealth = math.max(0, humanoid.Health - damageAmount)
    humanoid.Health = newHealth
    
    -- Get target name for logging
    local targetName = "Unknown"
    if humanoid.Parent then
        targetName = humanoid.Parent.Name
    end
    
    print("DamageSystem: Applied", damageAmount, "damage to", targetName, "with", weaponName)
    print("  - Health:", humanoid.Health .. "/" .. humanoid.MaxHealth)
    
    -- Audio is now handled client-side in ToolSystem
    
    if newHealth <= 0 then
        print("DamageSystem:", targetName, "has been defeated by", attacker.Name)
        -- The Humanoid.Died event will be handled by the target's own systems
    end
end



-- Public methods for other systems
function DamageSystem:GetDamageConfig()
    return DAMAGE_CONFIG
end

function DamageSystem:IsPlayerOnCooldown(player)
    if not lastDamageTime[player] then return false end
    return (tick() - lastDamageTime[player]) < DAMAGE_CONFIG.DAMAGE_COOLDOWN
end

return DamageSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="85">
          <Properties>
            <string name="Name">DragServerSystem</string>
            <string name="Source"><![CDATA[-- Server-side drag system for handling network ownership
local DragServerSystem = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Track which objects are being dragged by which players
local draggedObjects = {}

function DragServerSystem:Initialize()
    -- Wait for and get remote events
    local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
    
    -- Handle drag requests from clients
    RemoteEvents.DragRequest.OnServerInvoke = function(player, action, object)
        return self:HandleDragRequest(player, action, object)
    end
    
    -- Clean up when players leave
    Players.PlayerRemoving:Connect(function(player)
        self:CleanupPlayerDrags(player)
    end)
    
    print("Drag server system initialized")
end

function DragServerSystem:HandleDragRequest(player, action, object)
    if not object or not object.Parent then
        return false, "Invalid object"
    end
    
    if action == "pickup" then
        return self:HandlePickup(player, object)
    elseif action == "drop" then
        return self:HandleDrop(player, object)
    else
        return false, "Invalid action"
    end
end

function DragServerSystem:HandlePickup(player, object)
    -- Check if object is already being dragged
    if draggedObjects[object] then
        return false, "Object already being dragged"
    end
    -- Check if object can be dragged (has the tag or parent is Draggable model)
    local CollectionService = game:GetService("CollectionService")
    local Constants = require(ReplicatedStorage.Shared.Constants)
    local isModel = object.Parent and CollectionService:HasTag(object.Parent, "Draggable")
    local isDraggableModel = object.Parent and CollectionService:HasTag(object.Parent, Constants.TAGS.DRAGGABLE_ITEM)
    if not (CollectionService:HasTag(object, Constants.TAGS.DRAGGABLE_ITEM) or isModel or isDraggableModel) then
        return false, "Object not draggable"
    end
    -- If it's a model, always drag the model itself
    if isModel or isDraggableModel then
        object = object.Parent
        -- Find the part to set network ownership on
        local mainPart = object.PrimaryPart or object:FindFirstChild("Torso") or object:FindFirstChild("HumanoidRootPart")
        if not mainPart then
            return false, "No suitable part to set network ownership"
        end
        -- Set network ownership to the player
        local success, error = pcall(function()
            mainPart:SetNetworkOwner(player)
        end)
        if not success then
            warn("Failed to set network owner:", error)
            return false, "Failed to set network ownership"
        end
    else
        -- Set network ownership to the player for regular parts
        local success, error = pcall(function()
            object:SetNetworkOwner(player)
        end)
        if not success then
            warn("Failed to set network owner:", error)
            return false, "Failed to set network ownership"
        end
    end
    -- Mark as being dragged
    draggedObjects[object] = player.UserId
    object:SetAttribute("DraggedBy", player.UserId)
    print("Player", player.Name, "picked up", object.Name)
    return true, "Pickup successful"
end

function DragServerSystem:HandleDrop(player, object)
    -- Check if object still exists
    if not object or not object.Parent then
        return false, "Object no longer exists"
    end
    
    -- Find the actual dragged object (could be the object itself or its parent model)
    local actualObject = object
    for draggedObj, userId in pairs(draggedObjects) do
        if userId == player.UserId then
            -- Check if this is the object or if object is a child of the dragged model
            if draggedObj == object or (draggedObj:IsA("Model") and object.Parent == draggedObj) then
                actualObject = draggedObj
                break
            end
        end
    end
    
    -- Check if player owns this object
    if draggedObjects[actualObject] ~= player.UserId then
        return false, "You don't own this object"
    end
    
    -- Remove from dragged objects
    draggedObjects[actualObject] = nil
    actualObject:SetAttribute("DraggedBy", nil)
    
    -- Reset network ownership to server
    local success, error = pcall(function()
        -- Check if object still exists before trying to reset network ownership
        if actualObject and actualObject.Parent then
            if actualObject:IsA("Model") then
                -- For models, find the primary part or a suitable part to reset network ownership
                local mainPart = actualObject.PrimaryPart or actualObject:FindFirstChild("Torso") or actualObject:FindFirstChild("HumanoidRootPart")
                if mainPart then
                    mainPart:SetNetworkOwner(nil)
                else
                    warn("No suitable part found to reset network ownership for model:", actualObject.Name)
                end
            else
                -- For regular parts, reset network ownership directly
                actualObject:SetNetworkOwner(nil)
            end
        end
    end)
    
    if not success then
        warn("Failed to reset network owner:", error)
    end
    
    print("Player", player.Name, "dropped", actualObject.Name)
    return true, "Drop successful"
end

function DragServerSystem:CleanupPlayerDrags(player)
    -- Find all objects dragged by this player and drop them
    for object, userId in pairs(draggedObjects) do
        if userId == player.UserId then
            self:HandleDrop(player, object)
        end
    end
end

function DragServerSystem:CleanupObjectDrags(object)
    -- Remove any drag references for a specific object
    if draggedObjects[object] then
        draggedObjects[object] = nil
        if object:GetAttribute("DraggedBy") then
            object:SetAttribute("DraggedBy", nil)
        end
        print("Cleaned up drag references for:", object.Name)
    end
    
    -- Also check if any child parts are being dragged
    if object:IsA("Model") then
        for _, child in ipairs(object:GetDescendants()) do
            if draggedObjects[child] then
                draggedObjects[child] = nil
                if child:GetAttribute("DraggedBy") then
                    child:SetAttribute("DraggedBy", nil)
                end
                print("Cleaned up drag references for child:", child.Name)
            end
        end
    end
end

return DragServerSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="86">
          <Properties>
            <string name="Name">InventoryServerSystem</string>
            <string name="Source"><![CDATA[-- Server-side inventory system (completely independent from DragServerSystem)
local InventoryServerSystem = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local ECS = require(ReplicatedStorage.Shared.ECS)
local Constants = require(ReplicatedStorage.Shared.Constants)

-- Player inventory storage (server-side)
local playerInventories = {}
local playerEquippedSlots = {}

function InventoryServerSystem:Initialize()
    -- Initialize player inventories and equipped slots tracking
    Players.PlayerAdded:Connect(function(player)
        playerInventories[player] = {}
        playerEquippedSlots[player] = nil
        print("Initialized inventory for player:", player.Name)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        self:CleanupPlayerInventory(player)
    end)
    
    -- Set up RemoteFunction connections
    RemoteEvents.InventoryRequest.OnServerInvoke = function(player, action, ...)
        return self:HandleInventoryRequest(player, action, ...)
    end
    
    -- Set up ConsumeItem handler
    RemoteEvents.ConsumeItemRequest.OnServerEvent:Connect(function(player, slot)
        local success, message = self:ConsumeItem(player, slot)
        -- Send response back to client
        RemoteEvents.ConsumeItemResponse:FireClient(player, success, message, slot)
    end)
    
    -- SIMPLIFIED: No periodic cleanup needed
    
    print("Inventory server system initialized")
end

function InventoryServerSystem:InitializePlayerInventory(player)
    playerInventories[player] = {}
    playerEquippedSlots[player] = nil
    
    -- Initialize 10 empty slots
    for i = 1, 10 do
        playerInventories[player][i] = nil
    end
    
    print("Initialized inventory for player:", player.Name)
end

function InventoryServerSystem:CleanupPlayerInventory(player)
    -- Clean up all tools in character first
    if player.Character then
        for _, child in pairs(player.Character:GetChildren()) do
            if child:IsA("Tool") then
                pcall(function() child:Destroy() end)
            end
        end
    end
    
    -- Drop all inventory items to world
    if playerInventories[player] then
        for slot, inventoryItem in pairs(playerInventories[player]) do
            if inventoryItem then
                pcall(function()
                    self:DropItemToWorld(player, inventoryItem.object)
                end)
            end
        end
    end
    
    -- Clear player data
    playerInventories[player] = nil
    playerEquippedSlots[player] = nil
end

-- Cleanup method for system shutdown
function InventoryServerSystem:Cleanup()
    -- Clean up all players
    for player, _ in pairs(playerInventories) do
        pcall(function()
            self:CleanupPlayerInventory(player)
        end)
    end
    
    -- Clear tracking tables
    playerInventories = {}
    playerEquippedSlots = {}
end

function InventoryServerSystem:HandleInventoryRequest(player, action, ...)
    local args = {...}
    
    if action == "pickup_to_inventory" then
        local object, slot = args[1], args[2]
        return self:PickupToInventory(player, object, slot)
    elseif action == "drop_from_inventory" then
        local slot = args[1]
        return self:DropFromInventory(player, slot)
    elseif action == "equip_slot" then
        local slot = args[1]
        return self:EquipSlot(player, slot)
    elseif action == "swap_slots" then
        local slot1, slot2 = args[1], args[2]
        return self:SwapSlots(player, slot1, slot2)
    else
        warn("Unknown inventory action:", action)
        return false, "Unknown action"
    end
end

function InventoryServerSystem:PickupToInventory(player, object, slot)
    if not object or not object.Parent then
        return false, "Invalid object"
    end
    
    local isValidItem = self:IsValidItem(object)
    
    if not isValidItem then
        return false, "Object is not a valid item"
    end
    
    -- Check if player can pickup this item
    local canPlayerPickup = self:CanPlayerPickup(player, object)
    
    if not canPlayerPickup then
        return false, "Cannot pickup this item"
    end
    
    -- Check if slot is available
    local slotOccupied = playerInventories[player][slot] ~= nil
    
    if slotOccupied then
        return false, "Slot is occupied"
    end
    
    -- Store item information
    local itemIcon = self:GetItemIcon(object)
    local originalCFrame = object:IsA("Model") and object.PrimaryPart and object.PrimaryPart.CFrame or object.CFrame
    local itemInfo = {
        object = object,
        itemName = object.Name,
        originalCFrame = originalCFrame,
        originalParent = object.Parent,
        icon = itemIcon
    }
    
    -- Add to player's inventory
    playerInventories[player][slot] = itemInfo
    
    -- Reset network ownership before moving to ReplicatedStorage
    -- This prevents issues with models that had network ownership set during dragging
    local success, error = pcall(function()
        if object:IsA("Model") then
            -- For models, reset network ownership on the primary part
            local mainPart = object.PrimaryPart or object:FindFirstChild("Torso") or object:FindFirstChild("HumanoidRootPart")
            if mainPart then
                mainPart:SetNetworkOwner(nil)
            end
        else
            -- For regular parts, reset network ownership directly
            object:SetNetworkOwner(nil)
        end
    end)
    
    if not success then
        warn("Failed to reset network ownership for", object.Name, ":", error)
    end
    
    -- Hide item from world (move to ReplicatedStorage for safekeeping)
    object.Parent = ReplicatedStorage
    
    -- Anchor the object (handle both parts and models)
    if object:IsA("Model") then
        -- For models, anchor all parts
        for _, part in ipairs(object:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = true
            end
        end
    else
        -- For parts, anchor directly
        object.Anchored = true
    end
    
    -- WorldCleanupSystem removed - no longer needed
    
    return true, "Successfully picked up", itemIcon
end

function InventoryServerSystem:DropFromInventory(player, slot)
    local inventoryItem = playerInventories[player][slot]
    if not inventoryItem then
        return false, "Slot is empty"
    end
    
    local object = inventoryItem.object
    if not object or not object.Parent then
        return false, "Item object is invalid"
    end
    
    -- Calculate drop position (in front of player)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false, "Player character not found"
    end
    
    local humanoidRootPart = character.HumanoidRootPart
    local dropPosition = humanoidRootPart.CFrame * CFrame.new(0, 0, -5) -- 5 studs in front
    
    -- Remove tool from character if this slot is equipped
    if playerEquippedSlots[player] == slot then
        self:RemoveToolFromCharacter(player)
        playerEquippedSlots[player] = nil
    end
    
    -- Return item to world
    object.Parent = workspace
    if object:IsA("Model") and object.PrimaryPart then
        object:SetPrimaryPartCFrame(dropPosition)
        -- Ensure all parts are unanchored
        for _, part in ipairs(object:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
            end
        end
    else
        object.CFrame = dropPosition
        object.Anchored = false
    end
    
    -- Remove from inventory
    playerInventories[player][slot] = nil
    
    return true, "Successfully dropped"
end

function InventoryServerSystem:EquipSlot(player, slot)
    -- Handle unequip request (slot = nil means unequip)
    if slot == nil then
        -- Remove any currently equipped tool
        self:RemoveToolFromCharacter(player)
        playerEquippedSlots[player] = nil
        return true, "Unequipped - hands are empty"
    end
    
    -- If already equipped to this slot, don't do anything
    if playerEquippedSlots[player] == slot then
        return true, "Already equipped slot " .. slot
    end
    
    -- Remove any currently equipped tool first
    self:RemoveToolFromCharacter(player)
    
    -- Check if slot has an item
    if not playerInventories[player][slot] then
        -- Unequip if trying to equip empty slot
        playerEquippedSlots[player] = nil
        return true, "Unequipped"
    end
    
    -- Equip the slot
    playerEquippedSlots[player] = slot
    
    -- Create tool in character
    self:CreateToolInCharacter(player, slot)
    
    local equippedItem = playerInventories[player][slot]
    
    return true, "Equipped slot " .. slot .. " with " .. equippedItem.itemName
end

function InventoryServerSystem:IsValidItem(object)
    -- Check if object has required tag (components are client-side only)
    return CollectionService:HasTag(object, "DraggableItem")
end

function InventoryServerSystem:CanPlayerPickup(player, object)
    -- Check distance (anti-exploit)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    -- Get the position to check distance from
    local objectPosition
    if object:IsA("Model") and object.PrimaryPart then
        objectPosition = object.PrimaryPart.Position
    else
        objectPosition = object.Position
    end
    
    local distance = (character.HumanoidRootPart.Position - objectPosition).Magnitude
    if distance > 15 then -- Same as drag detection distance
        return false
    end
    
    -- Server-side validation: all tagged items can be picked up
    -- Client-side will handle detailed component validation
    return true
end

function InventoryServerSystem:GetItemIcon(object)
    -- Get icon from item definition or use default
    if ECS:HasComponent(object, "Inventoryable") then
        local inventoryComponent = ECS:GetComponent(object, "Inventoryable")
        return inventoryComponent.inventoryIcon or object.Name:sub(1, 2):upper()
    end
    
    return object.Name:sub(1, 2):upper()
end

function InventoryServerSystem:DropItemToWorld(player, object)
    if not object or not object.Parent then return end
    
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local dropPosition = character.HumanoidRootPart.CFrame * CFrame.new(0, 0, -5)
        object.Parent = workspace
        if object:IsA("Model") and object.PrimaryPart then
            object:SetPrimaryPartCFrame(dropPosition)
            -- Ensure all parts are unanchored
            for _, part in ipairs(object:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.Anchored = false
                end
            end
        else
            object.CFrame = dropPosition
            object.Anchored = false
        end
    else
        -- Fallback: drop at spawn location
        object.Parent = workspace
        if object:IsA("Model") and object.PrimaryPart then
            object:SetPrimaryPartCFrame(CFrame.new(0, 10, 0))
            -- Ensure all parts are unanchored
            for _, part in ipairs(object:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.Anchored = false
                end
            end
        else
            object.CFrame = CFrame.new(0, 10, 0)
            object.Anchored = false
        end
    end
    
    -- WorldCleanupSystem removed - no longer needed
end

function InventoryServerSystem:GetPlayerInventory(player)
    return playerInventories[player] or {}
end

function InventoryServerSystem:GetPlayerEquippedSlot(player)
    return playerEquippedSlots[player]
end

-- Debug method to get player inventories
function InventoryServerSystem:GetPlayerInventories()
    return playerInventories
end

function InventoryServerSystem:CreateToolInCharacter(player, slot)
    local inventoryItem = playerInventories[player][slot]
    if not inventoryItem or not inventoryItem.object then
        warn("Cannot create tool: invalid inventory item in slot", slot)
        return
    end
    local character = player.Character
    if not character then
        warn("Cannot create tool: player has no character")
        return
    end
    -- Remove any existing tool first
    self:RemoveToolFromCharacter(player)
    local originalObject = inventoryItem.object
    -- Create Tool object
    local tool = Instance.new("Tool")
    tool.Name = originalObject.Name
    tool.RequiresHandle = true
    tool.CanBeDropped = false -- Prevent default Roblox dropping
    -- Use default grip orientation for natural tool positioning
    tool.GripForward = Vector3.new(0, 1, 0)
    tool.GripRight = Vector3.new(1, 0, -1)
    tool.GripUp = Vector3.new(0, 0, -1)
    tool.GripPos = Vector3.new(0, 0, 0)

    local handle
    if originalObject:IsA("Model") then
        -- Clone the model
        local modelClone = originalObject:Clone()
        -- Find the part named 'Handle' inside the model
        handle = modelClone:FindFirstChild("Handle")
        if not handle or not handle:IsA("BasePart") then
            warn("Model does not contain a BasePart named 'Handle'")
            return
        end
        -- Parent the handle directly to the tool
        handle.Parent = tool
        -- Parent all other parts (that are welded) directly to the tool as well
        for _, obj in ipairs(modelClone:GetChildren()) do
            if obj ~= handle and obj:IsA("BasePart") then
                obj.Parent = tool
            end
        end
        -- Unanchor and set physics for all parts
        for _, part in ipairs(tool:GetChildren()) do
            if part:IsA("BasePart") then
                part.Anchored = false
                part.CanCollide = false
                part.TopSurface = Enum.SurfaceType.Smooth
                part.BottomSurface = Enum.SurfaceType.Smooth
                part.CollisionGroup = "Default"
            end
        end
    else
        -- Single-part item
        handle = originalObject:Clone()
        handle.Name = "Handle"
        handle.Anchored = false
        handle.CanCollide = false
        handle.TopSurface = Enum.SurfaceType.Smooth
        handle.BottomSurface = Enum.SurfaceType.Smooth
        handle.CollisionGroup = "Default"
        handle.Parent = tool
    end
    -- Add tool interaction script
    self:AddToolScript(tool)
    -- Equip the tool
    tool.Parent = character
    -- Store reference for cleanup
    inventoryItem.activeTool = tool
end

function InventoryServerSystem:RemoveToolFromCharacter(player)
    -- Simple approach: remove all tools from character
    local character = player.Character
    if not character then return end
    
    -- Clear activeTool references first
    if playerInventories[player] then
        for slot, inventoryItem in pairs(playerInventories[player]) do
            if inventoryItem then
                inventoryItem.activeTool = nil
            end
        end
    end
    
    -- Remove all tools from character
    for _, child in pairs(character:GetChildren()) do
        if child:IsA("Tool") then
            pcall(function() child:Destroy() end)
        end
    end
end



function InventoryServerSystem:AddToolScript(tool)
    -- Clone the pre-made tool handler script
    local toolHandlerTemplate = ReplicatedStorage:FindFirstChild("Shared"):FindFirstChild("ToolHandler")
    
    if toolHandlerTemplate then
        local toolScript = toolHandlerTemplate:Clone()
        toolScript.Parent = tool
    else
        -- Fallback: just add a simple identifier
        local toolId = Instance.new("StringValue")
        toolId.Name = "ToolId"
        toolId.Value = tool.Name
        toolId.Parent = tool
        warn("Tool script template not found - tools may not function properly")
    end
end

function InventoryServerSystem:SwapSlots(player, slot1, slot2)
    -- Validate slots
    if slot1 < 1 or slot1 > 10 or slot2 < 1 or slot2 > 10 then
        return false, "Invalid slot numbers"
    end
    
    if not playerInventories[player] then
        return false, "Player inventory not found"
    end
    
    -- Get current items
    local item1 = playerInventories[player][slot1]
    local item2 = playerInventories[player][slot2]
    
    -- Perform the swap on server
    playerInventories[player][slot1] = item2
    playerInventories[player][slot2] = item1
    
    return true, "Slots swapped successfully"
end

-- Public helper: remove an inventory item by its instance (object)
function InventoryServerSystem:RemoveItemByObject(player, object)
    if not playerInventories[player] or not object then return end

    for slot, inventoryItem in pairs(playerInventories[player]) do
        if inventoryItem and inventoryItem.object == object then
            -- Clear equipped slot tracking if needed
            if playerEquippedSlots[player] == slot then
                playerEquippedSlots[player] = nil
            end

            -- Destroy any active Tool instance held by the character
            if inventoryItem.activeTool and inventoryItem.activeTool.Parent then
                inventoryItem.activeTool:Destroy()
                inventoryItem.activeTool = nil
            end

            playerInventories[player][slot] = nil
            break
        end
    end
end

-- Add an item directly into the first available slot (used by ArmorServerSystem when unequipping)
function InventoryServerSystem:AddItemToFirstEmptySlot(player, object)
    if not playerInventories[player] or not object then
        return false, "Invalid player or object"
    end

    -- Find first empty slot
    local emptySlot = nil
    for i = 1, 10 do
        if not playerInventories[player][i] then
            emptySlot = i
            break
        end
    end

    if not emptySlot then
        return false, "Inventory full"
    end

    -- Build inventory item structure (re-using GetItemIcon helper)
    local itemInfo = {
        object = object,
        itemName = object.Name,
        originalCFrame = object.CFrame,
        originalParent = object.Parent,
        icon = self:GetItemIcon(object)
    }

    playerInventories[player][emptySlot] = itemInfo

    -- Ensure object is stored safely (anchor + ReplicatedStorage)
    object.Parent = ReplicatedStorage
    object.Anchored = true

    return true, emptySlot
end

-- Remove item from specific slot
function InventoryServerSystem:RemoveItemBySlot(player, slot)
    if not playerInventories[player] or not playerInventories[player][slot] then
        return false
    end
    
    local inventoryItem = playerInventories[player][slot]
    
    -- Clear equipped slot tracking if needed
    if playerEquippedSlots[player] == slot then
        playerEquippedSlots[player] = nil
    end
    
    -- Destroy any active Tool instance held by the character
    if inventoryItem.activeTool and inventoryItem.activeTool.Parent then
        inventoryItem.activeTool:Destroy()
        inventoryItem.activeTool = nil
    end
    
    -- Clear the slot
    playerInventories[player][slot] = nil
    
    return true
end

-- Method to consume an item from inventory (for functional items)
function InventoryServerSystem:ConsumeItem(player, slot)
    -- Validate slot
    if slot < 1 or slot > 10 then
        return false, "Invalid slot number"
    end
    
    if not playerInventories[player] then
        return false, "Player inventory not found"
    end
    
    local inventoryItem = playerInventories[player][slot]
    if not inventoryItem then
        return false, "Slot is empty"
    end
    
    print("Server consuming item:", inventoryItem.itemName, "from slot", slot, "for player", player.Name)
    
    -- Remove tool from character if this slot is equipped
    if playerEquippedSlots[player] == slot then
        self:RemoveToolFromCharacter(player)
        playerEquippedSlots[player] = nil
    end
    
    -- Destroy the item object completely (it's consumed)
    if inventoryItem.object and inventoryItem.object.Parent then
        pcall(function()
            inventoryItem.object:Destroy()
        end)
    end
    
    -- Remove from inventory
    playerInventories[player][slot] = nil
    
    print("Successfully consumed item:", inventoryItem.itemName, "for player", player.Name)
    print("DEBUG: Server returning success=true, message='Item consumed'")
    return true, "Item consumed"
end

-- REMOVED: Cleanup function - let Roblox handle object lifecycle

return InventoryServerSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="87">
          <Properties>
            <string name="Name">ItemSpawnSystem</string>
            <string name="Source"><![CDATA[-- ItemSpawnSystem.luau
-- Spawns items at item spawners (guaranteed and random), no respawn/cooldown, proximity-based

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local ItemLootPools = require(ReplicatedStorage.Shared.ItemLootPools)
local ItemSpawnerSetup = require(script.Parent.ItemSpawnerSetup)
local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)
local Constants = require(ReplicatedStorage.Shared.Constants)
local PhysicsService = game:GetService("PhysicsService")

local ItemPoolSpawnSystem = {}

local ACTIVATION_RANGE = 60 -- Fixed activation range for all item spawners
local CHECK_INTERVAL = 2 -- Seconds between proximity checks

local spawnedSpawners = {} -- [spawnerConfig] = true

local function isAnyPlayerNearSpawner(spawner)
    local spawnerPos = spawner.part.Position
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local playerPos = player.Character.HumanoidRootPart.Position
            if (playerPos - spawnerPos).Magnitude <= ACTIVATION_RANGE then
                return true
            end
        end
    end
    return false
end

function ItemPoolSpawnSystem._spawnAtSpawner(spawner)
    local pool = ItemLootPools[spawner.lootPool]
    if not pool then return end
    local spawned = {}
    -- Spawn guaranteed items first
    for _, guaranteedItem in ipairs(spawner.assignedGuaranteed) do
        ItemPoolSpawnSystem._spawnItemAtSpawner(spawner, guaranteedItem)
        spawned[guaranteedItem] = true
    end
    -- Determine how many more items to spawn
    local numToSpawn = math.random(spawner.countMin, spawner.countMax)
    local itemsSpawned = #spawner.assignedGuaranteed
    while itemsSpawned < numToSpawn do
        local item = ItemPoolSpawnSystem._chooseRandomItem(pool, spawned)
        if not item then break end
        ItemPoolSpawnSystem._spawnItemAtSpawner(spawner, item)
        spawned[item] = true
        itemsSpawned = itemsSpawned + 1
    end
    spawnedSpawners[spawner] = true
end

function ItemPoolSpawnSystem.spawnAllItems()
    local spawnerConfigs, spawnersByRegion = ItemSpawnerSetup.scanForItemSpawners()
    -- Destroy all spawner parts immediately after setup
    for _, spawner in ipairs(spawnerConfigs) do
        if spawner.part and spawner.part.Parent then
            spawner.part:Destroy()
        end
    end
    ItemSpawnerSetup.assignGuaranteedItems(spawnersByRegion)
    spawnedSpawners = {}

    -- Periodically check for player proximity and spawn items
    local function checkSpawners()
        local allSpawned = true
        for _, spawner in ipairs(spawnerConfigs) do
            if not spawnedSpawners[spawner] then
                allSpawned = false
                if isAnyPlayerNearSpawner(spawner) then
                    ItemPoolSpawnSystem._spawnAtSpawner(spawner)
                end
            end
        end
        if not allSpawned then
            -- Continue checking until all spawners have spawned
            task.delay(CHECK_INTERVAL, checkSpawners)
        end
    end
    checkSpawners()
end

function ItemPoolSpawnSystem._chooseRandomItem(pool, exclude)
    exclude = exclude or {}
    -- Weighted random selection, skipping excluded items
    local totalWeight = 0
    for i, item in ipairs(pool.items) do
        if not exclude[item] then
            totalWeight = totalWeight + (pool.rarities[i] or 0)
        end
    end
    if totalWeight == 0 then return nil end
    local r = math.random() * totalWeight
    local acc = 0
    for i, item in ipairs(pool.items) do
        if not exclude[item] then
            acc = acc + (pool.rarities[i] or 0)
            if r <= acc then
                return item
            end
        end
    end
    return nil
end

function ItemPoolSpawnSystem._spawnItemAtSpawner(spawner, itemId)
    local basePos = spawner.part.Position
    local radius = spawner.spawnRadius or 5
    local angle = math.random() * 2 * math.pi
    local dist = math.random() * radius
    local pos = basePos + Vector3.new(math.cos(angle) * dist, 0, math.sin(angle) * dist)
    -- Spawn the item using the utility logic
    ItemPoolSpawnSystem.SpawnItem(itemId, pos)
end

-- Utility function to spawn a single item (from the old system)
function ItemPoolSpawnSystem.SpawnItem(itemId, position)
    local itemDefinition = ItemDefinitions:GetItem(itemId)
    if not itemDefinition then
        warn("Item definition not found:", itemId)
        return nil
    end
    
    local item = nil
    -- Try to load custom model first
    if itemDefinition.model then
        local modelsFolder = ReplicatedStorage:FindFirstChild("Models")
        if modelsFolder then
            local modelTemplate = modelsFolder:FindFirstChild(itemDefinition.model)
            if modelTemplate then
                item = modelTemplate:Clone()
                print("Loaded custom model:", itemDefinition.model, "for", itemDefinition.name)
            else
                warn("Model not found in ReplicatedStorage/Models/:", itemDefinition.model)
            end
        else
            warn("Models folder not found in ReplicatedStorage")
        end
    end
    
    -- Create fallback part if no model found
    if not item then
        print("Using fallback basic part for:", itemDefinition.name)
        item = Instance.new("Part")
        item.Size = Vector3.new(2, 1, 0.5)
        item.BrickColor = BrickColor.Random()
        item.TopSurface = Enum.SurfaceType.Smooth
        item.BottomSurface = Enum.SurfaceType.Smooth
        item.Material = Enum.Material.Metal
    end
    
    -- ALWAYS set the correct name from item definition
    item.Name = itemDefinition.name
    print("Spawned item with name:", item.Name, "for itemId:", itemId)
    local primaryPart = item
    if item:IsA("Model") then
        -- Ensure model has a primary part
        if not item.PrimaryPart then
            local largestPart = nil
            local largestVolume = 0
            for _, part in pairs(item:GetChildren()) do
                if part:IsA("BasePart") then
                    local volume = part.Size.X * part.Size.Y * part.Size.Z
                    if volume > largestVolume then
                        largestVolume = volume
                        largestPart = part
                    end
                end
            end
            if largestPart then
                item.PrimaryPart = largestPart
                print("Set PrimaryPart for model:", itemDefinition.name, "to:", largestPart.Name)
            else
                warn("No suitable part found for PrimaryPart in model:", itemDefinition.name)
            end
        end
        primaryPart = item.PrimaryPart
        
        -- Position the model using its primary part
        if primaryPart then
            item:SetPrimaryPartCFrame(CFrame.new(position))
            -- Assign all parts to 'Items' collision group
            for _, part in ipairs(item:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CollisionGroup = "Items"
                    part.Anchored = false
                end
            end
        else
            warn("Could not position model - no primary part found:", itemDefinition.name)
        end
    else
        -- Handle single part items
        if primaryPart then
            primaryPart.Position = position
            primaryPart.CollisionGroup = "Items"
            primaryPart.Anchored = false
        else
            warn("Could not position item - no primary part found:", itemDefinition.name)
        end
    end
    item.Parent = workspace
    CollectionService:AddTag(item, Constants.TAGS.DRAGGABLE_ITEM)
    
    -- Add ECS components to the item (server-side setup)
    ItemPoolSpawnSystem:AddECSComponentsToItem(item, itemDefinition)
    
    print("Spawned item:", itemDefinition.name, "at", position)
    return item
end

-- Add ECS components to spawned items
function ItemPoolSpawnSystem:AddECSComponentsToItem(item, itemDefinition)
    local ECS = require(ReplicatedStorage.Shared.ECS)
    local Draggable = require(ReplicatedStorage.Shared.Components.Draggable)
    local Hoverable = require(ReplicatedStorage.Shared.Components.Hoverable)
    local Inventoryable = require(ReplicatedStorage.Shared.Components.Inventoryable)
    
    -- Add components based on item definition
    if itemDefinition.components then
        for componentName, config in pairs(itemDefinition.components) do
            local component = nil
            
            if componentName == "Draggable" then
                component = Draggable.new(config)
            elseif componentName == "Hoverable" then
                component = Hoverable.new(config)
            elseif componentName == "Inventoryable" then
                component = Inventoryable.new(config)
            end
            
            if component then
                ECS:AddComponent(item, componentName, component)
                print("Added", componentName, "component to", item.Name)
            else
                warn("Failed to create component:", componentName, "for", item.Name)
            end
        end
    else
        -- Add default components if none specified
        local defaultComponents = {
            Draggable = Draggable.new({ force = 8000, maxDistance = 35, dampening = 0.6 }),
            Hoverable = Hoverable.new({ displayName = item.Name, description = "A mysterious item." }),
            Inventoryable = Inventoryable.new({ canPickup = true, stackable = false, maxStack = 1 })
        }
        
        for componentName, component in pairs(defaultComponents) do
            ECS:AddComponent(item, componentName, component)
            print("Added default", componentName, "component to", item.Name)
        end
    end
end

return ItemPoolSpawnSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="88">
          <Properties>
            <string name="Name">ItemSpawnerSetup</string>
            <string name="Source"><![CDATA[-- ItemSpawnerSetup.luau
-- Scans for tagged ItemSpawner parts, reads attributes, and groups spawners by pool region

local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ItemLootPools = require(ReplicatedStorage.Shared.ItemLootPools)

local ItemSpawnerSetup = {}

-- Scan workspace for all tagged item spawner parts
function ItemSpawnerSetup.scanForItemSpawners()
    local taggedParts = CollectionService:GetTagged("ItemSpawner")
    local spawnersByRegion = {}
    local spawnerConfigs = {}

    for _, part in ipairs(taggedParts) do
        local lootPool = part:GetAttribute("LootPool")
        local countMin = part:GetAttribute("CountMin") or 1
        local countMax = part:GetAttribute("CountMax") or 1
        local spawnRadius = part:GetAttribute("SpawnRadius") or 5
        local pool = ItemLootPools[lootPool]
        local region = pool and pool.region or "default"

        local config = {
            part = part,
            lootPool = lootPool,
            countMin = countMin,
            countMax = countMax,
            spawnRadius = spawnRadius,
            assignedGuaranteed = {},
        }
        table.insert(spawnerConfigs, config)
        spawnersByRegion[region] = spawnersByRegion[region] or {}
        table.insert(spawnersByRegion[region], config)
    end

    return spawnerConfigs, spawnersByRegion
end

-- Assign guaranteed items to random spawners in each region
function ItemSpawnerSetup.assignGuaranteedItems(spawnersByRegion)
    for region, spawnerList in pairs(spawnersByRegion) do
        -- Find all pools for this region
        local pools = {}
        for poolName, pool in pairs(ItemLootPools) do
            if pool.region == region then
                table.insert(pools, pool)
            end
        end
        -- For each pool, assign each guaranteed item to a random spawner in this region
        for _, pool in ipairs(pools) do
            for _, guaranteedItem in ipairs(pool.guaranteed or {}) do
                if #spawnerList > 0 then
                    local idx = math.random(1, #spawnerList)
                    table.insert(spawnerList[idx].assignedGuaranteed, guaranteedItem)
                end
            end
        end
    end
end

return ItemSpawnerSetup ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="89">
          <Properties>
            <string name="Name">PlayerEffectsSystem</string>
            <string name="Source"><![CDATA[-- PlayerEffectsSystem.luau
-- Server-side system for managing player status effects like slow, jump disable, etc.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local PlayerEffectsSystem = {}

-- Store player effects data
local playerEffects = {} -- {[player] = {effects = {}, originalStats = {}}}

-- Effect types
local EFFECT_TYPES = {
    SLOW = "slow",
    JUMP_DISABLE = "jump_disable"
}

-- Default player stats
local DEFAULT_STATS = {
    walkSpeed = 16,
    jumpHeight = 7.2
}

-- Initialize the system
function PlayerEffectsSystem:Initialize()
    -- Handle player joining
    Players.PlayerAdded:Connect(function(player)
        playerEffects[player] = {
            effects = {},
            originalStats = {}
        }
        
        -- Handle character respawning
        player.CharacterAdded:Connect(function(character)
            print("🚫 Player", player.Name, "respawned - clearing effects")
            self:RemoveAllEffects(player)
        end)
    end)
    
    -- Handle player leaving
    Players.PlayerRemoving:Connect(function(player)
        -- Clean up effects before player leaves
        self:RemoveAllEffects(player)
        playerEffects[player] = nil
    end)
    
    -- Initialize existing players
    for _, player in pairs(Players:GetPlayers()) do
        playerEffects[player] = {
            effects = {},
            originalStats = {}
        }
        
        -- Handle character respawning for existing players
        if player.Character then
            player.CharacterAdded:Connect(function(character)
                print("🚫 Player", player.Name, "respawned - clearing effects")
                self:RemoveAllEffects(player)
            end)
        end
    end
    
    print("PlayerEffectsSystem initialized")
end

-- Apply a slow effect to a player
function PlayerEffectsSystem:ApplySlowEffect(player, duration, slowFactor)
    if not player or not player.Character then
        warn("PlayerEffectsSystem: Cannot apply slow effect - invalid player or no character")
        return false
    end
    
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid then
        warn("PlayerEffectsSystem: Cannot apply slow effect - no humanoid found")
        return false
    end
    
    -- Store original stats if not already stored
    if not playerEffects[player].originalStats.walkSpeed then
        playerEffects[player].originalStats.walkSpeed = humanoid.WalkSpeed
    end
    
    -- Add effect to tracking
    local effectId = "slow_" .. tick()
    playerEffects[player].effects[effectId] = {
        type = EFFECT_TYPES.SLOW,
        startTime = tick(),
        duration = duration,
        slowFactor = slowFactor
    }
    
    -- Apply the strongest slow effect (highest slow factor)
    self:_updatePlayerWalkSpeed(player)
    
    print("🐌 Applied slow effect to", player.Name, "- Speed:", humanoid.WalkSpeed, "Duration:", duration)
    
    -- Remove effect after duration using RunService
    local startTime = tick()
    local connection
    connection = game:GetService("RunService").Heartbeat:Connect(function()
        if tick() - startTime >= duration then
            connection:Disconnect()
            if player and player.Character and player.Character:FindFirstChild("Humanoid") then
                self:RemoveEffect(player, effectId)
            end
        end
    end)
    
    return true
end

-- Helper function to update player walk speed based on active slow effects
function PlayerEffectsSystem:_updatePlayerWalkSpeed(player)
    if not playerEffects[player] then
        return
    end
    
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
    if not humanoid then
        return
    end
    
    -- Store original walk speed if not already stored
    if not playerEffects[player].originalStats.walkSpeed then
        playerEffects[player].originalStats.walkSpeed = humanoid.WalkSpeed
    end
    
    -- Find the strongest slow effect (highest slow factor)
    local strongestSlowFactor = 0
    for _, effect in pairs(playerEffects[player].effects) do
        if effect.type == EFFECT_TYPES.SLOW then
            strongestSlowFactor = math.max(strongestSlowFactor, effect.slowFactor)
        end
    end
    
    -- Apply the strongest slow effect
    local walkSpeed = playerEffects[player].originalStats.walkSpeed or DEFAULT_STATS.walkSpeed
    local newSpeed = walkSpeed * (1 - strongestSlowFactor)
    humanoid.WalkSpeed = newSpeed
end

-- Helper function to update player jump height based on active jump disable effects
function PlayerEffectsSystem:_updatePlayerJumpHeight(player)
    if not playerEffects[player] then
        return
    end
    
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
    if not humanoid then
        return
    end
    
    -- Store original jump height if not already stored
    if not playerEffects[player].originalStats.jumpHeight then
        playerEffects[player].originalStats.jumpHeight = humanoid.JumpHeight
        print("🚫 Stored original jump height for", player.Name, ":", humanoid.JumpHeight)
    end
    
    -- Check if there are any jump disable effects
    local hasJumpDisable = false
    for _, effect in pairs(playerEffects[player].effects) do
        if effect.type == EFFECT_TYPES.JUMP_DISABLE then
            hasJumpDisable = true
            break
        end
    end
    
    -- Apply jump disable or restore original jump height
    if hasJumpDisable then
        humanoid.JumpHeight = 0
        print("🚫 Jump disabled for", player.Name, "- JumpHeight set to 0")
    else
        humanoid.JumpHeight = DEFAULT_STATS.jumpHeight
        print("🚫 Jump enabled for", player.Name, "- JumpHeight restored to:", DEFAULT_STATS.jumpHeight)
    end
end

-- Apply a jump disable effect to a player
function PlayerEffectsSystem:ApplyJumpDisableEffect(player, duration)
    if not player or not player.Character then
        warn("PlayerEffectsSystem: Cannot apply jump disable effect - invalid player or no character")
        return false
    end
    
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid then
        warn("PlayerEffectsSystem: Cannot apply jump disable effect - no humanoid found")
        return false
    end
    
    -- Store original stats if not already stored
    if not playerEffects[player].originalStats.jumpHeight then
        -- Use the current jump height, or default if it's 0
        local originalJumpHeight = humanoid.JumpHeight
        if originalJumpHeight == 0 then
            originalJumpHeight = DEFAULT_STATS.jumpHeight
        end
        playerEffects[player].originalStats.jumpHeight = originalJumpHeight
        print("🚫 Stored original jump height for", player.Name, ":", originalJumpHeight)
    end
    
    -- Check if player already has a jump disable effect
    for effectId, effect in pairs(playerEffects[player].effects) do
        if effect.type == EFFECT_TYPES.JUMP_DISABLE then
            print("🚫 Player", player.Name, "already has jump disable effect, skipping")
            return false
        end
    end
    
    -- Add effect to tracking
    local effectId = "jump_disable_" .. tick()
    playerEffects[player].effects[effectId] = {
        type = EFFECT_TYPES.JUMP_DISABLE,
        startTime = tick(),
        duration = duration
    }
    
    -- Apply jump disable effect
    self:_updatePlayerJumpHeight(player)
    
    print("🚫 Applied jump disable effect to", player.Name, "- Duration:", duration)
    
    -- Remove effect after duration using RunService
    local startTime = tick()
    local connection
    connection = game:GetService("RunService").Heartbeat:Connect(function()
        if tick() - startTime >= duration then
            connection:Disconnect()
            if player and player.Character and player.Character:FindFirstChild("Humanoid") then
                self:RemoveEffect(player, effectId)
            end
        end
    end)
    
    return true
end

-- Remove a specific effect from a player
function PlayerEffectsSystem:RemoveEffect(player, effectId)
    print("TEST: RemoveEffect called for", player.Name)
    
    if not playerEffects[player] or not playerEffects[player].effects[effectId] then
        print("TEST: Effect not found")
        return false
    end
    
    local effect = playerEffects[player].effects[effectId]
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
    
    print("TEST: Effect type:", effect.type)
    
    -- Remove effect from tracking FIRST
    playerEffects[player].effects[effectId] = nil
    print("TEST: Effect removed from tracking")
    
    if humanoid then
        if effect.type == EFFECT_TYPES.SLOW then
            -- Update walk speed based on remaining slow effects
            self:_updatePlayerWalkSpeed(player)
            print("🐌 Removed slow effect from", player.Name, "- Speed restored to:", humanoid.WalkSpeed)
        elseif effect.type == EFFECT_TYPES.JUMP_DISABLE then
            -- Update jump height based on remaining jump disable effects
            self:_updatePlayerJumpHeight(player)
            print("🚫 Removed jump disable effect from", player.Name, "- Jump height restored to:", humanoid.JumpHeight)
        end
    end
    
    return true
end

-- Remove all effects from a player
function PlayerEffectsSystem:RemoveAllEffects(player)
    if not playerEffects[player] then
        return false
    end
    
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
    
    if humanoid then
        -- Restore to default stats
        humanoid.WalkSpeed = DEFAULT_STATS.walkSpeed
        humanoid.JumpHeight = DEFAULT_STATS.jumpHeight
    end
    
    -- Clear all effects
    playerEffects[player].effects = {}
    
    print("🧹 Removed all effects from", player.Name)
    
    return true
end

-- Get current effects for a player
function PlayerEffectsSystem:GetPlayerEffects(player)
    if not playerEffects[player] then
        return {}
    end
    
    return playerEffects[player].effects
end

-- Check if player has a specific effect type
function PlayerEffectsSystem:HasEffect(player, effectType)
    if not playerEffects[player] then
        return false
    end
    
    for _, effect in pairs(playerEffects[player].effects) do
        if effect.type == effectType then
            return true
        end
    end
    
    return false
end

return PlayerEffectsSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="90">
          <Properties>
            <string name="Name">PlayerRagdollSystem</string>
            <string name="Source"><![CDATA[-- PlayerRagdollSystem.luau
-- Applies enemy-style ragdoll and drag to players on death

local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local PhysicsService = game:GetService("PhysicsService")

-- Reference to ReviveSystem (will be set after initialization)
local ReviveSystem = nil

-- Track characters that have already been ragdolled to prevent multiple flings
local ragdolledCharacters = {}

local function createAttachment(part, cframeOffset)
    local attachment = Instance.new("Attachment")
    attachment.Name = part.Name .. "Attachment"
    attachment.CFrame = cframeOffset
    attachment.Parent = part
    return attachment
end

local function createSocket(torso, part, c0, c1)
    local ballSocket = Instance.new("BallSocketConstraint")
    ballSocket.Name = part.Name .. "Socket"
    local attachment0 = createAttachment(torso, c0)
    local attachment1 = createAttachment(part, c1)
    ballSocket.Attachment0 = attachment0
    ballSocket.Attachment1 = attachment1
    ballSocket.Parent = torso
end

local deadHealthConnections = {}
local enforcingHealth = {} -- Track when we're actively enforcing health to prevent feedback loops
local healthChangedConnections = {} -- Track HealthChanged connections to disconnect them after ragdoll

local function enforceZeroHealth(player)
    if not player.Character then return end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Prevent feedback loops
    if enforcingHealth[player] then
        return
    end
    
    -- Disconnect any previous connection
    if deadHealthConnections[player] then
        deadHealthConnections[player]:Disconnect()
    end
    
    -- Mark that we're enforcing health
    enforcingHealth[player] = true
    
    -- Enforce health stays at 0
    deadHealthConnections[player] = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        if not enforcingHealth[player] then return end -- Prevent feedback loops
        if humanoid.Health > 0 then
            humanoid.Health = 0
        end
    end)
    
    -- Immediately set to 0 if not already
    if humanoid.Health > 0 then
        humanoid.Health = 0
    end
end

local function clearZeroHealthEnforcement(player)
    if deadHealthConnections[player] then
        deadHealthConnections[player]:Disconnect()
        deadHealthConnections[player] = nil
    end
    enforcingHealth[player] = nil
end

-- Ensure collision groups are set up
local function setupCollisionGroups()
    -- Register groups if they don't exist (using new API)
    pcall(function() PhysicsService:RegisterCollisionGroup("Enemies") end)
    pcall(function() PhysicsService:RegisterCollisionGroup("Ragdolls") end)
    pcall(function() PhysicsService:RegisterCollisionGroup("Items") end)
    -- Enemies ignore ragdolls and items
    PhysicsService:CollisionGroupSetCollidable("Enemies", "Ragdolls", false)
    PhysicsService:CollisionGroupSetCollidable("Enemies", "Items", false)
    -- Ragdolls and items still collide with Default (ground, walls, etc.)
end
setupCollisionGroups()

local function ragdollCharacter(character)
    -- Prevent multiple ragdolls on the same character
    if ragdolledCharacters[character] then
        print("PlayerRagdollSystem: Character already ragdolled, skipping:", character.Name)
        return
    end
    ragdolledCharacters[character] = true
    
    print("PlayerRagdollSystem: Starting ragdoll for character:", character.Name)
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then 
        print("PlayerRagdollSystem: No humanoid found for character:", character.Name)
        return 
    end
    
    -- Disconnect the HealthChanged event to prevent repeated calls
    if healthChangedConnections[character] then
        healthChangedConnections[character]:Disconnect()
        healthChangedConnections[character] = nil
        print("PlayerRagdollSystem: Disconnected HealthChanged event for:", character.Name)
    end
    
    -- Prevent respawn and enforce zero health early to prevent feedback loops
    local player = Players:GetPlayerFromCharacter(character)
    if player then
        player.Neutral = true
        -- Add Dead tag for spectate/respawn logic
        CollectionService:AddTag(player, "Dead")
        enforceZeroHealth(player)
    end
    
    -- Disable joint breaking
    humanoid.BreakJointsOnDeath = false
    humanoid.RequiresNeck = false
    -- Hide health bar
    humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
    -- Prevent Roblox from deleting the character
    character.Parent = workspace
    -- Set CanCollide = true and assign to Ragdolls group for all limb parts
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and (part.Name:find("Arm") or part.Name:find("Leg") or part.Name == "Torso" or part.Name == "Head") then
            part.CanCollide = true
            PhysicsService:SetPartCollisionGroup(part, "Ragdolls")
        end
    end
    
    -- Set PlatformStand to prevent standing up
    humanoid.PlatformStand = true
    
    -- Replace Motor6Ds with BallSocketConstraints (except Neck) FIRST
    local torso = character:FindFirstChild("Torso")
    if torso then
        for _, joint in ipairs(torso:GetChildren()) do
            if joint:IsA("Motor6D") and joint.Name ~= "Neck" then
                createSocket(torso, joint.Part1, joint.C0, joint.C1)
                joint:Destroy()
            end
        end
    end
    
    -- Add a small delay to ensure ragdoll state is established
    task.wait(0.1)
    
    -- NOW apply fling effect AFTER joints are destroyed
    if torso then
        print("PlayerRagdollSystem: Found torso, applying fling effect")
        
        -- Generate random direction for torso (angled, not straight up)
        local randomDirection = Vector3.new(
            math.random(-1, 1), -- Random X direction
            math.random(0.3, 0.8), -- Reduced upward bias for more angle
            math.random(-1, 1)  -- Random Z direction
        ).Unit -- Normalize to unit vector
        
        local torsoMass = torso:GetMass()
        local randomForce = math.random(30, 60) -- Reduced force range for more reasonable fling
        local upwardImpulse = randomDirection * randomForce * torsoMass
        print("PlayerRagdollSystem: Torso mass:", torsoMass, "Impulse:", upwardImpulse)
        torso:ApplyImpulse(upwardImpulse)
        
        -- Add moderate rotation to make the whole character spin
        local torsoAngularVelocity = Vector3.new(
            math.random(-15, 15), -- Moderate rotation on X axis
            math.random(-15, 15), -- Moderate rotation on Y axis
            math.random(-15, 15)  -- Moderate rotation on Z axis
        )
        torso.AssemblyAngularVelocity = torsoAngularVelocity
        
        -- Also try BodyVelocity as backup
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(5000, 5000, 5000) -- Reduced force
        bodyVelocity.Velocity = randomDirection * 25 -- Reduced velocity
        bodyVelocity.Parent = torso
        game:GetService("Debris"):AddItem(bodyVelocity, 0.3) -- Shorter duration
        
        print("Player flung into the air on death!")
    else
        print("PlayerRagdollSystem: No torso found for character:", character.Name)
    end
    
    print("PlayerRagdollSystem: Applied impulses to 0 limbs (removed individual limb impulses)")
    
    -- Tag as Draggable and PlayerSacrifice
    CollectionService:AddTag(character, "Draggable")
    CollectionService:AddTag(character, "PlayerSacrifice")
    
    -- Track dead player for revive system
    if ReviveSystem then
        ReviveSystem:TrackDeadPlayer(player, character)
    end
    
    print("PlayerRagdollSystem: Completed ragdoll for character:", character.Name)
end

local function onCharacterAdded(character)
    character.Parent = workspace -- Ensure always in workspace
    character.Destroying:Connect(function()
        warn("[PlayerRagdollSystem] Character is being destroyed!", character)
        -- Clean up ragdoll tracking when character is destroyed
        ragdolledCharacters[character] = nil
        -- Clean up health changed connection
        if healthChangedConnections[character] then
            healthChangedConnections[character]:Disconnect()
            healthChangedConnections[character] = nil
        end
    end)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local player = Players:GetPlayerFromCharacter(character)
    if player then
        -- Remove Dead tag on respawn
        if CollectionService:HasTag(player, "Dead") then
            CollectionService:RemoveTag(player, "Dead")
            clearZeroHealthEnforcement(player)
        end
        -- Clean up ragdoll tracking when player respawns
        ragdolledCharacters[character] = nil
        -- Clean up health changed connection
        if healthChangedConnections[character] then
            healthChangedConnections[character]:Disconnect()
            healthChangedConnections[character] = nil
        end
    end
    if humanoid then
        humanoid.BreakJointsOnDeath = false
        humanoid.RequiresNeck = false
        humanoid.Destroying:Connect(function()
            warn("[PlayerRagdollSystem] Humanoid is being destroyed!", humanoid)
        end)
        -- Store the HealthChanged connection so we can disconnect it later
        healthChangedConnections[character] = humanoid.HealthChanged:Connect(function(health)
            if health <= 0 then
                humanoid.EvaluateStateMachine = false -- Disable state machine on 'death'
                ragdollCharacter(character)
            end
        end)
        -- Remove or comment out the Died event handler
        -- humanoid.Died:Connect(function()
        --     ragdollCharacter(character)
        -- end)
    end
end

local PlayerRagdollSystem = {}

function PlayerRagdollSystem:Initialize()
    -- Hook up all current and future players
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            onCharacterAdded(player.Character)
        end
        player.CharacterAdded:Connect(onCharacterAdded)
    end
    Players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(onCharacterAdded)
    end)
    print("PlayerRagdollSystem initialized: players will ragdoll and be draggable on death.")
end

-- Set ReviveSystem reference (called after ReviveSystem is initialized)
function PlayerRagdollSystem:SetReviveSystem(reviveSystem)
    ReviveSystem = reviveSystem
    print("PlayerRagdollSystem: ReviveSystem reference set")
end

return PlayerRagdollSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="91">
          <Properties>
            <string name="Name">ReviveSystem</string>
            <string name="Source"><![CDATA[-- ReviveSystem.luau
-- Server-side system for handling player revives with revive plush

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local ReviveSystem = {}

-- Track dead players and their ragdolls
local deadPlayerRagdolls = {} -- [player] = ragdollCharacter

-- Configuration
local REVIVE_DISTANCE = 10 -- Maximum distance to revive

function ReviveSystem:Initialize()
    -- Set up RemoteEvent connections
    RemoteEvents.ReviveRequest.OnServerEvent:Connect(function(player, targetPlayer)
        self:HandleReviveRequest(player, targetPlayer)
    end)
    
    -- TEMPORARY: Test remote for spawning revive plush
    local testSpawnRemote = ReplicatedStorage:FindFirstChild("TestSpawnRevivePlush")
    if not testSpawnRemote then
        testSpawnRemote = Instance.new("RemoteEvent")
        testSpawnRemote.Name = "TestSpawnRevivePlush"
        testSpawnRemote.Parent = ReplicatedStorage
    end
    testSpawnRemote.OnServerEvent:Connect(function(player)
        self:SpawnTestRevivePlush(player)
    end)
    
    -- Track player leaving to clean up
    Players.PlayerRemoving:Connect(function(player)
        self:CleanupPlayer(player)
    end)
    
    print("ReviveSystem initialized")
end

-- Handle revive request from client
function ReviveSystem:HandleReviveRequest(reviver, targetPlayer)
    print("Revive request from", reviver.Name, "for", targetPlayer.Name)
    
    -- Validate target player exists and is dead
    if not targetPlayer or not targetPlayer.Parent then
        self:SendReviveResponse(reviver, false, "Target player not found")
        return
    end
    
    -- Check if target is actually dead
    if not CollectionService:HasTag(targetPlayer, "Dead") then
        self:SendReviveResponse(reviver, false, "Target player is not dead")
        return
    end
    

    
    -- Check distance
    if not self:IsWithinReviveDistance(reviver, targetPlayer) then
        self:SendReviveResponse(reviver, false, "Target player is too far away")
        return
    end
    
    -- Check if reviver has revive plush equipped
    if not self:HasRevivePlushEquipped(reviver) then
        self:SendReviveResponse(reviver, false, "You need a revive plush equipped")
        return
    end
    
    -- Perform the revive
    local success = self:PerformRevive(reviver, targetPlayer)
    if success then
        self:SendReviveResponse(reviver, true, "Successfully revived " .. targetPlayer.Name)
    else
        self:SendReviveResponse(reviver, false, "Failed to revive player")
    end
end



-- Check if reviver is within distance of target
function ReviveSystem:IsWithinReviveDistance(reviver, targetPlayer)
    if not reviver.Character or not reviver.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local distance = (reviver.Character.HumanoidRootPart.Position - targetPlayer.Character.HumanoidRootPart.Position).Magnitude
    return distance <= REVIVE_DISTANCE
end

-- Check if player has revive plush equipped
function ReviveSystem:HasRevivePlushEquipped(player)
    local InventoryServerSystem = _G.InventoryServerSystem
    if not InventoryServerSystem then
        warn("ReviveSystem: Could not find InventoryServerSystem to check revive plush")
        return false
    end
    
    -- Get the currently equipped slot
    local equippedSlot = InventoryServerSystem:GetPlayerEquippedSlot(player)
    if not equippedSlot then
        return false
    end
    
    -- Check if the equipped item is a revive plush
    local playerInventories = InventoryServerSystem:GetPlayerInventories()
    local inventoryItem = playerInventories[player] and playerInventories[player][equippedSlot]
    
    if not inventoryItem then
        return false
    end
    
    -- Check if the item is a revive plush by checking the object name
    local itemName = inventoryItem.itemName
    local isRevivePlush = (itemName == "Revive Plush")
    
    print("ReviveSystem: Checking revive plush for", player.Name, "- Item:", itemName, "Is revive plush:", isRevivePlush)
    
    return isRevivePlush
end

-- Perform the actual revive
function ReviveSystem:PerformRevive(reviver, targetPlayer)
    print("ReviveSystem: Performing revive:", reviver.Name, "->", targetPlayer.Name)
    
    -- Remove dead tag
    CollectionService:RemoveTag(targetPlayer, "Dead")
    
    -- Load character (this will respawn the player)
    targetPlayer:LoadCharacter()
    
    -- Clean up ragdoll tracking
    deadPlayerRagdolls[targetPlayer] = nil
    
    -- DEBUG: Print inventory system status
    print("ReviveSystem: Checking inventory system...")
    local InventoryServerSystem = _G.InventoryServerSystem
    
    if InventoryServerSystem then
        print("ReviveSystem: InventoryServerSystem found")
        
        -- Get the currently equipped slot
        local equippedSlot = InventoryServerSystem:GetPlayerEquippedSlot(reviver)
        print("ReviveSystem: Player equipped slot:", equippedSlot)
        
        if equippedSlot then
            -- DEBUG: Check what's in the equipped slot
            local playerInventories = InventoryServerSystem:GetPlayerInventories()
            local inventoryItem = playerInventories[reviver] and playerInventories[reviver][equippedSlot]
            
            if inventoryItem then
                print("ReviveSystem: Found item in equipped slot:", inventoryItem.itemName)
                print("ReviveSystem: Item object:", inventoryItem.object and inventoryItem.object.Name or "nil")
            else
                print("ReviveSystem: No item found in equipped slot")
            end
            
            -- Direct server-side consumption (same as functional items but server-side)
            local success, message = InventoryServerSystem:ConsumeItem(reviver, equippedSlot)
            if success then
                print("ReviveSystem: Consumed revive plush from", reviver.Name, "equipped slot", equippedSlot)
                -- Send consumption response to client to update UI
                RemoteEvents.ConsumeItemResponse:FireClient(reviver, success, message, equippedSlot)
            else
                print("ReviveSystem: Failed to consume revive plush from", reviver.Name, "error:", message)
            end
        else
            print("ReviveSystem: No equipped slot found for", reviver.Name)
        end
    else
        warn("ReviveSystem: Could not find InventoryServerSystem to consume revive plush")
    end
    
    print("ReviveSystem: Successfully revived", targetPlayer.Name)
    print("ReviveSystem: Remaining dead players tracked:", #deadPlayerRagdolls)
    for trackedPlayer, _ in pairs(deadPlayerRagdolls) do
        print("  -", trackedPlayer.Name)
    end
    return true
end

-- Send revive response to client
function ReviveSystem:SendReviveResponse(player, success, message)
    RemoteEvents.ReviveResponse:FireClient(player, success, message)
end

-- Track a dead player ragdoll
function ReviveSystem:TrackDeadPlayer(player, ragdollCharacter)
    deadPlayerRagdolls[player] = ragdollCharacter
    
    print("ReviveSystem: Tracking dead player ragdoll:", player.Name)
    print("ReviveSystem: Current dead players tracked:", #deadPlayerRagdolls)
    for trackedPlayer, _ in pairs(deadPlayerRagdolls) do
        print("  -", trackedPlayer.Name)
    end
end

-- Clean up when player leaves
function ReviveSystem:CleanupPlayer(player)
    deadPlayerRagdolls[player] = nil
    print("Cleaned up revive data for:", player.Name)
end

-- Get all dead player ragdolls
function ReviveSystem:GetDeadPlayerRagdolls()
    return deadPlayerRagdolls
end

-- Check if a player is dead
function ReviveSystem:IsPlayerDead(player)
    return deadPlayerRagdolls[player] ~= nil
end

-- TEMPORARY: Test function to spawn a revive plush for debugging
function ReviveSystem:SpawnTestRevivePlush(player)
    print("ReviveSystem: Spawning test revive plush for", player.Name)
    
    local ItemSpawnSystem = _G.ItemSpawnSystem
    if not ItemSpawnSystem then
        warn("ReviveSystem: ItemSpawnSystem not available")
        return false
    end
    
    -- Get player position
    local spawnPosition = Vector3.new(0, 5, 0) -- Default fallback
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        spawnPosition = player.Character.HumanoidRootPart.Position + Vector3.new(5, 0, 0) -- 5 studs away
    end
    
    -- Spawn the revive plush
    local spawnedItem = ItemSpawnSystem.SpawnItem("revive_plush", spawnPosition)
    
    if spawnedItem then
        print("ReviveSystem: Successfully spawned revive plush for", player.Name, "at", spawnPosition)
        return true
    else
        warn("ReviveSystem: Failed to spawn revive plush for", player.Name)
        return false
    end
end

return ReviveSystem ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="92">
          <Properties>
            <string name="Name">RewardProcessor</string>
            <string name="Source"><![CDATA[-- RewardProcessor.luau
-- Handles summoner spawning and cleanup for altar system

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RewardConfig = require(ReplicatedStorage.Shared.RewardConfig)

local RewardProcessor = {}

-- Spawn reward for an altar
function RewardProcessor:SpawnReward(altar, sacrifices, hasPlayerSacrifices)
    print("Spawning reward for altar:", altar:GetFullName())
    print("Sacrifices count:", #sacrifices)
    print("Has player sacrifices:", hasPlayerSacrifices)
    
    -- Calculate spawn position
    local spawnPosition = self:CalculateSpawnPosition(altar)
    
    -- Determine which reward to spawn
    local success
    if hasPlayerSacrifices then
        -- Spawn philosopher's stone if there are player sacrifices
        success = self:SpawnPhilosophersStone(spawnPosition)
    else
        -- Spawn summoner item for enemy sacrifices
        success = self:SpawnSummoner(spawnPosition)
    end
    
    if success then
        -- Clean up sacrifices
        self:CleanupSacrifices(sacrifices)
        print("Reward spawned successfully")
        return true
    else
        print("Failed to spawn reward")
        return false
    end
end

-- Calculate spawn position for reward
function RewardProcessor:CalculateSpawnPosition(altar)
    local spawnType = RewardConfig.SUMMONER_REWARD.spawnPosition
    local spawnFunction = RewardConfig.SPAWN_POSITIONS[spawnType]
    
    if spawnFunction then
        return spawnFunction(altar)
    else
        -- Default to altar center
        return altar.Position + Vector3.new(0, 2, 0)
    end
end

-- Spawn the summoner item
function RewardProcessor:SpawnSummoner(position)
    -- Get the ItemSpawnSystem from global
    local ItemSpawnSystem = _G.ItemSpawnSystem
    
    if not ItemSpawnSystem then
        warn("ItemSpawnSystem not available")
        return false
    end
    
    -- Spawn the summoner item
    local itemId = RewardConfig.SUMMONER_REWARD.itemId
    local spawnedItem = ItemSpawnSystem.SpawnItem(itemId, position)
    
    if spawnedItem then
        print("Spawned summoner item at:", position)
        return true
    else
        warn("Failed to spawn summoner item")
        return false
    end
end

-- Spawn the philosopher's stone
function RewardProcessor:SpawnPhilosophersStone(position)
    -- Get the ItemSpawnSystem from global
    local ItemSpawnSystem = _G.ItemSpawnSystem
    
    if not ItemSpawnSystem then
        warn("ItemSpawnSystem not available")
        return false
    end
    
    -- Spawn the philosopher's stone
    local itemId = RewardConfig.PHILOSOPHERS_STONE_REWARD.itemId
    local spawnedItem = ItemSpawnSystem.SpawnItem(itemId, position)
    
    if spawnedItem then
        print("Spawned philosopher's stone at:", position)
        return true
    else
        warn("Failed to spawn philosopher's stone")
        return false
    end
end

-- Clean up sacrificed ragdolls
function RewardProcessor:CleanupSacrifices(sacrifices)
    print("Cleaning up", #sacrifices, "sacrifices")
    
    -- Get the drag server system to clean up drag references
    local DragServerSystem = require(script.Parent.DragServerSystem)
    
    for _, sacrifice in ipairs(sacrifices) do
        if sacrifice and sacrifice.Parent then
            print("Destroying sacrifice:", sacrifice.Name)
            
            -- Clean up any drag references before destroying
            if DragServerSystem and DragServerSystem.CleanupObjectDrags then
                DragServerSystem:CleanupObjectDrags(sacrifice)
            end
            
            sacrifice:Destroy()
        end
    end
end

return RewardProcessor ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="93">
          <Properties>
            <string name="Name">SacrificeValidator</string>
            <string name="Source"><![CDATA[-- SacrificeValidator.luau
-- Simplified sacrifice validation system

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

local AltarConfig = require(ReplicatedStorage.Shared.AltarConfig)

local SacrificeValidator = {}

-- Check if a part is a valid sacrifice
function SacrificeValidator:IsValidSacrifice(part)
    -- Check if the part or its parent has the "Sacrifice" tag
    if CollectionService:HasTag(part, "Sacrifice") then
        return true
    end
    
    -- Check if parent is a sacrifice (for model parts)
    if part.Parent and CollectionService:HasTag(part.Parent, "Sacrifice") then
        return true
    end
    
    -- Check if the part or its parent has the "PlayerSacrifice" tag
    if CollectionService:HasTag(part, "PlayerSacrifice") then
        return true
    end
    
    -- Check if parent is a player sacrifice (for model parts)
    if part.Parent and CollectionService:HasTag(part.Parent, "PlayerSacrifice") then
        return true
    end
    
    return false
end

-- Get the actual sacrifice object (handles model parts)
function SacrificeValidator:GetSacrificeObject(part)
    -- If the part itself is tagged, return it
    if CollectionService:HasTag(part, "Sacrifice") then
        return part
    end
    
    -- If the parent is tagged, return the parent
    if part.Parent and CollectionService:HasTag(part.Parent, "Sacrifice") then
        return part.Parent
    end
    
    -- If the part itself is player sacrifice tagged, return it
    if CollectionService:HasTag(part, "PlayerSacrifice") then
        return part
    end
    
    -- If the parent is player sacrifice tagged, return the parent
    if part.Parent and CollectionService:HasTag(part.Parent, "PlayerSacrifice") then
        return part.Parent
    end
    
    return nil
end

-- Validate sacrifice count
function SacrificeValidator:ValidateSacrificeCount(count)
    return count >= AltarConfig.SETTINGS.requiredSacrifices
end

-- Check if sacrifices are unique (not the same ragdoll counted multiple times)
function SacrificeValidator:AreSacrificesUnique(sacrifices)
    local seen = {}
    for _, sacrifice in ipairs(sacrifices) do
        if seen[sacrifice] then
            return false -- Duplicate found
        end
        seen[sacrifice] = true
    end
    return true
end

return SacrificeValidator ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="94">
          <Properties>
            <string name="Name">TimeManager</string>
            <string name="Source"><![CDATA[local TimeManager = {}

local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")

-- CONFIG
local DAY_LENGTH = 5 * 60 -- seconds
local NIGHT_LENGTH = 5 * 60 -- seconds
local FULL_CYCLE = DAY_LENGTH + NIGHT_LENGTH

-- State
local elapsed = 0
local currentDay = 1
local playerData = {}

-- RemoteEvents (to be set up in shared/RemoteEvents.luau)
local RemoteEvents = require(game:GetService("ReplicatedStorage").Shared.RemoteEvents)

function TimeManager.Init()
	-- Initialize player data
	Players.PlayerAdded:Connect(function(player)
		playerData[player] = {playtime = 0, daysSurvived = 1}
	end)
	Players.PlayerRemoving:Connect(function(player)
		playerData[player] = nil
	end)

	RunService.Heartbeat:Connect(TimeManager.Update)

	-- Listen for stats requests from clients
	RemoteEvents.StatsUpdate.OnServerEvent:Connect(function(player)
		TimeManager.SendStatsToPlayer(player)
	end)
end

function TimeManager.Update(dt)
	elapsed = elapsed + dt
	-- Update Lighting.ClockTime smoothly
	local cycleTime = elapsed % FULL_CYCLE
	local clockTime
	if cycleTime < DAY_LENGTH then
		-- Day: 6 to 18 (Roblox default day)
		clockTime = 6 + (12 * (cycleTime / DAY_LENGTH))
	else
		-- Night: 18 to 30 (wraps to 6)
		local nightTime = cycleTime - DAY_LENGTH
		clockTime = 18 + (12 * (nightTime / NIGHT_LENGTH))
		if clockTime >= 24 then clockTime = clockTime - 24 end
	end
	Lighting.ClockTime = clockTime

	-- Update player playtime and days survived
	for player, data in pairs(playerData) do
		data.playtime = data.playtime + dt
		local newDay = math.floor(elapsed / FULL_CYCLE) + 1
		if newDay > data.daysSurvived then
			data.daysSurvived = newDay
		end
	end

	-- Fire clock update to clients
	RemoteEvents.ClockUpdate:FireAllClients(clockTime)
end

function TimeManager.SendStatsToPlayer(player)
	local data = playerData[player]
	if data then
		RemoteEvents.StatsUpdate:FireClient(player, data.daysSurvived, data.playtime)
	else
		RemoteEvents.StatsUpdate:FireClient(player, 1, 0)
	end
end

function TimeManager.GetPlayerStats(player)
	local data = playerData[player]
	if data then
		return data.daysSurvived, data.playtime
	else
		return 1, 0
	end
end

return TimeManager ]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="95">
        <Properties>
          <string name="Name">TraderHandler</string>
          <string name="Source"><![CDATA[-- TraderHandler.luau
-- Handles server-side trader UI coordination

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local TraderData = require(ReplicatedStorage.Shared.TraderData)
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local ItemMapping = require(ReplicatedStorage.Shared.ItemMapping)
local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)

local TraderHandler = {}

-- Track active trader sessions {[player] = {npcId, startTime}}
TraderHandler.activeTradeSessions = {}

-- Open trader shop for a player
function TraderHandler:OpenShop(player, npcId)
	-- Check if player already has a trade session
	if self.activeTradeSessions[player] then
		print("Player", player.Name, "already has an active trade session")
		return
	end
	
	-- Create trade session
	self.activeTradeSessions[player] = {
		npcId = npcId or "trader",
		startTime = tick()
	}
	
	-- Get trader data for client
	local itemList = TraderData:GetItemList()
	local uiConfig = TraderData.UIConfig
	
	print("Server: Sending trader data to", player.Name)
	print("Server: Item list count:", #itemList)
	print("Server: First item:", itemList[1] and itemList[1].id or "none")
	
	-- Send trader data to client
	RemoteEvents.OpenTraderShop:FireClient(player, {
		items = itemList,
		config = uiConfig,
		npcId = npcId or "trader"
	})
	
	print("Opened trader shop for", player.Name)
end

-- Close trader shop for a player
function TraderHandler:CloseShop(player)
	if self.activeTradeSessions[player] then
		self.activeTradeSessions[player] = nil
		RemoteEvents.CloseTraderShop:FireClient(player)
		print("Closed trader shop for", player.Name)
	end
end

-- Handle player disconnect cleanup
function TraderHandler:HandlePlayerDisconnect(player)
	if self.activeTradeSessions[player] then
		self.activeTradeSessions[player] = nil
		print("Cleaned up trade session for disconnected player", player.Name)
	end
end

-- Process a trade request from a player
function TraderHandler:ProcessTrade(player, itemId)
	print("Processing trade request for player:", player.Name, "item:", itemId)
	
	-- Check if player has an active trade session
	if not self.activeTradeSessions[player] then
		return false, "No active trade session"
	end
	
	-- Get trade requirements
	local requirements = TraderData:GetRequirements(itemId)
	if not requirements or #requirements == 0 then
		return false, "No trade requirements found for item: " .. itemId
	end
	
	-- Get player's inventory from InventoryServerSystem
	local InventoryServerSystem = _G.InventoryServerSystem
	if not InventoryServerSystem then
		return false, "Inventory system not available"
	end
	
	local playerInventory = InventoryServerSystem:GetPlayerInventory(player)
	if not playerInventory then
		return false, "Player inventory not found"
	end
	
	-- Validate trade requirements
	local isValid, validationResults, missingItems = ItemMapping:ValidateTradeRequirements(playerInventory, requirements)
	
	if not isValid then
		local missingItemsText = {}
		for _, missing in ipairs(missingItems) do
			table.insert(missingItemsText, missing.missing .. "x " .. missing.item)
		end
		return false, "Missing items: " .. table.concat(missingItemsText, ", ")
	end
	
	-- Execute the trade
	local success, errorMessage = self:ExecuteTrade(player, itemId, validationResults, playerInventory)
	
	if success then
		print("Trade successful for player:", player.Name, "item:", itemId)
		return true, "Trade completed successfully"
	else
		print("Trade failed for player:", player.Name, "error:", errorMessage)
		return false, errorMessage or "Trade execution failed"
	end
end

-- Execute the actual trade (remove items and spawn new item)
function TraderHandler:ExecuteTrade(player, itemId, validationResults, playerInventory)
	print("Executing trade for player:", player.Name, "item:", itemId)
	
	-- Get required systems
	local InventoryServerSystem = _G.InventoryServerSystem
	local ItemSpawnSystem = _G.ItemSpawnSystem
	
	if not InventoryServerSystem or not ItemSpawnSystem then
		return false, "Required systems not available"
	end
	
	-- Remove required items from inventory
	for requiredItem, validation in pairs(validationResults) do
		if validation.satisfied then
			local itemsToRemove = validation.required
			local slotsToRemove = validation.slots
			
			-- Remove items from the first slots that contain them
			for i = 1, math.min(itemsToRemove, #slotsToRemove) do
				local slot = slotsToRemove[i]
				local inventoryItem = playerInventory[slot]
				
				if inventoryItem and inventoryItem.object then
					-- Destroy the physical object
					inventoryItem.object:Destroy()
					
					-- Remove from inventory
					InventoryServerSystem:RemoveItemBySlot(player, slot)
					
					print("Removed item from slot", slot, ":", inventoryItem.itemName)
				end
			end
		end
	end
	
	-- Get the game item ID for the traded item
	local gameItemId = ItemMapping:GetGameItemId(itemId)
	if not gameItemId then
		-- If no mapping exists, try to use the itemId directly
		gameItemId = itemId
	end
	
	-- Check if the item exists in ItemDefinitions
	local itemDefinition = ItemDefinitions:GetItem(gameItemId)
	if not itemDefinition then
		return false, "Item definition not found: " .. gameItemId
	end
	
	-- Calculate spawn position (near the player)
	local character = player.Character
	local spawnPosition = Vector3.new(0, 10, 0) -- Default position
	
	if character and character:FindFirstChild("HumanoidRootPart") then
		local rootPart = character.HumanoidRootPart
		-- Spawn 5 studs in front of the player
		spawnPosition = rootPart.Position + rootPart.CFrame.LookVector * 5 + Vector3.new(0, 2, 0)
	end
	
	-- Spawn the new item
	local spawnedItem = ItemSpawnSystem:SpawnItem(gameItemId, spawnPosition)
	
	if spawnedItem then
		print("Spawned traded item:", itemDefinition.name, "at position:", spawnPosition)
		
		-- Update client inventory UI
		RemoteEvents.UpdateInventory:FireClient(player, InventoryServerSystem:GetPlayerInventory(player))
		
		return true, "Trade completed successfully"
	else
		return false, "Failed to spawn traded item"
	end
end

-- Initialize the trader handler
function TraderHandler:Initialize()
	-- Set up RemoteEvent connections
	RemoteEvents.CloseTraderShop.OnServerEvent:Connect(function(player)
		self:CloseShop(player)
	end)
	
	-- Set up trade request handling
	RemoteEvents.TradeRequest.OnServerInvoke = function(player, itemId)
		return self:ProcessTrade(player, itemId)
	end
	
	-- Handle player disconnect
	Players.PlayerRemoving:Connect(function(player)
		self:HandlePlayerDisconnect(player)
	end)
	
	print("TraderHandler initialized")
end

return TraderHandler ]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="96">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="97">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="98">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="99">
        <Properties>
          <string name="Name">Client</string>
          <string name="Source">-- Client initialization with comprehensive error handling
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Disable Roblox's default inventory system
StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
print("✅ Disabled Roblox default inventory")

local player = Players.LocalPlayer

-- Wait for character to load with timeout
local function waitForCharacterWithTimeout(timeoutSeconds)
    local startTime = tick()
    
    while not player.Character do
        if tick() - startTime > timeoutSeconds then
            error("Character failed to load within " .. timeoutSeconds .. " seconds")
        end
        wait(0.1)
    end
    
    return player.Character
end

-- Wait for RemoteEvents with validation and timeout
local function waitForRemoteEventsWithTimeout(timeoutSeconds)
    local startTime = tick()
    
    repeat
        local success, result = pcall(function()
            local sharedFolder = ReplicatedStorage:WaitForChild("Shared", 1)
            return require(sharedFolder:WaitForChild("RemoteEvents", 1))
        end)
        
        if success then
            print("✅ RemoteEvents loaded successfully")
            return result
        end
        
        wait(0.1)
    until tick() - startTime > timeoutSeconds
    
    error("RemoteEvents failed to load within " .. timeoutSeconds .. " seconds")
end

-- Initialize with error handling and retries
local function initializeSystemWithRetry(systemName, systemModule, maxRetries, validatePrerequisites)
    maxRetries = maxRetries or 3
    
    for attempt = 1, maxRetries do
        local success, errorMessage = pcall(function()
            -- Validate prerequisites if provided
            if validatePrerequisites then
                local prereqValid, prereqError = pcall(validatePrerequisites)
                if not prereqValid then
                    error("Prerequisites validation failed: " .. tostring(prereqError))
                end
            end
            
            -- Initialize the system
            systemModule:Initialize()
        end)
        
        if success then
            print("✅ " .. systemName .. " initialized successfully" .. (attempt > 1 and " (attempt " .. attempt .. ")" or ""))
            return true
        else
            warn("⚠️ " .. systemName .. " attempt " .. attempt .. " failed: " .. tostring(errorMessage))
            if attempt &lt; maxRetries then
                wait(0.5) -- Wait before retry
            end
        end
    end
    
    error("❌ " .. systemName .. " failed after " .. maxRetries .. " attempts")
end

-- Validate camera system prerequisites
local function validateCameraPrerequisites()
    if not player.Character then
        error("Character not available")
    end
    
    if not workspace.CurrentCamera then
        error("Camera not available")
    end
    
    print("✅ Camera prerequisites validated")
end

-- Validate RemoteEvents-dependent system prerequisites  
local function validateRemoteEventsPrerequisites()
    -- This will be called after RemoteEvents are confirmed loaded
    print("✅ RemoteEvents prerequisites validated")
end

print("🚀 Client starting...")

-- Step 1: Wait for character with timeout
local character = waitForCharacterWithTimeout(30)
print("✅ Character loaded:", character.Name)

-- Step 2: Wait for RemoteEvents with timeout
local RemoteEvents = waitForRemoteEventsWithTimeout(15)

-- Step 3: Initialize systems in proper dependency order
local systemInitializationOrder = {
    -- Critical systems first (no dependencies)
    {
        name = "CameraSystem",
        module = require(script.Systems.CameraSystem),
        maxRetries = 3,
        validatePrerequisites = validateCameraPrerequisites
    },
    
    -- Core systems (depend on camera/character)
    {
        name = "InventorySystem", 
        module = require(script.Systems.InventorySystem),
        maxRetries = 2,
        validatePrerequisites = validateRemoteEventsPrerequisites
    },
    
    -- UI systems (depend on core systems)
    {
        name = "CriticalAttackUI",
        module = require(script.Systems.CriticalAttackUI),
        maxRetries = 2
    },
    
    -- Interaction systems (depend on inventory globals)
    {
        name = "DragSystem",
        module = require(script.Systems.DragSystem),
        maxRetries = 2,
        validatePrerequisites = validateRemoteEventsPrerequisites
    },
    
    {
        name = "HoverSystem",
        module = require(script.Systems.HoverSystem),
        maxRetries = 2
    },
    
    {
        name = "ItemSetupSystem",
        module = require(script.Systems.ItemSetupSystem),
        maxRetries = 2
    },
    
    {
        name = "ArmorSystem",
        module = require(script.Systems.ArmorSystem),
        maxRetries = 2,
        validatePrerequisites = validateRemoteEventsPrerequisites
    },
    
    {
        name = "FunctionalSystem",
        module = require(script.Systems.FunctionalSystem),
        maxRetries = 2
    },
    
    {
        name = "AudioSystem",
        module = require(script.Systems.AudioSystem),
        maxRetries = 2
    },
    
    -- UI components
    {
        name = "Hotbar",
        module = require(script.UI.Hotbar),
        maxRetries = 2
    },
    {
        name = "ClockUI",
        module = require(script.UI.Clock),
        maxRetries = 2
    },
    
    {
        name = "ItemDetailUI",
        module = require(script.ItemDetailUI),
        maxRetries = 2
    },
    
    {
        name = "TraderUI",
        module = require(script.TraderUI),
        maxRetries = 2,
        customInit = function(module)
            local ItemDetailUI = require(script.ItemDetailUI)
            module:Initialize(ItemDetailUI)
        end
    },
    
    {
        name = "DialogueUI",
        module = require(script.DialogueUI),
        maxRetries = 2
    },
    
    -- Altar systems
    {
        name = "AltarUISystem",
        module = require(script.Systems.AltarUISystem),
        maxRetries = 2
    },
    
    {
        name = "SacrificeIndicator",
        module = require(script.Systems.SacrificeIndicator),
        maxRetries = 2
    },
    
    {
        name = "PrayerSystem",
        module = require(script.Systems.PrayerSystem),
        maxRetries = 2
    },
    
    {
        name = "RevivePromptSystem",
        module = require(script.Systems.RevivePromptSystem),
        maxRetries = 2
    },

    -- Projectile system (new)
    {
        name = "ProjectileRenderer",
        module = require(script.ProjectileRenderer),
        maxRetries = 2
    },

    -- Spectate UI (new)
    {
        name = "SpectateUI",
        module = require(script.UI.SpectateUI),
        maxRetries = 2
    },
    
    -- Boss system
    {
        name = "BossUI",
        module = require(script.BossEffects.BossUI),
        maxRetries = 2,
        customInit = function(module)
            module.Initialize()
        end
    },
    
    {
        name = "BossHealthUI",
        module = require(script.BossEffects.BossHealthUI),
        maxRetries = 2,
        customInit = function(module)
            _G.BossHealthUI = module
        end
    }
}

-- Initialize all systems
local initializedSystems = {}
local failedSystems = {}

for _, systemInfo in ipairs(systemInitializationOrder) do
    local success, errorMessage = pcall(function()
        if systemInfo.customInit then
            -- Custom initialization for systems with special requirements
            systemInfo.customInit(systemInfo.module)
        else
            -- Standard initialization with error handling and retries
            initializeSystemWithRetry(
                systemInfo.name, 
                systemInfo.module, 
                systemInfo.maxRetries,
                systemInfo.validatePrerequisites
            )
        end
    end)
    
    if success then
        table.insert(initializedSystems, systemInfo.name)
    else
        table.insert(failedSystems, {name = systemInfo.name, error = tostring(errorMessage)})
        warn("❌ CRITICAL: " .. systemInfo.name .. " failed to initialize: " .. tostring(errorMessage))
    end
end

-- Initialize ability renderers (non-critical)
local abilityRenderers = {
    LaserEyeRenderer = require(script.AbilityRenderers.LaserEyeRenderer),
    MissileRenderer = require(script.AbilityRenderers.MissileRenderer),
    OrbitalStrikeRenderer = require(script.AbilityRenderers.OrbitalStrikeRenderer),
    RippleSquareRenderer = require(script.AbilityRenderers.RippleSquareRenderer)
}

print("✅ Ability renderers loaded")

-- Set up boss system connections with error handling
local function setupBossConnections()
    local success, errorMessage = pcall(function()
        -- Wait for BossAbilities RemoteEvent
        local bossAbilitiesRemote = ReplicatedStorage:WaitForChild("BossAbilities", 10)
        
        -- Get BossHealthUI reference
        local BossHealthUI = _G.BossHealthUI
        if not BossHealthUI then
            warn("BossHealthUI not found in global scope")
        end
        
        -- Check if RemoteEvents exist before connecting
        if RemoteEvents.BossLanded then
            -- Boss landed screen shake and health bar connection
            RemoteEvents.BossLanded.OnClientEvent:Connect(function(bossData)
                print("Boss landed! Triggering screen shake and showing health bar.")
                
                -- Trigger screen shake
                local cameraSystem = _G.CameraSystem
                if cameraSystem then
                    cameraSystem:StartShake(3.0, 1.0, 30)
                else
                    warn("CameraSystem not found for screen shake")
                end
                
                -- Show boss health bar with boss data
                if BossHealthUI then
                    local health = (bossData and bossData.health) or 1000
                    local maxHealth = (bossData and bossData.maxHealth) or 1000
                    local name = (bossData and bossData.name) or "Boss"
                    BossHealthUI:Show(health, maxHealth, name)
                end
            end)
        else
            warn("BossLanded RemoteEvent not found")
        end
        
        -- Boss health update connection
        if RemoteEvents.BossHealthUpdate then
            RemoteEvents.BossHealthUpdate.OnClientEvent:Connect(function(healthData)
                if BossHealthUI and BossHealthUI:IsVisible() then
                    BossHealthUI:UpdateHealth(healthData.health, healthData.maxHealth)
                end
            end)
        else
            warn("BossHealthUpdate RemoteEvent not found")
        end
        
        -- Boss ability visual effects connection with batch support
        if bossAbilitiesRemote then
            bossAbilitiesRemote.OnClientEvent:Connect(function(abilityData)
                -- PERFORMANCE OPTIMIZATION: Handle batched events
                if abilityData.isBatch and abilityData.batchedEvents then
                    -- Process all events in the batch
                    for _, event in ipairs(abilityData.batchedEvents) do
                        if event.abilityType == "trackingShot" then
                            if event.phase == "missile" then
                                abilityRenderers.MissileRenderer.handleMissile(event)
                            else
                                abilityRenderers.LaserEyeRenderer.handleLaserUpdate(event)
                            end
                        elseif event.abilityType == "orbitalStrike" then
                            abilityRenderers.OrbitalStrikeRenderer.handleOrbitalStrike(event)
                        elseif event.abilityType == "rippleSquares" then
                            abilityRenderers.RippleSquareRenderer.handleRippleSquares(event)
                        end
                    end
                else
                    -- Handle single event (immediate or unbatched)
                    if abilityData.abilityType == "trackingShot" then
                        if abilityData.phase == "missile" then
                            abilityRenderers.MissileRenderer.handleMissile(abilityData)
                        else
                            abilityRenderers.LaserEyeRenderer.handleLaserUpdate(abilityData)
                        end
                    elseif abilityData.abilityType == "orbitalStrike" then
                        abilityRenderers.OrbitalStrikeRenderer.handleOrbitalStrike(abilityData)
                    elseif abilityData.abilityType == "rippleSquares" then
                        abilityRenderers.RippleSquareRenderer.handleRippleSquares(abilityData)
                    elseif abilityData.abilityType == "bossSpawned" then
                        print("Boss spawned - showing boss UI")
                    elseif abilityData.abilityType == "bossDestroyed" then
                        print("Boss destroyed - hiding boss UI and health bar")
                        abilityRenderers.LaserEyeRenderer.cleanup()
                        abilityRenderers.MissileRenderer.cleanup()
                        abilityRenderers.OrbitalStrikeRenderer.cleanup()
                        abilityRenderers.RippleSquareRenderer.cleanup()
                        
                        -- Hide boss health bar
                        if BossHealthUI then
                            BossHealthUI:Hide()
                        end
                    end
                end
            end)
        else
            warn("BossAbilities RemoteEvent not found")
        end
        
        print("✅ Boss system connections established")
    end)
    
    if not success then
        warn("❌ Boss system connections failed: " .. tostring(errorMessage))
    end
end

setupBossConnections()

-- Final initialization report
print("🎯 CLIENT INITIALIZATION COMPLETE")
print("✅ Successfully initialized systems:", table.concat(initializedSystems, ", "))

if #failedSystems > 0 then
    warn("❌ Failed systems:")
    for _, failed in ipairs(failedSystems) do
        warn("  - " .. failed.name .. ": " .. failed.error)
    end
    
    if #failedSystems >= 3 then
        error("Too many critical systems failed - game may be unplayable")
    end
else
    print("🎉 All systems initialized successfully!")
end</string>
        </Properties>
        <Item class="Folder" referent="100">
          <Properties>
            <string name="Name">AbilityRenderers</string>
          </Properties>
          <Item class="ModuleScript" referent="101">
            <Properties>
              <string name="Name">LaserEyeRenderer</string>
              <string name="Source"><![CDATA[local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local BossConfig = require(game.ReplicatedStorage.Shared.BossConfig)

local localPlayer = Players.LocalPlayer

-- Renderer state
local laserBeam = nil
local currentTarget = nil
local activeConnection = nil
local blinkTween = nil
local isBlinking = false
local lockOnAchieved = false

local LaserEyeRenderer = {}

local function createLaserBeam(startPos: Vector3, endPos: Vector3)
    -- Create start part and attachment
    local startPart = Instance.new("Part")
    startPart.Name = "LaserStart"
    startPart.Size = Vector3.new(0.1, 0.1, 0.1)
    startPart.Transparency = 1
    startPart.Anchored = true
    startPart.CanCollide = false
    startPart.Position = startPos
    startPart.Parent = workspace
    
    local startAttachment = Instance.new("Attachment")
    startAttachment.Parent = startPart
    
    -- Create end part and attachment
    local endPart = Instance.new("Part")
    endPart.Name = "LaserEnd"
    endPart.Size = Vector3.new(0.1, 0.1, 0.1)
    endPart.Transparency = 1
    endPart.Anchored = true
    endPart.CanCollide = false
    endPart.Position = endPos
    endPart.Parent = workspace
    
    local endAttachment = Instance.new("Attachment")
    endAttachment.Parent = endPart
    
    -- Create the laser beam
    local config = BossConfig.abilities.trackingShot
    local beam = Instance.new("Beam")
    beam.Name = "LaserEye"
    beam.Attachment0 = startAttachment
    beam.Attachment1 = endAttachment
    beam.Color = ColorSequence.new(config.laserColor)
    beam.Transparency = NumberSequence.new(config.laserTransparency)
    beam.Width0 = config.laserWidth
    beam.Width1 = config.laserWidth
    beam.FaceCamera = true
    beam.Parent = startPart
    
    -- Add particle effects at laser end
    local particles = Instance.new("ParticleEmitter")
    particles.Color = ColorSequence.new(config.laserColor)
    particles.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.3),
        NumberSequenceKeypoint.new(1, 0)
    }
    particles.Lifetime = NumberRange.new(0.1, 0.3)
    particles.Rate = config.particleRate
    particles.SpreadAngle = Vector2.new(45, 45)
    particles.Speed = NumberRange.new(2, 5)
    particles.Parent = endAttachment
    
    return {
        beam = beam,
        startAttachment = startAttachment,
        endAttachment = endAttachment
    }
end

local function updateLaserPosition(bossPos: Vector3, targetPos: Vector3)
    if not laserBeam then return end
    
    -- Raycast from boss to target to check for obstacles
    local direction = (targetPos - bossPos)
    local distance = direction.Magnitude
    local rayDirection = direction.Unit * distance
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Boss")} -- Don't hit the boss itself
    
    local raycastResult = workspace:Raycast(bossPos, rayDirection, raycastParams)
    
    local finalEndPos = targetPos
    if raycastResult then
        -- Hit something, stop the beam at the hit point
        finalEndPos = raycastResult.Position
    end
    
    -- Update positions
    local startPart = laserBeam.startAttachment.Parent :: Part
    local endPart = laserBeam.endAttachment.Parent :: Part
    if startPart and endPart then
        startPart.Position = bossPos
        endPart.Position = finalEndPos
    end
end

local function getTargetPosition(targetPlayer: Player): Vector3?
    if targetPlayer == localPlayer then
        -- Use own real-time position for smooth tracking
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart") :: BasePart
            return rootPart.Position
        end
    else
        -- Use last known replicated position for other players
        if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") :: BasePart
            return rootPart.Position
        end
    end
    return nil
end

local function startBlinkingEffect(blinkCount: number)
    if not laserBeam or isBlinking then return end
    
    isBlinking = true
    local config = BossConfig.abilities.trackingShot
    local blinkSpeed = config.blinkSpeed
    local blinkTransparency = config.blinkTransparency
    
    task.spawn(function()
        for i = 1, blinkCount do
            -- Blink on (more visible)
            laserBeam.beam.Transparency = NumberSequence.new(blinkTransparency[1])
            task.wait(blinkSpeed / 2)
            
            -- Blink off (less visible)
            laserBeam.beam.Transparency = NumberSequence.new(blinkTransparency[2])
            task.wait(blinkSpeed / 2)
        end
        
        isBlinking = false
    end)
end

local function cleanupLaser()
    if activeConnection then
        activeConnection:Disconnect()
        activeConnection = nil
    end
    
    if blinkTween then
        blinkTween:Cancel()
        blinkTween = nil
    end
    
    if laserBeam then
        local startPart = laserBeam.startAttachment.Parent
        local endPart = laserBeam.endAttachment.Parent
        if startPart then startPart:Destroy() end
        if endPart then endPart:Destroy() end
        laserBeam = nil
    end
    
    currentTarget = nil
    isBlinking = false
end

-- Public functions
function LaserEyeRenderer.handleLaserUpdate(data)
    if data.phase == "tracking" then
        -- Cleanup any existing laser first
        if laserBeam then
            cleanupLaser()
        end
        
        lockOnAchieved = false
        
        -- Start tracking phase
        local targetPlayer = Players:GetPlayerByUserId(data.targetPlayerId)
        if not targetPlayer then return end
        
        currentTarget = targetPlayer
        
        -- Get initial positions
        local targetPos = getTargetPosition(targetPlayer)
        if not targetPos then return end
        
        -- Create laser beam (red for tracking)
        laserBeam = createLaserBeam(data.bossPosition, targetPos)
        
        -- Start real-time tracking
        activeConnection = RunService.Heartbeat:Connect(function()
            if not currentTarget then return end
            
            local newTargetPos = getTargetPosition(currentTarget)
            if newTargetPos then
                -- Get current boss position from workspace
                local boss = workspace:FindFirstChild("Boss")
                local bossPos = data.bossPosition
                if boss and boss:FindFirstChild("HumanoidRootPart") then
                    local bossRootPart = boss:FindFirstChild("HumanoidRootPart") :: BasePart
                    bossPos = bossRootPart.Position
                end
                updateLaserPosition(bossPos, newTargetPos)
            end
        end)
        
    elseif data.phase == "lockOnAttempt" then
        -- Start lock-on blinking sequence
        if data.blinkCount then
            startBlinkingEffect(data.blinkCount)
        end
        
    elseif data.phase == "lockOnSuccess" then
        -- Lock-on achieved - change laser color to orange
        lockOnAchieved = true
        if laserBeam then
            local config = BossConfig.abilities.trackingShot
            laserBeam.beam.Color = ColorSequence.new(config.lockOnColor)
            print("Lock-on successful - laser color changed")
        end
        
    elseif data.phase == "lockOnFailed" then
        -- Lock-on failed - cleanup laser
        print("Lock-on failed - no missile will be launched")
        cleanupLaser()
        
    elseif data.phase == "missileLaunch" then
        -- Missile launched - cleanup laser
        print("Missile launched - cleaning up laser")
        cleanupLaser()
        
    elseif data.phase == "missile" then
        -- This is handled by MissileRenderer, not LaserEyeRenderer
        -- But we should cleanup any remaining laser just in case
        cleanupLaser()
        
    elseif data.phase == "inactive" then
        cleanupLaser()
    end
end

function LaserEyeRenderer.cleanup()
    cleanupLaser()
end

function LaserEyeRenderer.isActive(): boolean
    return laserBeam ~= nil
end

return LaserEyeRenderer ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="102">
            <Properties>
              <string name="Name">MissileRenderer</string>
              <string name="Source"><![CDATA[-- Missile Renderer - Client-side visual effects for missiles
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)

local MissileRenderer = {}

-- Types
type MissileVisual = {
    id: string,
    model: Model,
    position: Vector3,
    velocity: Vector3,
    target: Player?,
    lastServerPosition: Vector3?,
    currentServerPosition: Vector3?,
    lastUpdateTime: number,
    trail: ParticleEmitter?
}

-- Private variables
local localPlayer = Players.LocalPlayer
local activeMissiles: {[string]: MissileVisual} = {}
local updateConnection: RBXScriptConnection?

-- Private functions
local function createMissileModel(position: Vector3, velocity: Vector3): Model
    local config = BossConfig.abilities.trackingShot
    
    -- Create missile model
    local missile = Instance.new("Model")
    missile.Name = "Missile"
    missile.Parent = workspace
    
    -- Main body
    local body = Instance.new("Part")
    body.Name = "Body"
    body.Size = config.missileSize
    body.Shape = Enum.PartType.Block
    body.Material = Enum.Material.Metal
    body.Color = config.missileColor
    body.Anchored = true
    body.CanCollide = false
    body.Position = position
    body.Parent = missile
    
    -- Point missile in direction of velocity
    if velocity.Magnitude > 0 then
        body.CFrame = CFrame.lookAt(position, position + velocity.Unit)
    end
    
    -- Add glowing effect
    local pointLight = Instance.new("PointLight")
    pointLight.Color = config.trailColor
    pointLight.Brightness = 2
    pointLight.Range = 10
    pointLight.Parent = body
    
    -- Add trail effect
    local trail = Instance.new("ParticleEmitter")
    trail.Color = ColorSequence.new(config.trailColor)
    trail.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(1, 0)
    }
    trail.Lifetime = NumberRange.new(0.3, 0.8)
    trail.Rate = config.trailLength
    trail.SpreadAngle = Vector2.new(10, 10)
    trail.Speed = NumberRange.new(1, 3)
    trail.Acceleration = Vector3.new(0, -5, 0) -- Gravity effect on particles
    trail.Parent = body
    
    return missile
end

local function interpolatePosition(missile: MissileVisual, deltaTime: number): Vector3
    local currentTime = tick()
    
    -- Check if we have server data to interpolate between
    if not missile.lastServerPosition or not missile.currentServerPosition then
        -- No server data yet, stay at current position
        return missile.position
    end
    
    -- Calculate interpolation progress
    local timeSinceUpdate = currentTime - missile.lastUpdateTime
    local updateInterval = 1 / 30 -- 30Hz server updates
    local alpha = math.min(timeSinceUpdate / updateInterval, 1)
    
    -- Smooth interpolation with easing
    local easedAlpha = alpha * alpha * (3 - 2 * alpha) -- Smoothstep easing
    
    -- Interpolate position
    local interpolatedPosition = missile.lastServerPosition:Lerp(missile.currentServerPosition, easedAlpha)
    
    -- If we've reached the target, extrapolate slightly using velocity
    if alpha >= 1 and missile.velocity.Magnitude > 0 then
        local extrapolationTime = timeSinceUpdate - updateInterval
        interpolatedPosition = interpolatedPosition + (missile.velocity * extrapolationTime * 0.5) -- Gentle extrapolation
    end
    
    return interpolatedPosition
end

local function updateMissileVisuals(deltaTime: number)
    local currentTime = tick()
    
    for missileId, missile in pairs(activeMissiles) do
        if not missile.model or not missile.model.Parent then
            -- Model was destroyed, cleanup
            activeMissiles[missileId] = nil
            continue
        end
        
        -- Pure server interpolation - no competing prediction
        local newPosition = interpolatePosition(missile, deltaTime)
        missile.position = newPosition
        
        -- Update model position and rotation
        local body = missile.model:FindFirstChild("Body") :: Part?
        if body then
            body.Position = newPosition
            
            -- Point missile in direction of velocity
            if missile.velocity.Magnitude > 0 then
                body.CFrame = CFrame.lookAt(newPosition, newPosition + missile.velocity.Unit)
            end
        end
    end
    
    -- Stop updates if no missiles
    if next(activeMissiles) == nil and updateConnection then
        updateConnection:Disconnect()
        updateConnection = nil
        print("All missiles finished - stopping visual updates")
    end
end

local function createExplosionEffect(position: Vector3)
    local config = BossConfig.abilities.trackingShot
    
    -- Create explosion visual
    local explosion = Instance.new("Part")
    explosion.Name = "MissileExplosion"
    explosion.Size = Vector3.new(0.1, 0.1, 0.1)
    explosion.Shape = Enum.PartType.Ball
    explosion.Material = Enum.Material.Neon
    explosion.BrickColor = BrickColor.new("Bright orange")
    explosion.Transparency = 0.2
    explosion.Anchored = true
    explosion.CanCollide = false
    explosion.Position = position
    explosion.Parent = workspace
    
    -- Add light
    local pointLight = Instance.new("PointLight")
    pointLight.Color = Color3.new(1, 0.5, 0)
    pointLight.Brightness = 5
    pointLight.Range = config.explosionRadius
    pointLight.Parent = explosion
    
    -- Expansion animation
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local expandTween = TweenService:Create(explosion, tweenInfo, {
        Size = Vector3.new(config.explosionVisualSize, config.explosionVisualSize, config.explosionVisualSize),
        Transparency = 0.8
    })
    
    local lightTween = TweenService:Create(pointLight, tweenInfo, {
        Range = config.explosionVisualSize,
        Brightness = 1
    })
    
    expandTween:Play()
    lightTween:Play()
    
    -- Particle burst
    local particles = Instance.new("ParticleEmitter")
    particles.Color = ColorSequence.new(Color3.new(1, 0.5, 0))
    particles.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 0)
    }
    particles.Lifetime = NumberRange.new(0.5, 1.5)
    particles.Rate = 200
    particles.SpreadAngle = Vector2.new(180, 180)
    particles.Speed = NumberRange.new(10, 25)
    particles.Acceleration = Vector3.new(0, -20, 0)
    particles.Parent = explosion
    
    -- Burst then stop
    task.wait(0.1)
    particles.Enabled = false
    
    -- Cleanup
    expandTween.Completed:Connect(function()
        explosion:Destroy()
    end)
end

-- Public functions
function MissileRenderer.handleMissile(data: {[string]: any})
    local updateType = data.updateType
    local missileId = data.missileId
    
    if updateType == "spawn" then
        local position = data.position
        local velocity = data.velocity
        local targetId = data.targetId
        
        print("Creating missile visual:", missileId, "at position:", position)
        
        -- Create missile visual
        local model = createMissileModel(position, velocity)
        local target = targetId and Players:GetPlayerByUserId(targetId) or nil
        
        local missile: MissileVisual = {
            id = missileId,
            model = model,
            position = position,
            velocity = velocity,
            target = target,
            lastServerPosition = position,
            currentServerPosition = position,
            lastUpdateTime = tick()
        }
        
        activeMissiles[missileId] = missile
        
        -- Start update loop if not running
        if not updateConnection then
            updateConnection = RunService.Heartbeat:Connect(updateMissileVisuals)
            print("Started missile visual updates")
        end
        
    elseif updateType == "update" then
        local missile = activeMissiles[missileId]
        if missile then
            -- Store previous position for interpolation
            missile.lastServerPosition = missile.currentServerPosition
            missile.currentServerPosition = data.position
            missile.velocity = data.velocity
            missile.lastUpdateTime = tick()
        end
        
    elseif updateType == "explode" then
        local position = data.position
        print("Creating explosion effect at:", position)
        
        createExplosionEffect(position)
        
    elseif updateType == "destroy" then
        local missile = activeMissiles[missileId]
        if missile then
            if missile.model and missile.model.Parent then
                missile.model:Destroy()
            end
            activeMissiles[missileId] = nil
            print("Destroyed missile visual:", missileId)
        end
    end
end

function MissileRenderer.cleanup()
    -- Cleanup all missiles
    for missileId, missile in pairs(activeMissiles) do
        if missile.model and missile.model.Parent then
            missile.model:Destroy()
        end
        activeMissiles[missileId] = nil
    end
    
    if updateConnection then
        updateConnection:Disconnect()
        updateConnection = nil
    end
end

return MissileRenderer ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="103">
            <Properties>
              <string name="Name">OrbitalStrikeRenderer</string>
              <string name="Source"><![CDATA[-- Orbital Strike Renderer - Handles visual effects for orbital strike ability
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)

local OrbitalStrikeRenderer = {}

-- Private variables
local activeCircles: {[number]: {part: BasePart, gui: SurfaceGui, position: Vector3}} = {}
local activeBeams: {[number]: {part: BasePart, beam: Beam}} = {}

-- Private functions
local function createWarningCircle(position: Vector3, index: number): {part: BasePart, gui: SurfaceGui, position: Vector3}
    local config = BossConfig.abilities.orbitalStrike
    
    -- Create invisible part at ground level
    local part = Instance.new("Part")
    part.Name = "OrbitalStrikeWarning_" .. index
    part.Size = Vector3.new(0.1, 0.1, 0.1)
    part.Position = position
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Parent = workspace
    
    -- Create surface GUI for the circle
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Face = Enum.NormalId.Top
    surfaceGui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
    surfaceGui.PixelsPerStud = 10
    surfaceGui.Parent = part
    
    -- Create the warning circle frame
    local circle = Instance.new("Frame")
    circle.Name = "WarningCircle"
    circle.Size = UDim2.new(0, config.visualRadius * 20, 0, config.visualRadius * 20) -- 20 pixels per stud
    circle.Position = UDim2.new(0.5, -config.visualRadius * 10, 0.5, -config.visualRadius * 10)
    circle.BackgroundColor3 = config.circleColor
    circle.BackgroundTransparency = 0.5
    circle.BorderSizePixel = 0
    circle.Parent = surfaceGui
    
    -- Make it circular
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.5, 0)
    corner.Parent = circle
    
    -- Add pulsing animation
    local pulseInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
    local pulseTween = TweenService:Create(circle, pulseInfo, {BackgroundTransparency = 0.8})
    pulseTween:Play()
    
    return {part = part, gui = surfaceGui, position = position}
end

local function createOrbitalBeam(position: Vector3, index: number): {part: BasePart, beam: Beam}
    local config = BossConfig.abilities.orbitalStrike
    
    -- Create beam start position high in the sky
    local skyHeight = 200
    local startPos = Vector3.new(position.X, position.Y + skyHeight, position.Z)
    
    -- Create start attachment part
    local startPart = Instance.new("Part")
    startPart.Name = "MeteorBeam_" .. index
    startPart.Size = Vector3.new(0.1, 0.1, 0.1)
    startPart.Position = startPos
    startPart.Anchored = true
    startPart.CanCollide = false
    startPart.Transparency = 1
    startPart.Parent = workspace
    
    -- Create end attachment part
    local endPart = Instance.new("Part")
    endPart.Name = "MeteorImpact_" .. index
    endPart.Size = Vector3.new(0.1, 0.1, 0.1)
    endPart.Position = position
    endPart.Anchored = true
    endPart.CanCollide = false
    endPart.Transparency = 1
    endPart.Parent = workspace
    
    -- Create attachments
    local startAttachment = Instance.new("Attachment")
    startAttachment.Parent = startPart
    
    local endAttachment = Instance.new("Attachment")
    endAttachment.Parent = endPart
    
    -- Create beam
    local beam = Instance.new("Beam")
    beam.Attachment0 = startAttachment
    beam.Attachment1 = endAttachment
    beam.Color = ColorSequence.new(config.beamColor)
    beam.Width0 = config.visualRadius * 0.5
    beam.Width1 = config.visualRadius * 0.5
    beam.Transparency = NumberSequence.new(0.2)
    beam.FaceCamera = true
    beam.Parent = startPart
    
    -- Create explosion effect at impact
    local explosion = Instance.new("Explosion")
    explosion.Position = position
    explosion.BlastRadius = config.visualRadius
    explosion.BlastPressure = 0 -- No physics effect
    explosion.Parent = workspace
    
    return {part = startPart, beam = beam}
end

-- Public functions
function OrbitalStrikeRenderer.handleOrbitalStrike(data: {[string]: any})
    local phase = data.phase
    local position = data.position
    local index = data.index
    
    if phase == "addCircle" and position and index then
        print("Adding meteor warning circle", index, "at position:", position)
        
        -- Create warning circle for this strike
        local circleData = createWarningCircle(position, index)
        activeCircles[index] = circleData
        
    elseif phase == "fireSingleStrike" and position and index then
        print("Firing meteor strike", index, "at position:", position)
        
        -- Remove warning circle for this strike
        local circleData = activeCircles[index]
        if circleData then
            circleData.part:Destroy()
            activeCircles[index] = nil
        end
        
        -- Create orbital beam for this strike
        local beamData = createOrbitalBeam(position, index)
        activeBeams[index] = beamData
        
    elseif phase == "cleanup" then
        print("Cleaning up meteor shower effects")
        
        -- Clean up any remaining circles
        for index, circleData in pairs(activeCircles) do
            circleData.part:Destroy()
            activeCircles[index] = nil
        end
        
        -- Clean up beams after duration
        for index, beamData in pairs(activeBeams) do
            -- Schedule cleanup
            Debris:AddItem(beamData.part, BossConfig.abilities.orbitalStrike.beamDuration)
            activeBeams[index] = nil
        end
    end
end

function OrbitalStrikeRenderer.cleanup()
    -- Clean up all active effects
    for index, circleData in pairs(activeCircles) do
        circleData.part:Destroy()
        activeCircles[index] = nil
    end
    
    for index, beamData in pairs(activeBeams) do
        beamData.part:Destroy()
        activeBeams[index] = nil
    end
end

return OrbitalStrikeRenderer ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="104">
            <Properties>
              <string name="Name">RippleSquareRenderer</string>
              <string name="Source"><![CDATA[-- Ripple Square Renderer - Handles visual effects for expanding square outlines
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local BossConfig = require(ReplicatedStorage.Shared.BossConfig)

local RippleSquareRenderer = {}

-- Private variables
local activeSquares: {[number]: {parts: {BasePart}, startTime: number}} = {}

-- Find ground level at boss position (identical to server)
local function findGroundLevel(position: Vector3): Vector3
    -- Raycast downward to find ground
    local Players = game:GetService("Players")
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    
    -- Filter out boss AND all player characters
    local filterList = {}
    if workspace:FindFirstChild("Boss") then
        table.insert(filterList, workspace:FindFirstChild("Boss"))
    end
    
    -- Add all player characters to filter
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            table.insert(filterList, player.Character)
        end
    end
    
    raycastParams.FilterDescendantsInstances = filterList
    
    local raycast = workspace:Raycast(Vector3.new(position.X, position.Y + 20, position.Z), Vector3.new(0, -100, 0), raycastParams)
    if raycast then
        -- Debug: Print what we hit
        print("CLIENT Raycast hit:", raycast.Instance.Name, "at Y:", raycast.Position.Y, "Parent:", raycast.Instance.Parent.Name)
        -- Position slightly above ground to ensure visibility
        return Vector3.new(position.X, raycast.Position.Y + 0.1, position.Z)
    else
        -- Debug: Print when no hit
        print("CLIENT Raycast missed - using fallback position")
        -- Fallback to boss Y position minus some height to get to ground level
        return Vector3.new(position.X, position.Y - 5, position.Z)
    end
end

-- Create a visual square outline made of 4 parts
local function createVisualSquareOutline(bossPosition: Vector3, squareIndex: number): {BasePart}
    local config = BossConfig.abilities.rippleSquares
    local parts = {}
    
    -- Find ground level for the squares (matching server exactly)
    local groundPosition = findGroundLevel(bossPosition)
    
    -- Create 4 parts that form a hollow square outline (matching server exactly)
    local partNames = {"Top", "Bottom", "Left", "Right"}
    
    for i, partName in ipairs(partNames) do
        local part = Instance.new("Part")
        part.Name = "RippleSquareVisual_" .. squareIndex .. "_" .. partName
        part.Color = config.visualColor
        part.Material = config.visualMaterial
        part.Transparency = config.visualTransparency
        part.CanCollide = false
        part.Anchored = true
        part.Parent = workspace
        
        -- Position and size the parts to form a hollow square on the ground (identical to server)
        if partName == "Top" then
            part.Size = Vector3.new(config.initialSize.X, config.outlineThickness, config.outlineThickness)
            part.Position = groundPosition + Vector3.new(0, config.outlineThickness/2, config.initialSize.Z/2)
        elseif partName == "Bottom" then
            part.Size = Vector3.new(config.initialSize.X, config.outlineThickness, config.outlineThickness)
            part.Position = groundPosition + Vector3.new(0, config.outlineThickness/2, -config.initialSize.Z/2)
        elseif partName == "Left" then
            part.Size = Vector3.new(config.outlineThickness, config.outlineThickness, config.initialSize.Z)
            part.Position = groundPosition + Vector3.new(-config.initialSize.X/2, config.outlineThickness/2, 0)
        elseif partName == "Right" then
            part.Size = Vector3.new(config.outlineThickness, config.outlineThickness, config.initialSize.Z)
            part.Position = groundPosition + Vector3.new(config.initialSize.X/2, config.outlineThickness/2, 0)
        end
        
        -- Add subtle glow effect
        local pointLight = Instance.new("PointLight")
        pointLight.Color = config.visualColor
        pointLight.Brightness = 0.3
        pointLight.Range = 3
        pointLight.Parent = part
        
        table.insert(parts, part)
    end
    
    return parts
end

-- Animate the visual square outline expansion (matching server exactly)
local function animateVisualExpansion(parts: {BasePart}, bossPosition: Vector3, squareIndex: number)
    local config = BossConfig.abilities.rippleSquares
    
    -- Find ground level for expansion targets (matching server exactly)
    local groundPosition = findGroundLevel(bossPosition)
    
    -- Create expansion tween for each part (identical to server timing)
    local tweenInfo = TweenInfo.new(
        config.expansionDuration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out
    )
    
    for i, part in ipairs(parts) do
        local partName = part.Name:match("_(%w+)$") -- Extract part name (Top, Bottom, etc.)
        local targetSize
        local targetPosition
        
        -- Calculate target size and position (identical to server)
        if partName == "Top" then
            targetSize = Vector3.new(config.maxSize.X, config.outlineThickness, config.outlineThickness)
            targetPosition = groundPosition + Vector3.new(0, config.outlineThickness/2, config.maxSize.Z/2)
        elseif partName == "Bottom" then
            targetSize = Vector3.new(config.maxSize.X, config.outlineThickness, config.outlineThickness)
            targetPosition = groundPosition + Vector3.new(0, config.outlineThickness/2, -config.maxSize.Z/2)
        elseif partName == "Left" then
            targetSize = Vector3.new(config.outlineThickness, config.outlineThickness, config.maxSize.Z)
            targetPosition = groundPosition + Vector3.new(-config.maxSize.X/2, config.outlineThickness/2, 0)
        elseif partName == "Right" then
            targetSize = Vector3.new(config.outlineThickness, config.outlineThickness, config.maxSize.Z)
            targetPosition = groundPosition + Vector3.new(config.maxSize.X/2, config.outlineThickness/2, 0)
        end
        
        -- Create and play the expansion tween
        local sizeTween = TweenService:Create(part, tweenInfo, {Size = targetSize})
        local positionTween = TweenService:Create(part, tweenInfo, {Position = targetPosition})
        
        -- Add fade out effect as it expands
        local fadeTween = TweenService:Create(part, tweenInfo, {Transparency = 1})
        
        sizeTween:Play()
        positionTween:Play()
        fadeTween:Play()
        
        -- Cleanup when expansion completes
        if i == 1 then -- Only need to connect once per square
            sizeTween.Completed:Connect(function()
                -- Remove all parts of this square
                for _, squarePart in ipairs(parts) do
                    if squarePart and squarePart.Parent then
                        squarePart:Destroy()
                    end
                end
            end)
        end
    end
end

-- Public functions
function RippleSquareRenderer.handleRippleSquares(data: {[string]: any})
    local phase = data.phase
    local bossPosition = data.bossPosition
    local squareIndex = data.squareIndex
    
    if phase == "start" then
        print("Starting expanding square ripples visual effect")
        -- Could add initial boss effect here (like a brief glow)
        
    elseif phase == "spawnSquare" and bossPosition and squareIndex then
        print("Spawning visual expanding square", squareIndex)
        
        -- Create visual square outline
        local parts = createVisualSquareOutline(bossPosition, squareIndex)
        activeSquares[squareIndex] = {
            parts = parts,
            startTime = tick()
        }
        
        -- Start expansion animation
        animateVisualExpansion(parts, bossPosition, squareIndex)
        
    elseif phase == "cleanup" then
        print("Cleaning up expanding square ripples visual effects")
        
        -- Clean up any remaining squares
        for squareIndex, squareData in pairs(activeSquares) do
            for _, part in ipairs(squareData.parts) do
                if part and part.Parent then
                    -- Add quick disappear animation
                    local disappearTween = TweenService:Create(
                        part,
                        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
                        {Transparency = 1}
                    )
                    disappearTween:Play()
                    
                    -- Destroy after animation
                    disappearTween.Completed:Connect(function()
                        if part and part.Parent then
                            part:Destroy()
                        end
                    end)
                end
            end
            activeSquares[squareIndex] = nil
        end
    end
end

function RippleSquareRenderer.cleanup()
    -- Clean up all active squares
    for squareIndex, squareData in pairs(activeSquares) do
        for _, part in ipairs(squareData.parts) do
            if part and part.Parent then
                part:Destroy()
            end
        end
        activeSquares[squareIndex] = nil
    end
end

return RippleSquareRenderer ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="105">
          <Properties>
            <string name="Name">BossEffects</string>
          </Properties>
          <Item class="ModuleScript" referent="106">
            <Properties>
              <string name="Name">BossHealthUI</string>
              <string name="Source"><![CDATA[-- BossHealthUI.luau
-- Legend of Zelda: Breath of the Wild style boss health bar

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local BossHealthUI = {}

-- UI State
local isVisible = false
local currentHealth = 0
local maxHealth = 0
local bossName = "Boss"
local healthStacks = 1 -- For multi-phase bosses (x2, x3, etc.)
local currentStack = 1

-- UI Components
local screenGui = nil
local mainFrame = nil
local bossNameLabel = nil
local healthBarFrame = nil
local healthBarFill = nil
local multiplierLabel = nil

-- Configuration - Authentic BotW Style
local CONFIG = {
    -- Health bar dimensions (authentic BotW - thinner bar)
    BAR_WIDTH = 480,
    BAR_HEIGHT = 8, -- Much thinner like real BotW
    CORNER_RADIUS = 4, -- Proportional to thinner bar
    
    -- BotW Color Scheme
    ACTIVE_HEALTH_COLOR = Color3.fromRGB(255, 200, 50), -- Bright yellow/orange
    EMPTY_HEALTH_COLOR = Color3.fromRGB(60, 60, 60), -- Dark gray
    BAR_BACKGROUND_COLOR = Color3.fromRGB(25, 25, 25), -- Very dark background
    BAR_BORDER_COLOR = Color3.fromRGB(200, 200, 200), -- Light gray border
    
    -- Typography (BotW style)
    NAME_COLOR = Color3.fromRGB(255, 255, 255),
    NAME_OUTLINE_COLOR = Color3.fromRGB(0, 0, 0),
    MULTIPLIER_COLOR = Color3.fromRGB(255, 200, 50),
    
    -- BotW Positioning
    TOP_MARGIN = 40, -- Closer to top edge
    NAME_HEIGHT = 32, -- Increased height for larger text
    BAR_MARGIN_TOP = 8,
    
    -- Animation timings
    APPEAR_DURATION = 0.6,
    HEALTH_DRAIN_DURATION = 0.4,
    PHASE_TRANSITION_DURATION = 0.8,
    
    -- Transparency states
    IDLE_TRANSPARENCY = 0.15, -- Slight transparency when not taking damage
    ACTIVE_TRANSPARENCY = 0, -- Full opacity when taking damage
    TRANSITION_DURATION = 0.3,
}

-- Create the authentic BotW-style health bar UI
local function createHealthBarUI()
    -- Main screen GUI
    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "BossHealthUI"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.DisplayOrder = 100
    screenGui.Parent = playerGui
    
    -- Main container frame (top-center positioning)
    mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, CONFIG.BAR_WIDTH + 100, 0, CONFIG.NAME_HEIGHT + CONFIG.BAR_HEIGHT + CONFIG.BAR_MARGIN_TOP + 20)
    mainFrame.Position = UDim2.new(0.5, -(CONFIG.BAR_WIDTH + 100) / 2, 0, CONFIG.TOP_MARGIN)
    mainFrame.BackgroundTransparency = 1
    mainFrame.BorderSizePixel = 0
    mainFrame.Visible = false
    mainFrame.Parent = screenGui
    
    -- Boss name label (BotW typography) - Centered on health bar
    bossNameLabel = Instance.new("TextLabel")
    bossNameLabel.Name = "BossNameLabel"
    bossNameLabel.Size = UDim2.new(0, CONFIG.BAR_WIDTH, 0, CONFIG.NAME_HEIGHT) -- Match bar width for perfect centering
    bossNameLabel.Position = UDim2.new(0.5, -CONFIG.BAR_WIDTH / 2, 0, 0) -- Center relative to main frame
    bossNameLabel.BackgroundTransparency = 1
    bossNameLabel.Text = bossName
    bossNameLabel.TextColor3 = CONFIG.NAME_COLOR
    bossNameLabel.TextSize = 24 -- Increased from 20 to 24 for larger text
    bossNameLabel.TextStrokeTransparency = 0.3 -- Subtle outline
    bossNameLabel.TextStrokeColor3 = CONFIG.NAME_OUTLINE_COLOR
    bossNameLabel.Font = Enum.Font.GothamMedium -- Clean, readable font
    bossNameLabel.TextXAlignment = Enum.TextXAlignment.Center
    bossNameLabel.Parent = mainFrame
    
    -- Health stack multiplier (x2, x3, etc.)
    multiplierLabel = Instance.new("TextLabel")
    multiplierLabel.Name = "MultiplierLabel"
    multiplierLabel.Size = UDim2.new(0, 50, 0, CONFIG.NAME_HEIGHT)
    multiplierLabel.Position = UDim2.new(1, -50, 0, 0)
    multiplierLabel.BackgroundTransparency = 1
    multiplierLabel.Text = ""
    multiplierLabel.TextColor3 = CONFIG.MULTIPLIER_COLOR
    multiplierLabel.TextSize = 20 -- Increased from 18 to 20
    multiplierLabel.TextStrokeTransparency = 0.3
    multiplierLabel.TextStrokeColor3 = CONFIG.NAME_OUTLINE_COLOR
    multiplierLabel.Font = Enum.Font.GothamBold
    multiplierLabel.TextXAlignment = Enum.TextXAlignment.Center
    multiplierLabel.Visible = false
    multiplierLabel.Parent = mainFrame
    
    -- Health bar background frame with rounded corners
    healthBarFrame = Instance.new("Frame")
    healthBarFrame.Name = "HealthBarFrame"
    healthBarFrame.Size = UDim2.new(0, CONFIG.BAR_WIDTH, 0, CONFIG.BAR_HEIGHT)
    healthBarFrame.Position = UDim2.new(0.5, -CONFIG.BAR_WIDTH / 2, 0, CONFIG.NAME_HEIGHT + CONFIG.BAR_MARGIN_TOP)
    healthBarFrame.BackgroundColor3 = CONFIG.BAR_BACKGROUND_COLOR
    healthBarFrame.BorderColor3 = CONFIG.BAR_BORDER_COLOR
    healthBarFrame.BorderSizePixel = 1
    healthBarFrame.Parent = mainFrame
    
    -- Rounded corners for health bar background
    local healthBarCorner = Instance.new("UICorner")
    healthBarCorner.CornerRadius = UDim.new(0, CONFIG.CORNER_RADIUS)
    healthBarCorner.Parent = healthBarFrame
    
    -- Health bar fill (smooth continuous bar)
    healthBarFill = Instance.new("Frame")
    healthBarFill.Name = "HealthBarFill"
    healthBarFill.Size = UDim2.new(1, -2, 1, -2) -- Start at full width, subtract border
    healthBarFill.Position = UDim2.new(0, 1, 0, 1) -- Account for border
    healthBarFill.BackgroundColor3 = CONFIG.ACTIVE_HEALTH_COLOR
    healthBarFill.BorderSizePixel = 0
    healthBarFill.Parent = healthBarFrame
    
    -- Rounded corners for health bar fill
    local healthFillCorner = Instance.new("UICorner")
    healthFillCorner.CornerRadius = UDim.new(0, CONFIG.CORNER_RADIUS - 1)
    healthFillCorner.Parent = healthBarFill
    
    print("BossHealthUI: Authentic BotW-style continuous health bar created")
end

-- Update health bar with smooth right-to-left depletion
local function updateHealthBar(healthPercent, animate, showDamageEffect)
    if not healthBarFill then return end
    
    local targetSize = UDim2.new(healthPercent, -2, 1, -2)
    
    if animate then
        -- Set active state for damage feedback
        if showDamageEffect then
            -- Flash effect for damage
            local flashTween = TweenService:Create(healthBarFill,
                TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, true),
                {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}
            )
            flashTween:Play()
            
            -- Reset color after flash
            flashTween.Completed:Connect(function()
                healthBarFill.BackgroundColor3 = CONFIG.ACTIVE_HEALTH_COLOR
            end)
        end
        
        -- Smooth size transition
        local sizeTween = TweenService:Create(healthBarFill,
            TweenInfo.new(CONFIG.HEALTH_DRAIN_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
            {Size = targetSize}
        )
        sizeTween:Play()
    else
        -- Instant update
        healthBarFill.Size = targetSize
        healthBarFill.BackgroundColor3 = CONFIG.ACTIVE_HEALTH_COLOR
    end
end

-- Set transparency state (idle vs active)
local function setTransparencyState(isActive)
    if not mainFrame then return end
    
    local targetTransparency = isActive and CONFIG.ACTIVE_TRANSPARENCY or CONFIG.IDLE_TRANSPARENCY
    
    -- Apply transparency to individual elements since Frame doesn't have GroupTransparency
    if bossNameLabel then
        local nameTween = TweenService:Create(bossNameLabel,
            TweenInfo.new(CONFIG.TRANSITION_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
            {TextTransparency = targetTransparency}
        )
        nameTween:Play()
    end
    
    if healthBarFrame then
        local frameTween = TweenService:Create(healthBarFrame,
            TweenInfo.new(CONFIG.TRANSITION_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
            {BackgroundTransparency = targetTransparency}
        )
        frameTween:Play()
    end
    
    if healthBarFill then
        local fillTween = TweenService:Create(healthBarFill,
            TweenInfo.new(CONFIG.TRANSITION_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
            {BackgroundTransparency = targetTransparency}
        )
        fillTween:Play()
    end
    
    if multiplierLabel and multiplierLabel.Visible then
        local multiplierTween = TweenService:Create(multiplierLabel,
            TweenInfo.new(CONFIG.TRANSITION_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
            {TextTransparency = targetTransparency}
        )
        multiplierTween:Play()
    end
end

-- Update multiplier display
local function updateMultiplierDisplay()
    if not multiplierLabel then return end
    
    if healthStacks > 1 then
        multiplierLabel.Text = "x" .. currentStack
        multiplierLabel.Visible = true
    else
        multiplierLabel.Visible = false
    end
end

-- Public functions
function BossHealthUI:Show(health, maxHp, name, stacks)
    if isVisible then return end
    
    currentHealth = health or 1000
    maxHealth = maxHp or 1000
    bossName = name or "Boss"
    healthStacks = stacks or 1
    currentStack = healthStacks
    
    print("BossHealthUI: Showing authentic BotW health bar -", bossName, "(" .. currentHealth .. "/" .. maxHealth .. ") Stacks:", healthStacks)
    
    -- Create UI if it doesn't exist
    if not screenGui then
        createHealthBarUI()
    end
    
    -- Update boss name and multiplier
    if bossNameLabel then
        bossNameLabel.Text = bossName
    end
    updateMultiplierDisplay()
    
    -- Set initial health
    local healthPercent = currentHealth / maxHealth
    updateHealthBar(healthPercent, false)
    
    -- Show with BotW-style animation
    isVisible = true
    mainFrame.Visible = true
    mainFrame.Position = UDim2.new(0.5, -(CONFIG.BAR_WIDTH + 100) / 2, 0, CONFIG.TOP_MARGIN - 20) -- Start higher
    
    -- Set initial transparency for all elements
    if bossNameLabel then bossNameLabel.TextTransparency = 1 end
    if healthBarFrame then healthBarFrame.BackgroundTransparency = 1 end
    if healthBarFill then healthBarFill.BackgroundTransparency = 1 end
    if multiplierLabel then multiplierLabel.TextTransparency = 1 end
    
    -- Smooth slide-in animation
    local appearTween = TweenService:Create(mainFrame,
        TweenInfo.new(CONFIG.APPEAR_DURATION, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
        {Position = UDim2.new(0.5, -(CONFIG.BAR_WIDTH + 100) / 2, 0, CONFIG.TOP_MARGIN)}
    )
    appearTween:Play()
    
    -- Animate elements appearing
    task.spawn(function()
        task.wait(CONFIG.APPEAR_DURATION * 0.2)
        
        -- Animate name appearing
        if bossNameLabel then
            local nameTween = TweenService:Create(bossNameLabel,
                TweenInfo.new(CONFIG.APPEAR_DURATION * 0.6, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
                {TextTransparency = CONFIG.IDLE_TRANSPARENCY}
            )
            nameTween:Play()
        end
        
        -- Animate health bar frame appearing
        if healthBarFrame then
            local frameTween = TweenService:Create(healthBarFrame,
                TweenInfo.new(CONFIG.APPEAR_DURATION * 0.6, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
                {BackgroundTransparency = CONFIG.IDLE_TRANSPARENCY}
            )
            frameTween:Play()
        end
        
        -- Animate health bar fill appearing (FIX: Added missing transparency animation)
        if healthBarFill then
            local fillTween = TweenService:Create(healthBarFill,
                TweenInfo.new(CONFIG.APPEAR_DURATION * 0.6, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
                {BackgroundTransparency = CONFIG.IDLE_TRANSPARENCY}
            )
            fillTween:Play()
        end
        
        -- Animate multiplier appearing
        if multiplierLabel and multiplierLabel.Visible then
            local multiplierTween = TweenService:Create(multiplierLabel,
                TweenInfo.new(CONFIG.APPEAR_DURATION * 0.6, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
                {TextTransparency = CONFIG.IDLE_TRANSPARENCY}
            )
            multiplierTween:Play()
        end
        
        -- Animate health bar fill appearing
        task.wait(CONFIG.APPEAR_DURATION * 0.2)
        updateHealthBar(healthPercent, true, false)
    end)
end

function BossHealthUI:Hide()
    if not isVisible then return end
    
    print("BossHealthUI: Hiding authentic BotW health bar")
    isVisible = false
    
    if mainFrame then
        -- Animate individual elements disappearing
        if bossNameLabel then
            local nameTween = TweenService:Create(bossNameLabel,
                TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
                {TextTransparency = 1}
            )
            nameTween:Play()
        end
        
        if healthBarFrame then
            local frameTween = TweenService:Create(healthBarFrame,
                TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
                {BackgroundTransparency = 1}
            )
            frameTween:Play()
        end
        
        if healthBarFill then
            local fillTween = TweenService:Create(healthBarFill,
                TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
                {BackgroundTransparency = 1}
            )
            fillTween:Play()
        end
        
        if multiplierLabel then
            local multiplierTween = TweenService:Create(multiplierLabel,
                TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
                {TextTransparency = 1}
            )
            multiplierTween:Play()
        end
        
        -- Animate position
        local hideTween = TweenService:Create(mainFrame,
            TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
            {Position = UDim2.new(0.5, -(CONFIG.BAR_WIDTH + 100) / 2, 0, CONFIG.TOP_MARGIN - 20)}
        )
        hideTween:Play()
        
        hideTween.Completed:Connect(function()
            mainFrame.Visible = false
        end)
    end
end

function BossHealthUI:UpdateHealth(newHealth, newMaxHealth)
    if not isVisible then return end
    
    local previousHealth = currentHealth
    currentHealth = newHealth or currentHealth
    maxHealth = newMaxHealth or maxHealth
    
    local healthPercent = currentHealth / maxHealth
    
    print("BossHealthUI: Updating health to", currentHealth .. "/" .. maxHealth, "(" .. math.floor(healthPercent * 100) .. "%)")
    
    -- Set active state for damage feedback
    setTransparencyState(true)
    
    -- Check for phase transition (health bar fully depleted)
    if healthPercent <= 0 and currentStack > 1 then
        -- Phase transition - new health bar
        task.spawn(function()
            task.wait(CONFIG.PHASE_TRANSITION_DURATION * 0.3)
            currentStack = currentStack - 1
            updateMultiplierDisplay()
            
            -- Reset to full health for next phase
            currentHealth = maxHealth
            updateHealthBar(1.0, true, false)
        end)
    else
        -- Normal health update with damage effect
        task.spawn(function()
            updateHealthBar(healthPercent, true, previousHealth > currentHealth)
        end)
    end
    
    -- Return to idle state after damage
    task.spawn(function()
        task.wait(1.0) -- Stay active for 1 second
        setTransparencyState(false)
    end)
end

function BossHealthUI:IsVisible()
    return isVisible
end

function BossHealthUI:Cleanup()
    if screenGui then
        screenGui:Destroy()
        screenGui = nil
        mainFrame = nil
        bossNameLabel = nil
        healthBarFrame = nil
        healthBarFill = nil
        multiplierLabel = nil
    end
    isVisible = false
    currentStack = 1
    healthStacks = 1
    print("BossHealthUI: Cleaned up")
end

-- Initialize
print("BossHealthUI: Authentic BotW-style module loaded")

return BossHealthUI ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="107">
            <Properties>
              <string name="Name">BossUI</string>
              <string name="Source"><![CDATA[-- Boss UI - Client-side boss visual effects and UI
local BossUI = {}

-- Initialize the boss UI system
function BossUI.Initialize()
    print("Boss UI system initialized")
    -- Additional initialization will be added here
end

return BossUI ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="108">
          <Properties>
            <string name="Name">DialogueUI</string>
            <string name="Source"><![CDATA[-- DialogueUI.luau
-- Handles client-side dialogue UI and interactions

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local DialogueUI = {}

-- Track active dialogue state
DialogueUI.activeDialogue = nil
DialogueUI.activeBillboard = nil
DialogueUI.modalButton = nil -- Track modal button for cursor management

-- Create BOTW-style dialogue system with main dialogue box at bottom
function DialogueUI:CreateDialogueSystem()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "BOTWDialogueSystem"
	screenGui.ResetOnSpawn = false
	screenGui.IgnoreGuiInset = true
	screenGui.Parent = player.PlayerGui
	
	-- Speaker name container (above main dialogue box)
	local speakerContainer = Instance.new("Frame")
	speakerContainer.Name = "SpeakerContainer"
	speakerContainer.Size = UDim2.new(0, 200, 0, 35)
	speakerContainer.Position = UDim2.new(0.5, -100, 1, -200) -- Above main dialogue box
	speakerContainer.BackgroundTransparency = 1 -- Fully transparent - no bubble
	speakerContainer.BorderSizePixel = 0
	speakerContainer.Parent = screenGui
	
	-- Speaker name label
	local speakerLabel = Instance.new("TextLabel")
	speakerLabel.Name = "SpeakerName"
	speakerLabel.Size = UDim2.new(1, -16, 1, -8)
	speakerLabel.Position = UDim2.new(0, 8, 0, 4)
	speakerLabel.BackgroundTransparency = 1
	speakerLabel.Text = "Speaker"
	speakerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	speakerLabel.TextSize = 16
	speakerLabel.TextWrapped = true
	speakerLabel.Font = Enum.Font.GothamBold
	speakerLabel.TextXAlignment = Enum.TextXAlignment.Center
	speakerLabel.Parent = speakerContainer
	
	-- Main dialogue box (bottom center of screen)
	local dialogueBox = Instance.new("Frame")
	dialogueBox.Name = "MainDialogueBox"
	dialogueBox.Size = UDim2.new(0, 800, 0, 150) -- Wide rectangular shape
	dialogueBox.Position = UDim2.new(0.5, -400, 1, -170) -- Bottom center, low enough to see characters
	dialogueBox.BackgroundColor3 = Color3.fromRGB(45, 45, 45) -- Muted grey
	dialogueBox.BackgroundTransparency = 0.25 -- Semi-transparent to see game world
	dialogueBox.BorderSizePixel = 0
	dialogueBox.Parent = screenGui
	
	-- Main dialogue box corner rounding
	local dialogueCorner = Instance.new("UICorner")
	dialogueCorner.CornerRadius = UDim.new(0, 12) -- Gently rounded corners
	dialogueCorner.Parent = dialogueBox
	
	-- Dialogue text area
	local textArea = Instance.new("TextLabel")
	textArea.Name = "DialogueText"
	textArea.Size = UDim2.new(1, -40, 1, -30)
	textArea.Position = UDim2.new(0, 20, 0, 15)
	textArea.BackgroundTransparency = 1
	textArea.Text = ""
	textArea.TextColor3 = Color3.fromRGB(255, 255, 255)
	textArea.TextSize = 18
	textArea.TextWrapped = true
	textArea.Font = Enum.Font.Gotham -- Clean, legible font
	textArea.TextXAlignment = Enum.TextXAlignment.Left
	textArea.TextYAlignment = Enum.TextYAlignment.Top
	textArea.Parent = dialogueBox
	
	-- Choice container (to the right of main dialogue box)
	local choiceContainer = Instance.new("Frame")
	choiceContainer.Name = "ChoiceContainer"
	choiceContainer.Size = UDim2.new(0, 350, 0, 200) -- Narrower width to fit on right side
	choiceContainer.Position = UDim2.new(0.5, 420, 1, -245) -- To the right of dialogue box, vertically centered with it
	choiceContainer.BackgroundTransparency = 1 -- Invisible container
	choiceContainer.Parent = screenGui
	
	-- Layout for choice boxes (vertical list)
	local choiceLayout = Instance.new("UIListLayout")
	choiceLayout.FillDirection = Enum.FillDirection.Vertical
	choiceLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	choiceLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	choiceLayout.Padding = UDim.new(0, 8) -- Spacing between choices
	choiceLayout.Parent = choiceContainer
	
	return screenGui, dialogueBox, textArea, speakerLabel, choiceContainer
end

-- Clear/remove dialogue system
function DialogueUI:ClearDialogueSystem()
	local existingSystem = player.PlayerGui:FindFirstChild("BOTWDialogueSystem")
	if existingSystem then
		existingSystem:Destroy()
	end
	
	-- Clear modal button reference since it's destroyed with the system
	self.modalButton = nil
end

-- Create BOTW-style individual choice box
function DialogueUI:CreateChoiceBox(choiceText, choiceIndex, container, npcId)
	local button = Instance.new("TextButton")
	button.Name = "ChoiceBox" .. choiceIndex
	button.Size = UDim2.new(0, 320, 0, 35) -- Shorter and narrower to fit in right-side container
	button.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Muted grey like main dialogue box
	button.BackgroundTransparency = 0.3 -- Semi-transparent
	button.BorderSizePixel = 0
	button.Text = choiceText
	button.TextColor3 = Color3.fromRGB(255, 255, 255)
	button.TextSize = 14 -- Slightly smaller text size to fit better
	button.TextWrapped = true
	button.Font = Enum.Font.Gotham -- Clean, legible font
	button.AutoButtonColor = false
	button.Parent = container
	
	-- Corner rounding for choice box
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8) -- Gentle rounding
	corner.Parent = button
	
	-- Padding for text
	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 6)
	padding.PaddingBottom = UDim.new(0, 6)
	padding.Parent = button
	
	-- BOTW-style hover effects (subtle glow and color change)
	button.MouseEnter:Connect(function()
		-- Play choice hover sound
		if _G.AudioSystem then
			_G.AudioSystem:PlayChoiceHoverSound()
		end
		
		button.BackgroundColor3 = Color3.fromRGB(80, 120, 200) -- Subtle blue highlight
		button.BackgroundTransparency = 0.1 -- More opaque when highlighted
		button.TextColor3 = Color3.fromRGB(255, 255, 255)
	end)
	
	button.MouseLeave:Connect(function()
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		button.BackgroundTransparency = 0.3
		button.TextColor3 = Color3.fromRGB(255, 255, 255)
	end)
	
	-- Click handling
	button.MouseButton1Click:Connect(function()
		print("Choice box clicked:", choiceIndex, choiceText)
		-- Don't clear dialogue system immediately - let server response handle the flow
		-- Send choice to server and wait for response
		RemoteEvents.ProcessChoice:FireServer(npcId, choiceIndex)
	end)
	
	return button
end

-- Typewriter effect for dialogue text
function DialogueUI:TypewriterEffect(textLabel, fullText, speed, onComplete)
	speed = speed or 0.03 -- Characters per second
	local currentText = ""
	local textLength = string.len(fullText)
	local currentIndex = 0
	local completed = false -- Track if animation is complete to prevent duplicate onComplete calls
	local lastDisplayIndex = 0 -- Track last displayed character for sound triggering
	
	-- Clear existing text
	textLabel.Text = ""
	
	-- Create typewriter animation
	local typewriterConnection
	typewriterConnection = RunService.Heartbeat:Connect(function(deltaTime)
		currentIndex = currentIndex + (speed / deltaTime)
		
		if currentIndex >= textLength then
			-- Animation complete
			textLabel.Text = fullText
			typewriterConnection:Disconnect()
			if onComplete and not completed then
				completed = true
				onComplete()
			end
		else
			-- Update displayed text
			local displayIndex = math.floor(currentIndex)
			if displayIndex > lastDisplayIndex then
				-- Character added - play typewriter sound
				if _G.AudioSystem then
					_G.AudioSystem:PlayTextAdvanceSound()
				end
				lastDisplayIndex = displayIndex
			end
			currentText = string.sub(fullText, 1, displayIndex)
			textLabel.Text = currentText
		end
	end)
	
	-- Allow instant reveal on click
	local clickConnection
	clickConnection = textLabel.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			-- Play instant reveal sound
			if _G.AudioSystem then
				_G.AudioSystem:PlayInstantRevealSound()
			end
			
			-- Instantly show full text
			textLabel.Text = fullText
			currentIndex = textLength
			typewriterConnection:Disconnect()
			clickConnection:Disconnect()
			if onComplete and not completed then
				completed = true
				onComplete()
			end
		end
	end)
	
	return typewriterConnection, clickConnection
end

-- Create modal button for cursor management (similar to ArmorMenu)
function DialogueUI:CreateModalButton()
	if self.modalButton then
		return -- Already exists
	end
	
	local screenGui = player.PlayerGui:FindFirstChild("BOTWDialogueSystem")
	if not screenGui then
		return -- No dialogue UI active
	end
	
	-- Create invisible modal button to keep cursor unlocked
	local modalButton = Instance.new("TextButton")
	modalButton.Name = "DialogueModalButton"
	modalButton.Size = UDim2.new(1, 0, 1, 0)
	modalButton.Position = UDim2.new(0, 0, 0, 0)
	modalButton.BackgroundTransparency = 1
	modalButton.Text = ""
	modalButton.Modal = true -- This keeps the cursor unlocked
	modalButton.ZIndex = -1 -- Behind other UI elements
	modalButton.Parent = screenGui
	
	self.modalButton = modalButton
end

-- Note: RemoveModalButton function removed - modal button is now automatically destroyed with the dialogue system

-- Display dialogue using BOTW-style dialogue system
function DialogueUI:DisplayDialogue(npcId, dialogueData)
	local npcModel = workspace:FindFirstChild(npcId)
	if not npcModel then
		print("NPC model not found:", npcId)
		return
	end
	
	-- Only set cursor behavior if no dialogue is currently active
	if not self.activeDialogue then
		-- Unlock cursor and hide crosshair when dialogue starts
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
		
		-- Hide crosshair when dialogue is open
		if _G.CameraSystem then
			_G.CameraSystem:HideCrosshair()
		end
	end

	-- Parse dialogue text to separate main text from choices
	local fullText = dialogueData.text
	local lines = {}
	for line in fullText:gmatch("[^\r\n]+") do
		table.insert(lines, line)
	end

	-- Find where choices start (lines that begin with "•")
	local mainTextLines = {}
	local choiceLines = {}
	local foundChoices = false

	for i, line in ipairs(lines) do
		if line:match("^•") then -- Line starts with bullet point
			foundChoices = true
			table.insert(choiceLines, line)
		else
			if not foundChoices then
				table.insert(mainTextLines, line)
			end
		end
	end

	-- Clear any existing dialogue system
	self:ClearDialogueSystem()

	-- Create new BOTW-style dialogue system
	local screenGui, dialogueBox, textArea, speakerLabel, choiceContainer = self:CreateDialogueSystem()

	-- Set speaker name (format NPC ID to readable name)
	local speakerName = npcId:gsub("_", " "):gsub("(%a)([%w_']*)", function(first, rest) 
		return first:upper()..rest 
	end)
	speakerLabel.Text = speakerName

	-- Get main dialogue text
	local mainText = table.concat(mainTextLines, "\n")
	
	-- Start typewriter effect for main text
	self:TypewriterEffect(textArea, mainText, 0.05, function()
		-- After typewriter completes, show choices if any exist
		if #choiceLines > 0 then
			for i, choiceLine in ipairs(choiceLines) do
				-- Remove bullet point and trim whitespace manually
				local choiceText = choiceLine:gsub("^•%s*", ""):gsub("^%[(.-)%]%s*%-", "%1:")
				choiceText = choiceText:gsub("^%s*(.-)%s*$", "%1") -- Manual trim
				self:CreateChoiceBox(choiceText, i, choiceContainer, npcId)
			end
		end
	end)

	-- Create modal button to keep cursor unlocked
	self:CreateModalButton()

	-- Store active dialogue reference
	self.activeDialogue = {
		npcId = npcId,
		dialogueSystem = screenGui,
		startTime = tick()
	}

	print("Displayed BOTW dialogue for", npcId)
end

-- Note: ShowOverheadText function removed - server now uses DisplayDialogue for all responses

-- End dialogue (cleanup)
function DialogueUI:EndDialogue()
	-- Clear dialogue system
	self:ClearDialogueSystem()

	-- Clear active dialogue
	self.activeDialogue = nil
	
	-- Restore cursor lock and show crosshair when dialogue ends
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseIconEnabled = false
	
	-- Show crosshair when dialogue is closed
	if _G.CameraSystem then
		_G.CameraSystem:ShowCrosshair()
	end

	print("Dialogue ended")
end

-- Handle proximity prompt triggered
function DialogueUI:OnProximityPromptTriggered(promptObject)
	print("OnProximityPromptTriggered called with:", promptObject)
	print("Prompt parent:", promptObject.Parent)
	print("Prompt parent name:", promptObject.Parent and promptObject.Parent.Name or "nil")
	
	-- The proximity prompt is attached to HumanoidRootPart, so we need to go up one more level
	local humanoidRootPart = promptObject.Parent
	local npcModel = humanoidRootPart and humanoidRootPart.Parent
	
	print("HumanoidRootPart:", humanoidRootPart)
	print("NPC Model:", npcModel)
	print("NPC Model Name:", npcModel and npcModel.Name or "nil")
	print("NPC Model Parent:", npcModel and npcModel.Parent or "nil")
	
	if npcModel and npcModel.Parent == workspace then
		local npcId = npcModel.Name
		print("Proximity prompt triggered for NPC:", npcId)
		print("Firing StartDialogue to server for:", npcId)
		RemoteEvents.StartDialogue:FireServer(npcId)
	else
		print("NPC model not found or not in workspace")
		print("npcModel:", npcModel)
		print("npcModel.Parent:", npcModel and npcModel.Parent or "nil")
	end
end

-- Initialize the dialogue UI system
function DialogueUI:Initialize()
	-- Connect to RemoteEvents
	RemoteEvents.DisplayDialogue.OnClientEvent:Connect(function(npcId, dialogueData)
		self:DisplayDialogue(npcId, dialogueData)
	end)
	
	RemoteEvents.EndDialogue.OnClientEvent:Connect(function()
		self:EndDialogue()
	end)
	
	-- Connect to all proximity prompts (for NPCs) - future ones
	workspace.DescendantAdded:Connect(function(descendant)
		if descendant:IsA("ProximityPrompt") then
			print("Found new ProximityPrompt:", descendant.Name, "in", descendant.Parent.Name)
			descendant.Triggered:Connect(function(player)
				if player == Players.LocalPlayer then
					print("ProximityPrompt triggered by", player.Name)
					self:OnProximityPromptTriggered(descendant)
				end
			end)
		end
	end)
	
	-- Function to connect existing proximity prompts with retry logic
	local function connectExistingPrompts()
		local promptsFound = 0
		for _, descendant in pairs(workspace:GetDescendants()) do
			if descendant:IsA("ProximityPrompt") then
				promptsFound = promptsFound + 1
				print("Connecting to existing ProximityPrompt:", descendant.Name, "in", descendant.Parent.Name)
				descendant.Triggered:Connect(function(player)
					if player == Players.LocalPlayer then
						print("Existing ProximityPrompt triggered by", player.Name)
						self:OnProximityPromptTriggered(descendant)
					end
				end)
			end
		end
		print("Connected to", promptsFound, "existing proximity prompts")
		return promptsFound
	end
	
	-- Connect to existing proximity prompts immediately
	local initialPrompts = connectExistingPrompts()
	
	-- If no prompts found initially, retry after a delay (NPCs might still be loading)
	if initialPrompts == 0 then
		print("No proximity prompts found initially, retrying in 2 seconds...")
		wait(2)
		connectExistingPrompts()
	end
	
	print("DialogueUI initialized")
end

return DialogueUI ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="109">
          <Properties>
            <string name="Name">ItemDetailUI</string>
            <string name="Source"><![CDATA[-- ItemDetailUI.luau
-- Handles item detail popup interface

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local TraderData = require(ReplicatedStorage.Shared.TraderData)
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local ItemDetailUI = {}

-- Track UI state
ItemDetailUI.isDetailOpen = false
ItemDetailUI.currentDetailGui = nil
ItemDetailUI.currentItemId = nil
ItemDetailUI.modalButton = nil -- Track modal button for cursor management

-- Create the item detail popup window
function ItemDetailUI:CreateDetailWindow(itemId, itemData)
	local config = TraderData.UIConfig
	local requirements = TraderData:GetRequirements(itemId)
	
	-- Safety check: Remove any existing ItemDetailGui
	local existingGui = player.PlayerGui:FindFirstChild("ItemDetailGui")
	if existingGui then
		print("WARNING: Found existing ItemDetailGui, removing it")
		existingGui:Destroy()
	end
	
	-- Create ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ItemDetailGui"
	screenGui.ResetOnSpawn = false
	screenGui.IgnoreGuiInset = true
	screenGui.Parent = player.PlayerGui
	
	-- Background overlay (semi-transparent)
	local overlay = Instance.new("Frame")
	overlay.Name = "Overlay"
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.BackgroundColor3 = Color3.new(0, 0, 0)
	overlay.BackgroundTransparency = 0.5
	overlay.BorderSizePixel = 0
	overlay.Parent = screenGui
	
	-- Main detail frame
	local detailFrame = Instance.new("Frame")
	detailFrame.Name = "DetailFrame"
	detailFrame.Size = config.detailWindowSize
	detailFrame.Position = config.detailWindowPosition
	detailFrame.BackgroundColor3 = config.backgroundColor
	detailFrame.BorderSizePixel = 0
	detailFrame.Parent = screenGui
	
	-- Corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = detailFrame
	
	-- Header section
	local headerFrame = Instance.new("Frame")
	headerFrame.Name = "HeaderFrame"
	headerFrame.Size = UDim2.new(1, 0, 0, 80)
	headerFrame.Position = UDim2.new(0, 0, 0, 0)
	headerFrame.BackgroundColor3 = config.frameColor
	headerFrame.BorderSizePixel = 0
	headerFrame.Parent = detailFrame
	
	-- Header corner
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 12)
	headerCorner.Parent = headerFrame
	
	-- Item icon (large)
	local iconFrame = Instance.new("Frame")
	iconFrame.Name = "IconFrame"
	iconFrame.Size = UDim2.new(0, 60, 0, 60)
	iconFrame.Position = UDim2.new(0, 10, 0, 10)
	iconFrame.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
	iconFrame.BorderSizePixel = 0
	iconFrame.Parent = headerFrame
	
	-- Icon corner
	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(0, 8)
	iconCorner.Parent = iconFrame
	
	-- Icon label (placeholder)
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Name = "IconLabel"
	iconLabel.Size = UDim2.new(1, 0, 1, 0)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = "?"
	iconLabel.TextColor3 = config.textColor
	iconLabel.TextSize = 36
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.Parent = iconFrame
	
	-- Item name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, -90, 0, 30)
	nameLabel.Position = UDim2.new(0, 80, 0, 10)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = itemData.name
	nameLabel.TextColor3 = config.textColor
	nameLabel.TextSize = 20
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.Parent = headerFrame
	
	-- Item rarity
	local rarityLabel = Instance.new("TextLabel")
	rarityLabel.Name = "RarityLabel"
	rarityLabel.Size = UDim2.new(1, -90, 0, 20)
	rarityLabel.Position = UDim2.new(0, 80, 0, 40)
	rarityLabel.BackgroundTransparency = 1
	rarityLabel.Text = itemData.rarity:upper()
	rarityLabel.TextColor3 = config.rarityColors[itemData.rarity] or config.rarityColors.common
	rarityLabel.TextSize = 14
	rarityLabel.TextXAlignment = Enum.TextXAlignment.Left
	rarityLabel.Font = Enum.Font.GothamBold
	rarityLabel.Parent = headerFrame
	
	-- Description section
	local descriptionFrame = Instance.new("Frame")
	descriptionFrame.Name = "DescriptionFrame"
	descriptionFrame.Size = UDim2.new(1, -20, 0, 60)
	descriptionFrame.Position = UDim2.new(0, 10, 0, 90)
	descriptionFrame.BackgroundTransparency = 1
	descriptionFrame.Parent = detailFrame
	
	-- Description label
	local descriptionLabel = Instance.new("TextLabel")
	descriptionLabel.Name = "DescriptionLabel"
	descriptionLabel.Size = UDim2.new(1, 0, 1, 0)
	descriptionLabel.BackgroundTransparency = 1
	descriptionLabel.Text = itemData.description
	descriptionLabel.TextColor3 = config.textColor
	descriptionLabel.TextSize = 14
	descriptionLabel.TextWrapped = true
	descriptionLabel.TextXAlignment = Enum.TextXAlignment.Left
	descriptionLabel.TextYAlignment = Enum.TextYAlignment.Top
	descriptionLabel.Font = Enum.Font.Gotham
	descriptionLabel.Parent = descriptionFrame
	
	-- Requirements section
	local requirementsFrame = Instance.new("Frame")
	requirementsFrame.Name = "RequirementsFrame"
	requirementsFrame.Size = UDim2.new(1, -20, 0, 120)
	requirementsFrame.Position = UDim2.new(0, 10, 0, 160)
	requirementsFrame.BackgroundColor3 = config.frameColor
	requirementsFrame.BorderSizePixel = 0
	requirementsFrame.Parent = detailFrame
	
	-- Requirements corner
	local reqCorner = Instance.new("UICorner")
	reqCorner.CornerRadius = UDim.new(0, 8)
	reqCorner.Parent = requirementsFrame
	
	-- Requirements title
	local reqTitle = Instance.new("TextLabel")
	reqTitle.Name = "RequirementsTitle"
	reqTitle.Size = UDim2.new(1, -20, 0, 25)
	reqTitle.Position = UDim2.new(0, 10, 0, 5)
	reqTitle.BackgroundTransparency = 1
	reqTitle.Text = "Required Items:"
	reqTitle.TextColor3 = config.textColor
	reqTitle.TextSize = 16
	reqTitle.TextXAlignment = Enum.TextXAlignment.Left
	reqTitle.Font = Enum.Font.GothamBold
	reqTitle.Parent = requirementsFrame
	
	-- Requirements list
	local reqScrollFrame = Instance.new("ScrollingFrame")
	reqScrollFrame.Name = "RequirementsScrollFrame"
	reqScrollFrame.Size = UDim2.new(1, -20, 1, -35)
	reqScrollFrame.Position = UDim2.new(0, 10, 0, 30)
	reqScrollFrame.BackgroundTransparency = 1
	reqScrollFrame.BorderSizePixel = 0
	reqScrollFrame.ScrollBarThickness = 4
	reqScrollFrame.ScrollBarImageColor3 = config.accentColor
	reqScrollFrame.Parent = requirementsFrame
	
	-- Requirements layout
	local reqLayout = Instance.new("UIListLayout")
	reqLayout.FillDirection = Enum.FillDirection.Vertical
	reqLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	reqLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	reqLayout.Padding = UDim.new(0, 5)
	reqLayout.SortOrder = Enum.SortOrder.LayoutOrder
	reqLayout.Parent = reqScrollFrame
	
	-- Create requirement items
	for i, requirement in ipairs(requirements) do
		local reqItem = Instance.new("Frame")
		reqItem.Name = "RequirementItem" .. i
		reqItem.Size = UDim2.new(1, -10, 0, 25)
		reqItem.BackgroundTransparency = 1
		reqItem.LayoutOrder = i
		reqItem.Parent = reqScrollFrame
		
		-- Bullet point
		local bullet = Instance.new("TextLabel")
		bullet.Name = "Bullet"
		bullet.Size = UDim2.new(0, 20, 1, 0)
		bullet.Position = UDim2.new(0, 0, 0, 0)
		bullet.BackgroundTransparency = 1
		bullet.Text = "•"
		bullet.TextColor3 = config.accentColor
		bullet.TextSize = 16
		bullet.Font = Enum.Font.GothamBold
		bullet.Parent = reqItem
		
		-- Requirement text
		local reqText = Instance.new("TextLabel")
		reqText.Name = "RequirementText"
		reqText.Size = UDim2.new(1, -25, 1, 0)
		reqText.Position = UDim2.new(0, 25, 0, 0)
		reqText.BackgroundTransparency = 1
		reqText.Text = requirement.quantity .. "x " .. requirement.item
		reqText.TextColor3 = config.textColor
		reqText.TextSize = 14
		reqText.TextXAlignment = Enum.TextXAlignment.Left
		reqText.Font = Enum.Font.Gotham
		reqText.Parent = reqItem
	end
	
	-- Update scroll frame canvas size
	reqLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		reqScrollFrame.CanvasSize = UDim2.new(0, 0, 0, reqLayout.AbsoluteContentSize.Y + 10)
	end)
	reqScrollFrame.CanvasSize = UDim2.new(0, 0, 0, reqLayout.AbsoluteContentSize.Y + 10)
	
	-- Trade button
	local tradeButton = Instance.new("TextButton")
	tradeButton.Name = "TradeButton"
	tradeButton.Size = UDim2.new(1, -20, 0, 40)
	tradeButton.Position = UDim2.new(0, 10, 1, -50)
	tradeButton.BackgroundColor3 = config.accentColor
	tradeButton.BorderSizePixel = 0
	tradeButton.Text = "Trade"
	tradeButton.TextColor3 = Color3.new(1, 1, 1)
	tradeButton.TextSize = 18
	tradeButton.Font = Enum.Font.GothamBold
	tradeButton.Parent = detailFrame
	
	-- Trade button corner
	local tradeCorner = Instance.new("UICorner")
	tradeCorner.CornerRadius = UDim.new(0, 8)
	tradeCorner.Parent = tradeButton
	
	-- Trade button hover effects
	tradeButton.MouseEnter:Connect(function()
		tradeButton.BackgroundColor3 = Color3.new(0.3, 0.5, 0.9)
	end)
	
	tradeButton.MouseLeave:Connect(function()
		tradeButton.BackgroundColor3 = config.accentColor
	end)
	
	-- Trade button click - process the trade
	tradeButton.MouseButton1Click:Connect(function()
		print("Trade button clicked for:", itemData.name)
		self:ProcessTrade(itemId, itemData)
	end)
	
	-- Click overlay to close
	overlay.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self:CloseItemDetail()
		end
	end)
	
	-- Animate in
	detailFrame.Size = UDim2.new(0, 0, 0, 0)
	detailFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	
	local tween = TweenService:Create(detailFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = config.detailWindowSize,
		Position = config.detailWindowPosition
	})
	tween:Play()
	
	return screenGui
end

-- Create modal button for cursor management (exactly like DialogueUI)
function ItemDetailUI:CreateModalButton()
	if self.modalButton then
		return -- Already exists
	end
	
	if not self.currentDetailGui then
		return -- No detail UI active
	end
	
	-- Create invisible modal button to keep cursor unlocked
	local modalButton = Instance.new("TextButton")
	modalButton.Name = "ItemDetailModalButton"
	modalButton.Size = UDim2.new(1, 0, 1, 0)
	modalButton.Position = UDim2.new(0, 0, 0, 0)
	modalButton.BackgroundTransparency = 1
	modalButton.Text = ""
	modalButton.Modal = true -- This keeps the cursor unlocked
	modalButton.ZIndex = -1 -- Behind other UI elements
	modalButton.Parent = self.currentDetailGui
	
	self.modalButton = modalButton
end

-- Remove modal button
function ItemDetailUI:RemoveModalButton()
	if self.modalButton then
		self.modalButton:Destroy()
		self.modalButton = nil
	end
end

-- Show item detail popup
function ItemDetailUI:ShowItemDetail(itemId, itemData)
	print("ShowItemDetail called for:", itemData.name, "Current detail open:", self.isDetailOpen)
	
	-- Force cleanup any existing detail windows first
	self:ForceCleanup()
	
	-- Now create the new detail window
	self.isDetailOpen = true
	self.currentItemId = itemId

	-- Create detail window
	local detailGui = self:CreateDetailWindow(itemId, itemData)
	self.currentDetailGui = detailGui
	
	-- Create modal button to keep cursor unlocked (BEFORE setting cursor properties)
	self:CreateModalButton()
	
	-- Unlock cursor and hide crosshair when detail opens (AFTER modal button is created)
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	UserInputService.MouseIconEnabled = true
	
	-- Hide crosshair when detail is open
	if _G.CameraSystem then
		_G.CameraSystem:HideCrosshair()
	end

	print("Showing item detail for:", itemData.name)
end

-- Close item detail popup
function ItemDetailUI:CloseItemDetail()
	print("CloseItemDetail called, isDetailOpen:", self.isDetailOpen)
	
	if not self.isDetailOpen then
		print("Detail not open, ignoring close request")
		return
	end
	
	self.isDetailOpen = false
	self.currentItemId = nil
	
	-- Remove modal button
	self:RemoveModalButton()

	-- Remove detail GUI immediately without animation to prevent glitches
	if self.currentDetailGui then
		print("Destroying detail GUI immediately")
		self.currentDetailGui:Destroy()
		self.currentDetailGui = nil
	else
		print("No detail GUI to destroy")
	end
	

	
	-- Only restore cursor lock if TraderUI is not open
	if not (_G.TraderUI and _G.TraderUI.isShopOpen) then
		-- Restore cursor lock and show crosshair when detail closes
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false
		
		-- Show crosshair when detail is closed
		if _G.CameraSystem then
			_G.CameraSystem:ShowCrosshair()
		end
		
		print("[ITEM DETAIL DEBUG] Restored cursor lock (TraderUI not open)")
	else
		print("[ITEM DETAIL DEBUG] TraderUI is open, not locking cursor")
	end

	print("Closed item detail")
end

-- Force cleanup of all detail windows (for emergency cleanup)
function ItemDetailUI:ForceCleanup()
	print("ItemDetailUI: Force cleanup called")
	
	-- Reset state
	self.isDetailOpen = false
	self.currentItemId = nil
	self.currentDetailGui = nil
	
	-- Remove modal button
	self:RemoveModalButton()

	-- Remove any ItemDetailGui from PlayerGui
	local allDetailGuis = player.PlayerGui:GetChildren()
	for _, gui in pairs(allDetailGuis) do
		if gui.Name == "ItemDetailGui" then
			print("Force removing ItemDetailGui:", gui)
			gui:Destroy()
		end
	end
	

	
	-- Only restore cursor lock if TraderUI is not open
	if not (_G.TraderUI and _G.TraderUI.isShopOpen) then
		-- Restore cursor lock and show crosshair when cleanup happens
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false
		
		-- Show crosshair when cleanup happens
		if _G.CameraSystem then
			_G.CameraSystem:ShowCrosshair()
		end
		
		print("[ITEM DETAIL DEBUG] ForceCleanup: Restored cursor lock (TraderUI not open)")
	else
		print("[ITEM DETAIL DEBUG] ForceCleanup: TraderUI is open, not locking cursor")
	end

	print("ItemDetailUI: Force cleanup completed")
end

-- Process a trade request
function ItemDetailUI:ProcessTrade(itemId, itemData)
	print("Processing trade for item:", itemId, itemData.name)
	
	-- Disable the trade button temporarily to prevent double-clicking
	if self.currentDetailGui then
		local detailFrame = self.currentDetailGui:FindFirstChild("ItemDetailFrame")
		if detailFrame then
			local tradeButton = detailFrame:FindFirstChild("TradeButton")
			if tradeButton then
				tradeButton.Enabled = false
				tradeButton.Text = "Trading..."
			end
		end
	end
	
	-- Send trade request to server
	local success, message = RemoteEvents.TradeRequest:InvokeServer(itemId)
	
	-- Handle the response
	if success then
		print("Trade successful:", message)
		
		-- Close the item detail UI immediately
		self:CloseItemDetail()
		
		-- Close the trader UI as well
		if _G.TraderUI then
			_G.TraderUI:CloseShop()
		end
	else
		print("Trade failed:", message)
		
		-- Show error message
		self:ShowTradeMessage("Trade Failed", message or "Unknown error occurred", Color3.fromRGB(255, 0, 0))
		
		-- Re-enable the trade button
		if self.currentDetailGui then
			local detailFrame = self.currentDetailGui:FindFirstChild("ItemDetailFrame")
			if detailFrame then
				local tradeButton = detailFrame:FindFirstChild("TradeButton")
				if tradeButton then
					tradeButton.Enabled = true
					tradeButton.Text = "Trade"
				end
			end
		end
	end
end

-- Show a trade message (success or error)
function ItemDetailUI:ShowTradeMessage(title, message, color)
	if not self.currentDetailGui then return end
	
	local detailFrame = self.currentDetailGui:FindFirstChild("ItemDetailFrame")
	if not detailFrame then return end
	
	-- Create message frame
	local messageFrame = Instance.new("Frame")
	messageFrame.Name = "TradeMessageFrame"
	messageFrame.Size = UDim2.new(1, -20, 0, 80)
	messageFrame.Position = UDim2.new(0, 10, 0, 10)
	messageFrame.BackgroundColor3 = color
	messageFrame.BorderSizePixel = 0
	messageFrame.ZIndex = 10
	messageFrame.Parent = detailFrame
	
	-- Message frame corner
	local messageCorner = Instance.new("UICorner")
	messageCorner.CornerRadius = UDim.new(0, 8)
	messageCorner.Parent = messageFrame
	
	-- Title label
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, -10, 0, 25)
	titleLabel.Position = UDim2.new(0, 5, 0, 5)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = title
	titleLabel.TextColor3 = Color3.new(1, 1, 1)
	titleLabel.TextSize = 18
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = messageFrame
	
	-- Message label
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "MessageLabel"
	messageLabel.Size = UDim2.new(1, -10, 0, 45)
	messageLabel.Position = UDim2.new(0, 5, 0, 30)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Text = message
	messageLabel.TextColor3 = Color3.new(1, 1, 1)
	messageLabel.TextSize = 14
	messageLabel.Font = Enum.Font.Gotham
	messageLabel.TextXAlignment = Enum.TextXAlignment.Left
	messageLabel.TextYAlignment = Enum.TextYAlignment.Top
	messageLabel.TextWrapped = true
	messageLabel.Parent = messageFrame
	
	-- Auto-remove message after 3 seconds
	game:GetService("Debris"):AddItem(messageFrame, 3)
end

-- Initialize the item detail UI
function ItemDetailUI:Initialize()
	print("ItemDetailUI initialized")
end

return ItemDetailUI ]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="110">
          <Properties>
            <string name="Name">ProjectileRenderer</string>
            <string name="Source"><![CDATA[-- ProjectileRenderer.luau
-- Client-side projectile rendering system
-- Handles visual creation, movement, and effects of projectiles

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

local ProjectileRenderer = {}

-- Store active projectiles on client
local activeProjectiles = {} -- {[projectileId] = {part, trail, bodyVelocity, startTime, lifetime}}

-- Remote events for server communication
local ProjectileEvents = ReplicatedStorage:WaitForChild("ProjectileEvents")

-- Create visual projectile on client
function ProjectileRenderer.createProjectile(projectileId, startPosition, targetPosition, config)
    -- Calculate distance and direction
    local direction = (targetPosition - startPosition).Unit
    local distance = (targetPosition - startPosition).Magnitude
    
    -- Create full-length beam that spans from weapon to target
    local projectile = Instance.new("Part")
    projectile.Name = "ClientProjectile_" .. projectileId
    projectile.Size = Vector3.new(0.1, 0.1, distance) -- Beam spans full distance
    projectile.Color = Color3.fromRGB(255, 255, 255) -- Pure white
    projectile.Material = Enum.Material.Plastic
    projectile.Shape = Enum.PartType.Block
    projectile.CanCollide = false
    projectile.Anchored = true -- Anchored so it doesn't move
    
    -- Position beam to span from start to target
    local midpoint = (startPosition + targetPosition) / 2
    local lookAt = CFrame.lookAt(startPosition, targetPosition)
    projectile.CFrame = lookAt * CFrame.new(0, 0, 0) -- Center the beam
    projectile.Position = midpoint
    
    projectile.Parent = workspace
    
    -- Store projectile data
    activeProjectiles[projectileId] = {
        part = projectile,
        startTime = tick(),
        lifetime = 0.1, -- Very short lifetime for instant hit effect
        targetPosition = targetPosition,
        config = config
    }
    
    print("⚡ Client created instant beam", projectileId, "from", startPosition, "to", targetPosition)
    
    -- Auto cleanup after very short time (instant hit effect)
    Debris:AddItem(projectile, 0.1)
end

-- Destroy projectile on client
function ProjectileRenderer.destroyProjectile(projectileId)
    local projectileData = activeProjectiles[projectileId]
    if projectileData then
        if projectileData.part then
            projectileData.part:Destroy()
        end
        activeProjectiles[projectileId] = nil
        print("🗑️ Client destroyed projectile", projectileId)
    end
end

-- Hit effects removed for now - can be added later

-- Initialize client projectile system
function ProjectileRenderer.Initialize()
    print("🎨 ProjectileRenderer: Initializing client-side projectile system")
    
    -- Connect to server projectile events
    if ProjectileEvents then
        -- Handle projectile spawn events from server
        local spawnEvent = ProjectileEvents:WaitForChild("SpawnProjectile")
        spawnEvent.OnClientEvent:Connect(function(projectileId, startPosition, targetPosition, config)
            ProjectileRenderer.createProjectile(projectileId, startPosition, targetPosition, config)
        end)
        
        -- Handle projectile destroy events from server
        local destroyEvent = ProjectileEvents:WaitForChild("DestroyProjectile")
        destroyEvent.OnClientEvent:Connect(function(projectileId)
            ProjectileRenderer.destroyProjectile(projectileId)
        end)
        
        -- Handle projectile hit events from server (hit effects removed for now)
        local hitEvent = ProjectileEvents:WaitForChild("ProjectileHit")
        hitEvent.OnClientEvent:Connect(function(projectileId, hitPosition)
            ProjectileRenderer.destroyProjectile(projectileId)
        end)
        
        print("✅ ProjectileRenderer: Connected to server projectile events")
    else
        warn("⚠️ ProjectileRenderer: ProjectileEvents not found in ReplicatedStorage")
    end
end

-- Clean up all client projectiles
function ProjectileRenderer.cleanup()
    for projectileId, projectileData in pairs(activeProjectiles) do
        if projectileData.part then
            projectileData.part:Destroy()
        end
    end
    activeProjectiles = {}
    print("🧹 ProjectileRenderer: Cleaned up all client projectiles")
end

return ProjectileRenderer ]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="111">
          <Properties>
            <string name="Name">Systems</string>
          </Properties>
          <Item class="ModuleScript" referent="112">
            <Properties>
              <string name="Name">AltarUISystem</string>
              <string name="Source"><![CDATA[-- AltarUISystem.luau
-- Client-side visual feedback for altar system

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

local AltarConfig = require(ReplicatedStorage.Shared.AltarConfig)

local AltarUISystem = {}

-- Track altar highlights
local altarHighlights = {} -- [altar] = highlight

function AltarUISystem:Initialize()
    print("Initializing AltarUISystem...")
    
    -- Find existing altars
    self:SetupExistingAltars()
    
    -- Listen for new altars
    CollectionService:GetInstanceAddedSignal("Altar"):Connect(function(altar)
        self:SetupAltarUI(altar)
    end)
    
    -- Listen for altar removal
    CollectionService:GetInstanceRemovedSignal("Altar"):Connect(function(altar)
        self:CleanupAltarUI(altar)
    end)
    
    print("AltarUISystem initialized")
end

-- Setup UI for existing altars
function AltarUISystem:SetupExistingAltars()
    local taggedAltars = CollectionService:GetTagged("Altar")
    for _, altar in ipairs(taggedAltars) do
        self:SetupAltarUI(altar)
    end
    print("Setup UI for", #taggedAltars, "existing altars")
end

-- Setup UI for a single altar
function AltarUISystem:SetupAltarUI(altar)
    -- Create highlight for altar
    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Red for altar
    highlight.FillTransparency = 0.3
    highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
    highlight.OutlineTransparency = 0
    highlight.Parent = altar
    highlight.Name = "AltarHighlight"
    
    altarHighlights[altar] = highlight
    
    print("Setup UI for altar:", altar:GetFullName())
end

-- Cleanup UI for a single altar
function AltarUISystem:CleanupAltarUI(altar)
    if altarHighlights[altar] then
        altarHighlights[altar]:Destroy()
        altarHighlights[altar] = nil
        print("Cleaned up UI for altar:", altar:GetFullName())
    end
end

-- Update altar highlight based on sacrifice count
function AltarUISystem:UpdateAltarHighlight(altar, sacrificeCount)
    local highlight = altarHighlights[altar]
    if not highlight then
        return
    end
    
    local required = AltarConfig.SETTINGS.requiredSacrifices
    local progress = sacrificeCount / required
    
    -- Change color based on progress
    if progress >= 1 then
        -- Ready to trigger
        highlight.FillColor = Color3.fromRGB(0, 255, 0) -- Green
        highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
    elseif progress >= 0.5 then
        -- Getting close
        highlight.FillColor = Color3.fromRGB(255, 255, 0) -- Yellow
        highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
    else
        -- Just started
        highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Red
        highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
    end
end

-- Show sacrifice progress notification
function AltarUISystem:ShowSacrificeProgress(altar, sacrificeCount)
    local required = AltarConfig.SETTINGS.requiredSacrifices
    local remaining = required - sacrificeCount
    
    if remaining > 0 then
        print("Altar needs", remaining, "more sacrifices")
    else
        print("Altar is ready! Triggering reward...")
    end
end

return AltarUISystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="113">
            <Properties>
              <string name="Name">ArmorSystem</string>
              <string name="Source"><![CDATA[-- Armor system for handling armor equipment independently
local ArmorSystem = {}

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RemoteEvents = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("RemoteEvents"))
local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)
local Categories = require(ReplicatedStorage.Shared.ItemCategory)
local SystemManager = require(ReplicatedStorage.Shared.SystemManager)

local player = Players.LocalPlayer

-- Armor state (separate from hotbar inventory)
local playerArmor = {
    helmet = nil,
    chestplate = nil,
    boots = nil
}

-- UI reference
local ArmorMenu = nil

function ArmorSystem:Initialize()
    -- Register with SystemManager instead of global
    SystemManager.RegisterSystem("ArmorSystem", self)
    
    -- Set up global reference for other systems (like Hotbar)
    _G.ArmorSystem = self
    
    -- Initialize armor menu UI
    ArmorMenu = require(script.Parent.Parent.UI.ArmorMenu)
    ArmorMenu:Initialize()
    
    -- Handle G key input (independent from other systems)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.G then
            print("[ARMOR DEBUG] G key pressed - toggling armor menu")
            self:HandleGKeyPress()
        end
    end)
    
    print("[ARMOR DEBUG] Armor system initialized")
end

function ArmorSystem:HandleGKeyPress()
    -- Toggle armor menu visibility
    print("[ARMOR DEBUG] Handling G key press - toggling menu")
    ArmorMenu:Toggle()
end

function ArmorSystem:HandleSlotClick(armorSlot)
    -- Handle clicking on armor slots
    local currentArmor = playerArmor[armorSlot]
    
    if currentArmor then
        -- Unequip armor (move back to hotbar)
        self:UnequipArmor(armorSlot)
    else
        -- Try to equip armor from hotbar
        self:TryEquipArmorFromHotbar(armorSlot)
    end
end

function ArmorSystem:TryEquipArmorFromHotbar(armorSlot)
    -- Check if player has compatible armor equipped in hotbar
    local equippedItem = self:GetEquippedHotbarItem()
    
    if not equippedItem then
        -- Nothing equipped – cannot proceed
        return
    end
    
    -- Check if equipped item is armor of the right type
    local itemDef = ItemDefinitions:GetItem(equippedItem.itemId)
    
    if not itemDef then
        warn("No item definition found for ID:", equippedItem.itemId)
        return
    end
    
    if itemDef.category ~= Categories.Armor then
        return
    end
    
    if itemDef.armorSlot ~= armorSlot then
        return
    end
    
    -- Request armor equip from server
    self:RequestArmorEquip(armorSlot, equippedItem)
end

function ArmorSystem:UnequipArmor(armorSlot)
    -- Request armor unequip from server
    self:RequestArmorUnequip(armorSlot)
end

function ArmorSystem:RequestArmorEquip(armorSlot, hotbarItem)
    local success, result, message = pcall(function()
        return RemoteEvents.ArmorRequest:InvokeServer("equip_armor", armorSlot, hotbarItem)
    end)
    
    if not success then
        warn("ArmorRequest call failed:", result)
        return
    end
    
    local serverSuccess, serverMessage = result, message
    
    if serverSuccess then
        -- Update local armor state
        playerArmor[armorSlot] = {
            itemName = hotbarItem.itemName,
            itemId = hotbarItem.itemId,
            object = hotbarItem.object
        }
        
        -- Update armor menu display
        ArmorMenu:UpdateDisplay(playerArmor)
        
        -- Notify inventory system to update hotbar (remove equipped item)
        self:NotifyInventorySystemArmorEquipped()
    else
        warn("Failed to equip armor:", serverMessage)
    end
end

function ArmorSystem:RequestArmorUnequip(armorSlot)
    local success, result, message = pcall(function()
        return RemoteEvents.ArmorRequest:InvokeServer("unequip_armor", armorSlot)
    end)
    
    if not success then
        warn("ArmorRequest call failed:", result)
        return
    end
    
    local serverSuccess, serverMessage = result, message
    
    if serverSuccess then
        -- Clear local armor state
        local unequippedArmor = playerArmor[armorSlot]
        playerArmor[armorSlot] = nil
        
        -- Update armor menu display
        ArmorMenu:UpdateDisplay(playerArmor)
        
        -- Notify inventory system to update hotbar (add back to hotbar)
        self:NotifyInventorySystemArmorUnequipped(unequippedArmor)
    else
        warn("Failed to unequip armor:", serverMessage)
    end
end

function ArmorSystem:GetEquippedHotbarItem()
    -- Get currently equipped item from inventory system through SystemManager
    return SystemManager.CallSystem("InventorySystem", "GetEquippedItem")
end

function ArmorSystem:NotifyInventorySystemArmorEquipped()
    -- Notify inventory system that armor was equipped (remove from hotbar)
    SystemManager.CallSystem("InventorySystem", "HandleArmorEquipped")
end

function ArmorSystem:NotifyInventorySystemArmorUnequipped(armorItem)
    -- Notify inventory system that armor was unequipped (add back to hotbar)
    SystemManager.CallSystem("InventorySystem", "HandleArmorUnequipped", armorItem)
end

function ArmorSystem:TryEquipFromUse(heldItem)
    if not heldItem or not heldItem.itemId then
        return
    end

    local itemDef = ItemDefinitions:GetItem(heldItem.itemId)
    if not itemDef or itemDef.category ~= Categories.Armor or not itemDef.armorSlot then
        return
    end

    local armorSlot = itemDef.armorSlot

    -- Check if the target armor slot is already occupied
    if playerArmor[armorSlot] then
        -- Optionally, open the armor menu here to allow manual swapping
        self:Show()
        return
    end
    -- The server request requires the full hotbarItem object, which includes the .object reference
    self:RequestArmorEquip(armorSlot, heldItem)

    print("[ARMOR DEBUG] --- TryEquipFromUse END ---")
end

-- Public methods for other systems
function ArmorSystem:GetEquippedArmor()
    return playerArmor
end

function ArmorSystem:IsArmorMenuVisible()
    return ArmorMenu and ArmorMenu:IsVisible()
end

-- Equip directly from a specific inventory slot (used by drag-drop)
function ArmorSystem:EquipFromInventorySlot(slotIndex, armorSlot)
    -- Equip the slot first (client + server)
    local success = SystemManager.CallSystem("InventorySystem", "EquipSlotDirect", slotIndex)
    if not success then 
        print("[ARMOR DEBUG] Failed to equip slot through InventorySystem")
        return 
    end

    -- Now attempt normal equip flow
    self:TryEquipArmorFromHotbar(armorSlot)
end

-- Armor has no click functionality - all interaction is through equip system
function ArmorSystem:Use(itemDef, player, target)
    print("ArmorSystem: Armor has no click functionality")
    print("  - Use G key to open armor menu and equip", itemDef.name)
    print("  - Armor provides health when equipped")
end

return ArmorSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="114">
            <Properties>
              <string name="Name">AudioSystem</string>
              <string name="Source"><![CDATA[-- Client-side audio system for handling game sound effects
local AudioSystem = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local ContentProvider = game:GetService("ContentProvider")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local SystemManager = require(ReplicatedStorage.Shared.SystemManager)
local FrameBudgetManager = require(ReplicatedStorage.Shared.FrameBudgetManager)

local player = Players.LocalPlayer

-- Audio configuration
local AUDIO_CONFIG = {
    -- Critical attack sound effects
    CRITICAL_SOUNDS = {
        timing_success = "rbxassetid://90888363530177", -- Success timing sound
        critical_hit = "rbxassetid://133571969001119", -- Critical hit impact sound
        swing_miss = "rbxassetid://91413392394116", -- Tool swing with no hit
        hit_success = { -- Random selection for successful hits
            "rbxassetid://108593693294419",
            "rbxassetid://74950311934371"
        }
    },
    
    -- Dialogue sound effects
    DIALOGUE_SOUNDS = {
        typewriter = "rbxassetid://93715887251564", -- Character-by-character typing sound
        instant_reveal = "rbxassetid://93715887251564", -- Instant text reveal sound (same as typewriter)
        choice_hover = "rbxassetid://133240016897321", -- Choice button hover sound
    },
    
    -- Volume settings
    CRITICAL_VOLUME = 0.7, -- Volume for critical effects
    DIALOGUE_VOLUME = 0.4, -- Volume for dialogue sounds (subtle)
    MASTER_VOLUME = 1.0,
    
    -- Sound properties
    SOUND_PITCH_VARIATION = 0.1, -- Random pitch variation for variety
    TYPEWRITER_THROTTLE = 0.05, -- Minimum time between typewriter sounds (seconds)
}

-- Sound cache to avoid creating new sounds every time
local soundCache = {}

-- PERFORMANCE OPTIMIZATION: Sound pooling for frequently used sounds
local soundPools = {}
local poolSizes = {
    hit_success = 5,    -- Multiple hit sounds can play simultaneously
    swing_miss = 3,     -- Multiple swings possible
    typewriter = 2,     -- Dialogue sounds
    critical_hit = 3,   -- Critical effects
    timing_success = 2  -- Timing feedback
}

-- Preloading status tracking
local preloadingStatus = {
    isPreloading = false,
    totalSounds = 0,
    loadedSounds = 0,
    failedSounds = 0
}

function AudioSystem:Initialize()
    -- Register with SystemManager
    SystemManager.RegisterSystem("AudioSystem", self)
    
    -- Set up global reference for other systems
    _G.AudioSystem = self
    
    -- Damage audio is now handled client-side in ToolSystem
    
    -- Pre-load common sounds
    self:PreloadSounds()
    
    print("AudioSystem initialized")
end

function AudioSystem:PreloadSounds()
    preloadingStatus.isPreloading = true
    preloadingStatus.totalSounds = 0
    preloadingStatus.loadedSounds = 0
    preloadingStatus.failedSounds = 0
    
    -- PERFORMANCE OPTIMIZATION: Async sound preloading with frame budgeting
    task.spawn(function()
        local loadOperations = {}
        
        -- Prepare all sound loading operations
        for soundName, soundId in pairs(AUDIO_CONFIG.CRITICAL_SOUNDS) do
            if type(soundId) == "table" then
                -- Handle arrays of sound IDs (like hit_success)
                for i, id in ipairs(soundId) do
                    local finalSoundName = soundName .. "_" .. i
                    table.insert(loadOperations, function()
                        self:AsyncLoadSound(finalSoundName, id)
                    end)
                    preloadingStatus.totalSounds += 1
                end
            else
                table.insert(loadOperations, function()
                    self:AsyncLoadSound(soundName, soundId)
                end)
                preloadingStatus.totalSounds += 1
            end
        end
        
        -- Pre-load dialogue sounds
        for soundName, soundId in pairs(AUDIO_CONFIG.DIALOGUE_SOUNDS) do
            table.insert(loadOperations, function()
                self:AsyncLoadSound(soundName, soundId)
            end)
            preloadingStatus.totalSounds += 1
        end
        
        -- Execute loading with frame budgeting (max 2 sounds per frame)
        FrameBudgetManager.executeWithLimit(loadOperations, 2)
        
        -- Initialize sound pools after loading
        self:InitializeSoundPools()
        
        preloadingStatus.isPreloading = false
        print("AudioSystem: Async preloading complete -", 
              preloadingStatus.loadedSounds, "loaded,", 
              preloadingStatus.failedSounds, "failed")
    end)
end

function AudioSystem:AsyncLoadSound(soundName, soundId)
    -- Create the sound first
    local sound = Instance.new("Sound")
    sound.Name = soundName
    sound.SoundId = soundId
    sound.Volume = AUDIO_CONFIG.CRITICAL_VOLUME * AUDIO_CONFIG.MASTER_VOLUME
    sound.Parent = SoundService
    
    -- Cache immediately for access
    soundCache[soundName] = sound
    
    -- Async load the content
    task.spawn(function()
        local success, errorMsg = pcall(function()
            ContentProvider:PreloadAsync({sound})
        end)
        
        if success then
            preloadingStatus.loadedSounds += 1
            print("AudioSystem: Preloaded", soundName)
        else
            preloadingStatus.failedSounds += 1
            warn("AudioSystem: Failed to preload", soundName, ":", errorMsg)
        end
    end)
end

function AudioSystem:InitializeSoundPools()
    -- PERFORMANCE OPTIMIZATION: Create sound pools for frequently used sounds
    for soundName, poolSize in pairs(poolSizes) do
        if not soundPools[soundName] then
            soundPools[soundName] = {
                available = {},
                inUse = {},
                maxSize = poolSize
            }
            
            -- Create initial pool
            for i = 1, poolSize do
                local pooledSound = self:CreatePooledSound(soundName)
                if pooledSound then
                    table.insert(soundPools[soundName].available, pooledSound)
                end
            end
            
            print("AudioSystem: Created sound pool for", soundName, "with", #soundPools[soundName].available, "sounds")
        end
    end
end

function AudioSystem:CreatePooledSound(baseSoundName)
    -- Find the base sound in cache
    local baseSound = soundCache[baseSoundName]
    if not baseSound then
        -- Try to find a numbered variant (like hit_success_1)
        for cachedName, cachedSound in pairs(soundCache) do
            if cachedName:match("^" .. baseSoundName .. "_") then
                baseSound = cachedSound
                break
            end
        end
    end
    
    if not baseSound then
        warn("AudioSystem: Could not find base sound for pool:", baseSoundName)
        return nil
    end
    
    -- Create pooled sound with same properties
    local pooledSound = Instance.new("Sound")
    pooledSound.Name = baseSoundName .. "_pooled_" .. tostring(math.random(1000, 9999))
    pooledSound.SoundId = baseSound.SoundId
    pooledSound.Volume = baseSound.Volume
    pooledSound.PlaybackSpeed = baseSound.PlaybackSpeed
    pooledSound.Parent = SoundService
    
    -- Return to pool when finished
    pooledSound.Ended:Connect(function()
        self:ReturnSoundToPool(baseSoundName, pooledSound)
    end)
    
    return pooledSound
end

function AudioSystem:GetOrCreateSound(soundName, soundId)
    -- Check if sound is already cached
    if soundCache[soundName] then
        return soundCache[soundName]
    end
    
    -- Create new sound
    local sound = Instance.new("Sound")
    sound.Name = soundName
    sound.SoundId = soundId
    sound.Volume = AUDIO_CONFIG.CRITICAL_VOLUME * AUDIO_CONFIG.MASTER_VOLUME
    sound.Parent = SoundService -- Use SoundService for global sounds
    
    -- Cache the sound
    soundCache[soundName] = sound
    
    return sound
end

-- PERFORMANCE OPTIMIZATION: Sound pooling methods
function AudioSystem:GetPooledSound(soundName)
    local pool = soundPools[soundName]
    if not pool then
        -- No pool for this sound, use regular method
        return self:GetOrCreateSound(soundName, nil)
    end
    
    -- Get available sound from pool
    if #pool.available > 0 then
        local sound = table.remove(pool.available)
        table.insert(pool.inUse, sound)
        return sound
    end
    
    -- Pool exhausted, create new sound if under limit
    if #pool.inUse < pool.maxSize * 2 then -- Allow 2x expansion under load
        local newSound = self:CreatePooledSound(soundName)
        if newSound then
            table.insert(pool.inUse, newSound)
            return newSound
        end
    end
    
    -- Fallback to cached sound (may cause audio overlap)
    warn("AudioSystem: Pool exhausted for", soundName, "- using cached sound")
    return soundCache[soundName]
end

function AudioSystem:ReturnSoundToPool(soundName, sound)
    local pool = soundPools[soundName]
    if not pool then return end
    
    -- Remove from in-use
    for i, inUseSound in ipairs(pool.inUse) do
        if inUseSound == sound then
            table.remove(pool.inUse, i)
            break
        end
    end
    
    -- Add back to available if pool not full
    if #pool.available < pool.maxSize then
        table.insert(pool.available, sound)
    else
        -- Pool full, destroy excess sound
        sound:Destroy()
    end
end

-- Enhanced play method with pooling
function AudioSystem:PlayPooledSound(soundName, volume, pitch)
    volume = volume or AUDIO_CONFIG.CRITICAL_VOLUME
    pitch = pitch or 1.0
    
    local sound = self:GetPooledSound(soundName)
    if not sound then
        warn("AudioSystem: Could not get sound:", soundName)
        return
    end
    
    sound.Volume = volume * AUDIO_CONFIG.MASTER_VOLUME
    sound.PlaybackSpeed = pitch
    sound:Play()
    
    return sound
end



function AudioSystem:PlaySound(soundName, soundId, volume, pitch)
    volume = volume or AUDIO_CONFIG.CRITICAL_VOLUME
    pitch = pitch or 1.0
    
    local sound = self:GetOrCreateSound(soundName, soundId)
    sound.Volume = volume * AUDIO_CONFIG.MASTER_VOLUME
    sound.PlaybackSpeed = pitch
    sound:Play()
end

function AudioSystem:PlayCriticalTimingSuccess()
    -- PERFORMANCE OPTIMIZATION: Use pooled sound
    self:PlayPooledSound("timing_success", AUDIO_CONFIG.CRITICAL_VOLUME, 1.0)
    print("AudioSystem: Played critical timing success sound")
end

function AudioSystem:PlayCriticalHitSound()
    -- PERFORMANCE OPTIMIZATION: Use pooled sound
    self:PlayPooledSound("critical_hit", AUDIO_CONFIG.CRITICAL_VOLUME, 1.0)
    print("AudioSystem: Played critical hit impact sound")
end

function AudioSystem:PlaySwingMissSound()
    -- PERFORMANCE OPTIMIZATION: Use pooled sound
    self:PlayPooledSound("swing_miss", AUDIO_CONFIG.CRITICAL_VOLUME, 1.0)
    print("AudioSystem: Played swing miss sound")
end

function AudioSystem:PlayHitSuccessSound()
    -- PERFORMANCE OPTIMIZATION: Use pooled sound with random selection
    self:PlayPooledSound("hit_success", AUDIO_CONFIG.CRITICAL_VOLUME, 1.0)
    print("AudioSystem: Played hit success sound")
end

-- Dialogue Sound Methods

-- Track last typewriter sound time for throttling
local lastTypewriterSoundTime = 0

function AudioSystem:PlayTextAdvanceSound()
    -- Throttle typewriter sounds to prevent audio spam
    local currentTime = tick()
    if currentTime - lastTypewriterSoundTime < AUDIO_CONFIG.TYPEWRITER_THROTTLE then
        return -- Skip this sound to prevent spam
    end
    
    -- PERFORMANCE OPTIMIZATION: Use pooled sound
    self:PlayPooledSound("typewriter", AUDIO_CONFIG.DIALOGUE_VOLUME, 1.0)
    
    lastTypewriterSoundTime = currentTime
    print("AudioSystem: Played text advance sound")
end

function AudioSystem:PlayInstantRevealSound()
    -- PERFORMANCE OPTIMIZATION: Use pooled sound
    self:PlayPooledSound("instant_reveal", AUDIO_CONFIG.DIALOGUE_VOLUME, 1.0)
    print("AudioSystem: Played instant reveal sound")
end

function AudioSystem:PlayChoiceHoverSound()
    -- PERFORMANCE OPTIMIZATION: Use pooled sound
    self:PlayPooledSound("choice_hover", AUDIO_CONFIG.DIALOGUE_VOLUME, 1.0)
    print("AudioSystem: Played choice hover sound")
end

function AudioSystem:SetMasterVolume(volume)
    AUDIO_CONFIG.MASTER_VOLUME = math.clamp(volume, 0, 1)
    
    -- Update all cached sounds
    for _, sound in pairs(soundCache) do
        sound.Volume = sound.Volume * AUDIO_CONFIG.MASTER_VOLUME
    end
    
    print("AudioSystem: Set master volume to", AUDIO_CONFIG.MASTER_VOLUME)
end

function AudioSystem:SetCriticalVolume(volume)
    AUDIO_CONFIG.CRITICAL_VOLUME = math.clamp(volume, 0, 1)
    print("AudioSystem: Set critical volume to", AUDIO_CONFIG.CRITICAL_VOLUME)
end

-- Public methods for other systems
function AudioSystem:GetCachedSoundCount()
    local count = 0
    for _ in pairs(soundCache) do
        count = count + 1
    end
    return count
end

function AudioSystem:GetAudioConfig()
    return AUDIO_CONFIG
end

function AudioSystem:ClearSoundCache()
    for _, sound in pairs(soundCache) do
        sound:Destroy()
    end
    soundCache = {}
    
    -- Also clear sound pools
    for _, pool in pairs(soundPools) do
        for _, sound in pairs(pool.available) do
            sound:Destroy()
        end
        for _, sound in pairs(pool.inUse) do
            sound:Destroy()
        end
    end
    soundPools = {}
    
    print("AudioSystem: Cleared sound cache and pools")
end

-- PERFORMANCE OPTIMIZATION: Status and diagnostics methods
function AudioSystem:GetPreloadingStatus()
    return {
        isPreloading = preloadingStatus.isPreloading,
        progress = preloadingStatus.totalSounds > 0 and 
                  (preloadingStatus.loadedSounds / preloadingStatus.totalSounds) or 0,
        loaded = preloadingStatus.loadedSounds,
        failed = preloadingStatus.failedSounds,
        total = preloadingStatus.totalSounds
    }
end

function AudioSystem:GetPoolStatus()
    local status = {}
    for soundName, pool in pairs(soundPools) do
        status[soundName] = {
            available = #pool.available,
            inUse = #pool.inUse,
            maxSize = pool.maxSize
        }
    end
    return status
end

function AudioSystem:PrintDiagnostics()
    local preloadStatus = self:GetPreloadingStatus()
    local poolStatus = self:GetPoolStatus()
    
    print("=== AudioSystem Diagnostics ===")
    print("Preloading:", preloadStatus.isPreloading and "IN PROGRESS" or "COMPLETE")
    print("Sounds loaded:", preloadStatus.loaded .. "/" .. preloadStatus.total)
    if preloadStatus.failed > 0 then
        print("Failed sounds:", preloadStatus.failed)
    end
    
    print("\nSound Pools:")
    for soundName, status in pairs(poolStatus) do
        print("  " .. soundName .. ": " .. status.available .. " available, " .. 
              status.inUse .. " in use (max: " .. status.maxSize .. ")")
    end
    
    print("Total cached sounds:", self:GetCachedSoundCount())
    print("===============================")
end

return AudioSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="115">
            <Properties>
              <string name="Name">CameraSystem</string>
              <string name="Source"><![CDATA[-- New Camera System with third-person/first-person toggle
local CameraSystem = {}

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local DEFAULT_FOV = 70
local ZOOMED_FOV = 58 -- Less zoom in
local ZOOM_IN_TIME = 0.5 -- Slower, smoother zoom in
local ZOOM_OUT_TIME = 0.1
local fovTween = nil

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local camera = workspace.CurrentCamera

-- Camera system variables
local mobileDragging = false
local dragging = false
local distance = 0.5 -- Start in first-person mode

-- Rotation variables
local xRot = 0
local yRot = 0

-- Walk bobbing variables
local func1 = 0
local func2 = 0
local func3 = 0
local func4 = 0
local val = 0
local val2 = 0

-- Camera sway variables
local Turn = 0

-- Crosshair UI elements
local crosshairGui = nil

-- Connections
local renderStepConnection = nil
local inputBeganConnection = nil
local inputEndedConnection = nil
local cameraChangedConnection = nil

-- Cache for performance optimization
local lastFrameTime = tick()
local TARGET_FPS = 60
local FRAME_TIME_BUDGET = 1/TARGET_FPS

-- Helper function for linear interpolation
local function lerp(a, b, c)
    return a + (b - a) * c
end

-- Initialize camera rotation from current camera
local function initializeCameraRotation()
    local camX, camY, camZ = camera.CFrame:ToEulerAnglesXYZ()
    xRot = camY
    yRot = camX
end

-- Handle body transparency - hide head and accessories in first-person
local function updateBodyTransparency()
    if not camera.CameraSubject or not camera.CameraSubject.Parent then return end
    
    for _, v in pairs(camera.CameraSubject.Parent:GetDescendants()) do
        if (v:IsA("BasePart") or v:IsA("Decal") or v:IsA("Texture")) and not v:FindFirstAncestorOfClass("Tool") then
            -- In first-person mode, hide head and accessories but keep body visible
            if distance <= 0.5 then
                -- Make head and accessories completely invisible in first-person
                if v.Name == "Head" or v.Parent.Name == "Head" or v:FindFirstAncestor("Head") then
                    v.LocalTransparencyModifier = 1
                elseif v:FindFirstAncestorOfClass("Accessory") then
                    -- Hide all accessory parts (hats, hair, etc.)
                    v.LocalTransparencyModifier = 1
                else
                    v.LocalTransparencyModifier = 0 -- Keep body visible
                end
            else
                -- Make everything visible in third-person
                v.LocalTransparencyModifier = 0
            end
        end
    end
end

-- Calculate movement-based bobbing effects
local function calculateMovementBobbing(deltaTime)
    local character = player.Character
    if not character then return CFrame.new() end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        return CFrame.new()
    end
    
    local rootPart = humanoid.RootPart
    if not rootPart then
        return CFrame.new()
    end
    
    local rootMagnitude = Vector3.new(rootPart.Velocity.X, 0, rootPart.Velocity.Z).Magnitude
    
    -- Smooth deltaTime scaling for consistent bobbing with performance protection
    local scaledDeltaTime = math.min(deltaTime * 30, 2) -- Cap scaled deltaTime to prevent spikes
    
    -- Handle delta time spikes and movement-based bobbing calculations
    if scaledDeltaTime > 1.5 then
        func1 = lerp(func1, 0, 0.1)
        func2 = lerp(func2, 0, 0.1)
    else
        -- Only calculate bobbing if player is moving
        if rootMagnitude > 0.5 then
            -- Pre-calculate time-based values with bobbing intensity
            local timeValue = tick() * 14
            local cosTimeValue = math.cos(timeValue)
            local cosTimeValueSlow = math.cos(timeValue * 0.9)
            
            func1 = lerp(func1, cosTimeValue * 0.25 * scaledDeltaTime, 0.08 * scaledDeltaTime)
            func2 = lerp(func2, cosTimeValueSlow * 0.15 * scaledDeltaTime, 0.08 * scaledDeltaTime)
        else
            -- Gradually reduce bobbing when stationary
            local lerpFactor = 0.1 * deltaTime
            func1 = lerp(func1, 0, lerpFactor)
            func2 = lerp(func2, 0, lerpFactor)
        end
    end
    
    -- Reset some sway-related variables
    val2 = lerp(val2, 0, 0.2 * deltaTime)
    func4 = lerp(func4, 0, 0.2 * deltaTime)
    val = lerp(val, 0, 0.15 * deltaTime)
    
    -- Create bobbing CFrame
    local isMoving = rootMagnitude > 0.5
    if isMoving then
        -- Apply vertical bobbing and slight horizontal sway
        return CFrame.fromEulerAnglesXYZ(math.rad(func1 * 1.5), math.rad(func2 * 1.0), math.rad(func1 * 0.5))
    else
        -- No movement bobbing when stationary
        return CFrame.new()
    end
end

-- Calculate mouse-based sway effects
local function calculateMouseSway(mouseDelta, deltaTime)
    -- Update sway variables using mouse input
    local clampedMouseX = math.clamp(mouseDelta.X, -5.0, 5.0)
    local clampedMouseXSway = math.clamp(mouseDelta.X, -3.5, 3.5)
    
    Turn = lerp(Turn, clampedMouseX, math.min(6 * deltaTime, 0.5))
    func3 = lerp(func3, clampedMouseXSway, 0.25 * deltaTime)
    
    -- Return sway CFrame
    return CFrame.Angles(0, 0, math.rad(Turn * 0.8))
end

-- Main camera update function
local function updateCamera(deltaTime)
    local currentFrameTime = tick()
    
    -- Performance protection: skip frame if budget exceeded
    if currentFrameTime - lastFrameTime < FRAME_TIME_BUDGET * 0.8 then
        return
    end
    
    -- Get character and humanoid for body rotation
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    -- Set mouse behavior based on distance
    if distance <= 0.5 then
        UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
    else
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    end
    
    local mouseDelta = UserInputService:GetMouseDelta()
    local mouseSensitivity = UserGameSettings.MouseSensitivity
    
    if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
        dragging = false
    end
    
    -- Update rotation if dragging or in first-person mode
    if dragging or mobileDragging or UserInputService.MouseBehavior ~= Enum.MouseBehavior.Default then
        if dragging then
            UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
        end
        xRot += math.rad((mouseDelta.X * 0.25) * mouseSensitivity * -1)
        yRot += math.rad((mouseDelta.Y * 0.25) * mouseSensitivity * -1)
    end
    
    -- Clamp vertical rotation
    yRot = math.clamp(yRot, math.rad(-75), math.rad(75))
    
    -- Make body follow camera direction (rotate character to match camera horizontal rotation)
    if rootPart and humanoid and humanoid.Health > 0 then
        -- Create rotation CFrame from camera's horizontal rotation
        local bodyRotation = CFrame.fromEulerAnglesYXZ(0, xRot, 0)
        -- Apply rotation while keeping the character's position
        rootPart.CFrame = CFrame.new(rootPart.Position) * bodyRotation
    end
    
    -- Calculate effects for enhanced camera feel
    local movementBobbing = CFrame.new()
    local mouseSway = CFrame.new()
    
    -- Only apply bobbing and sway in first-person mode
    if distance <= 0.5 then
        movementBobbing = calculateMovementBobbing(deltaTime)
        mouseSway = calculateMouseSway(mouseDelta, deltaTime)
    end
    
    -- Combine effects
    local effectsTransform = movementBobbing * mouseSway
    
    -- Update camera position and rotation
    if camera.CameraSubject and camera.CameraSubject.Position then
        camera.Focus = CFrame.new(camera.CameraSubject.Position)
        camera.CFrame = camera.Focus
        
        -- Add camera offset to reduce body visibility in first-person
        local cameraOffset = Vector3.new(0, 0, 0)
        if distance <= 0.5 then
            -- Move camera slightly back and up to reduce body visibility
            cameraOffset = Vector3.new(0, 1, -0.2)
        end
        
        camera.CFrame = camera.CFrame * CFrame.fromEulerAnglesYXZ(yRot, xRot, 0) * CFrame.new(cameraOffset.X, cameraOffset.Y, distance + cameraOffset.Z)
        
        -- Apply effects in first-person mode
        if distance <= 0.5 then
            camera.CFrame = camera.CFrame * effectsTransform
        end
    end
    
    lastFrameTime = currentFrameTime
end

function CameraSystem:Initialize()
    -- Set up global reference for other systems
    _G.CameraSystem = self

    -- Wait for character and set camera subject
    local character = player.Character or player.CharacterAdded:Wait()
    if CollectionService:HasTag(player, "Dead") then
        -- Player is dead, enter spectate mode
        self:EnterSpectateMode()
    else
        local head = character:WaitForChild("Head")
        camera.CameraType = Enum.CameraType.Scriptable
        camera.CameraSubject = head
        initializeCameraRotation()
    end
    
    -- Create crosshair for first-person mode
    self:CreateCrosshair()
    
    -- Set up input connections
    inputBeganConnection = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            dragging = true
        end
        if input.UserInputType == Enum.UserInputType.Touch then
            mobileDragging = true
        end
    end)
    
    inputEndedConnection = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            dragging = false
        end
        if input.UserInputType == Enum.UserInputType.Touch then
            mobileDragging = false
        end
    end)
    
    -- Set up camera property changed connection for transparency
    cameraChangedConnection = camera:GetPropertyChangedSignal("CFrame"):Connect(updateBodyTransparency)
    
    -- Set up main camera update loop with deltaTime
    renderStepConnection = RunService:BindToRenderStep("Camera", Enum.RenderPriority.Camera.Value, updateCamera)
    
    -- Handle character respawning
    player.CharacterAdded:Connect(function(newCharacter)
        -- Wait a brief moment to ensure all attributes are properly set
        task.wait(0.1)
        
        if CollectionService:HasTag(player, "Dead") then
            self:EnterSpectateMode()
        else
            local newHead = newCharacter:WaitForChild("Head")
            camera.CameraSubject = newHead
            initializeCameraRotation()
            -- Force first-person mode on respawn with a slight delay to ensure everything is set up
            task.defer(function()
                -- Double-check that we're not in spectator mode
                if not CollectionService:HasTag(player, "Dead") then
                    self:SetDistance(0.5)
                    print("[CameraSystem] SetDistance(0.5) called after character respawn")
                end
            end)
        end
    end)
    
    print("Enhanced Camera System initialized - Distance:", distance, "(0.5 = first-person with bobbing/sway, higher = third-person)")
end

function CameraSystem:CreateCrosshair()
    -- Clean up existing crosshair first
    if crosshairGui then
        crosshairGui:Destroy()
    end
    
    -- Create crosshair GUI
    crosshairGui = Instance.new("ScreenGui")
    crosshairGui.Name = "CrosshairGui"
    crosshairGui.ResetOnSpawn = false
    crosshairGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    crosshairGui.IgnoreGuiInset = true
    crosshairGui.Parent = playerGui
    
    -- Create a simple dot crosshair
    local crosshairDot = Instance.new("Frame")
    crosshairDot.Name = "CrosshairDot"
    crosshairDot.Size = UDim2.new(0, 6, 0, 6)
    crosshairDot.Position = UDim2.new(0.5, -3, 0.5, -3)
    crosshairDot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    crosshairDot.BorderSizePixel = 0
    crosshairDot.Parent = crosshairGui
    
    -- Make it circular
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = crosshairDot
    
    -- Add black outline for visibility
    local outline = Instance.new("UIStroke")
    outline.Color = Color3.fromRGB(0, 0, 0)
    outline.Thickness = 1
    outline.Parent = crosshairDot
    
    -- Only show crosshair in first-person mode
    crosshairGui.Enabled = (distance <= 0.5)
    
    print("Crosshair created")
end

function CameraSystem:ShowCrosshair()
    if crosshairGui then
        crosshairGui.Enabled = true
    end
end

function CameraSystem:HideCrosshair()
    if crosshairGui then
        crosshairGui.Enabled = false
    end
end

-- Set camera distance (0.5 = first-person, higher = third-person)
function CameraSystem:SetDistance(newDistance)
    print("[CameraSystem] SetDistance:", newDistance, "->", math.max(0.5, newDistance))
    distance = math.max(0.5, newDistance)
    
    -- Update crosshair visibility based on distance
    if crosshairGui then
        crosshairGui.Enabled = (distance <= 0.5)
    end
    
    -- Update mouse cursor visibility
    UserInputService.MouseIconEnabled = (distance > 0.5)
end

-- Get current camera distance
function CameraSystem:GetDistance()
    return distance
end

-- Toggle between first-person and third-person
function CameraSystem:ToggleDistance()
    if distance <= 0.5 then
        self:SetDistance(5) -- Switch to third-person
    else
        self:SetDistance(0.5) -- Switch to first-person
    end
end

-- Enter spectate mode (called by SpectateUI when player dies)
function CameraSystem:EnterSpectateMode()
    print("[CameraSystem] EnterSpectateMode called")
    
    -- Set camera to third-person spectate mode
    self:SetDistance(8)
    
    -- Try to find the ragdoll model in workspace
    local ragdoll = workspace:FindFirstChild(player.Name)
    if ragdoll then
        local subject = ragdoll:FindFirstChild("Head") or ragdoll:FindFirstChild("Torso") or ragdoll:FindFirstChild("HumanoidRootPart")
        if subject then
            camera.CameraType = Enum.CameraType.Scriptable
            camera.CameraSubject = subject
            initializeCameraRotation()
            print("[CameraSystem] Set camera to ragdoll spectate mode")
        end
    else
        print("[CameraSystem] No ragdoll found for spectate mode")
    end
end

-- Set spectate target (called by SpectateUI when switching players)
function CameraSystem:SetSpectateTarget(targetPart)
    if targetPart then
        print("[CameraSystem] SetSpectateTarget:", targetPart.Name)
        camera.CameraType = Enum.CameraType.Scriptable
        camera.CameraSubject = targetPart
        initializeCameraRotation()
    else
        print("[CameraSystem] SetSpectateTarget: nil (no players alive)")
        camera.CameraSubject = nil
    end
end

-- Exit spectate mode (called by SpectateUI when player is revived)
function CameraSystem:ExitSpectateMode()
    print("[CameraSystem] ExitSpectateMode called")
    
    local character = player.Character
    if not character then
        print("[CameraSystem] No character found, waiting for character")
        character = player.CharacterAdded:Wait()
    end
    
    local head = character:FindFirstChild("Head")
    if head then
        print("[CameraSystem] Found head, restoring to first-person mode")
        camera.CameraType = Enum.CameraType.Scriptable
        camera.CameraSubject = head
        initializeCameraRotation()
        
        -- Force first-person mode
        self:SetDistance(0.5)
        print("[CameraSystem] ExitSpectateMode: Restored to first-person mode")
    else
        print("[CameraSystem] No head found in character")
    end
end

-- Legacy compatibility functions for screen shake (simplified)
function CameraSystem:StartShake(duration, intensity, speed)
    -- This new camera system doesn't have built-in shake
    -- You could implement it here if needed
    print("Screen shake not implemented in this camera system")
end

function CameraSystem:StopShake()
    print("Screen shake not implemented in this camera system")
end

function CameraSystem:ShakeScreen(intensity, duration)
    self:StartShake(duration, intensity, 15)
end

-- Legacy compatibility for walk bobbing (not implemented in new system)
function CameraSystem:StartWalkBobbing()
    print("Walk bobbing not implemented in this camera system")
end

function CameraSystem:StopWalkBobbing()
    print("Walk bobbing not implemented in this camera system")
end

function CameraSystem:StartCameraSway()
    print("Camera sway not implemented in this camera system")
end

function CameraSystem:StopCameraSway()
    print("Camera sway not implemented in this camera system")
end

function CameraSystem:ZoomIn()
    if fovTween then fovTween:Cancel() end
    fovTween = TweenService:Create(camera, TweenInfo.new(ZOOM_IN_TIME, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {FieldOfView = ZOOMED_FOV})
    fovTween:Play()
end

function CameraSystem:ZoomOut()
    if fovTween then fovTween:Cancel() end
    fovTween = TweenService:Create(camera, TweenInfo.new(ZOOM_OUT_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {FieldOfView = DEFAULT_FOV})
    fovTween:Play()
end

-- Cleanup function
function CameraSystem:Cleanup()
    -- Disconnect all connections
    if renderStepConnection then
        RunService:UnbindFromRenderStep("Camera")
        renderStepConnection = nil
    end
    
    if inputBeganConnection then
        inputBeganConnection:Disconnect()
        inputBeganConnection = nil
    end
    
    if inputEndedConnection then
        inputEndedConnection:Disconnect()
        inputEndedConnection = nil
    end
    
    if cameraChangedConnection then
        cameraChangedConnection:Disconnect()
        cameraChangedConnection = nil
    end
    
    -- Clean up crosshair GUI
    if crosshairGui then
        crosshairGui:Destroy()
        crosshairGui = nil
    end
    
    -- Reset camera and input settings
    camera.CameraType = Enum.CameraType.Custom
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    UserInputService.MouseIconEnabled = true
    
    -- Reset character transparency
    if camera.CameraSubject and camera.CameraSubject.Parent then
        for _, v in pairs(camera.CameraSubject.Parent:GetDescendants()) do
            if v:IsA("BasePart") or v:IsA("Decal") or v:IsA("Texture") then
                v.LocalTransparencyModifier = 0
            end
        end
    end
    
    print("Enhanced Camera System cleanup completed")
end

return CameraSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="116">
            <Properties>
              <string name="Name">CriticalAttackUI</string>
              <string name="Source"><![CDATA[-- Critical Attack UI system for managing the critical timing bar
local CriticalAttackUI = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Configuration
local BAR_CONFIG = {
    width = 18,  -- Scaled up from 12 to 18 (1.5x larger)
    height = 150, -- Scaled up from 100 to 150 (1.5x larger)
    offsetX = -60, -- Adjusted offset for bigger bar (1.5x larger)
    backgroundColor = Color3.fromRGB(0, 0, 0), -- Changed to black
    borderColor = Color3.fromRGB(120, 120, 120),
    transparency = 0.3 -- Increased opacity (more transparent) for better visibility
}

local CRITICAL_CONFIG = {
    minPosition = 0.1, -- 10% from top
    maxPosition = 0.7, -- 70% from top (leaves room for zone height)
    minSize = 0.15,    -- 15% of bar height
    maxSize = 0.25,    -- 25% of bar height
    color = Color3.fromRGB(255, 255, 255), -- White highlight
    transparency = 0.0 -- Make it fully opaque white
}

local INDICATOR_CONFIG = {
    height = 4,        -- Scaled up from 3 to 4 (proportional to larger bar)
    color = Color3.fromRGB(255, 200, 0), -- Gold/yellow
    speed = 2.0        -- Seconds for full up/down cycle
}

-- UI Elements
local criticalBarGui = nil
local criticalBarFrame = nil
local criticalZoneFrame = nil
local indicatorFrame = nil

-- State tracking
local isBarVisible = false
local indicatorAnimation = nil
local currentCriticalZone = nil

function CriticalAttackUI:Initialize()
    -- Set up global reference for other systems
    _G.CriticalAttackUI = self
    
    self:CreateCriticalBarUI()
    
    print("CriticalAttackUI initialized")
end

function CriticalAttackUI:CreateCriticalBarUI()
    -- Create critical bar GUI (initially hidden)
    criticalBarGui = Instance.new("ScreenGui")
    criticalBarGui.Name = "CriticalBarGui"
    criticalBarGui.ResetOnSpawn = false
    criticalBarGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    criticalBarGui.Enabled = false -- Start hidden
    criticalBarGui.Parent = playerGui
    
    -- Main bar frame (positioned relative to crosshair center)
    criticalBarFrame = Instance.new("Frame")
    criticalBarFrame.Name = "CriticalBar"
    criticalBarFrame.Size = UDim2.new(0, BAR_CONFIG.width, 0, BAR_CONFIG.height)
    criticalBarFrame.Position = UDim2.new(0.5, BAR_CONFIG.offsetX, 0.5, -BAR_CONFIG.height/2) -- Center vertically with crosshair
    criticalBarFrame.BackgroundColor3 = BAR_CONFIG.backgroundColor
    criticalBarFrame.BackgroundTransparency = BAR_CONFIG.transparency
    criticalBarFrame.BorderSizePixel = 0
    criticalBarFrame.Parent = criticalBarGui
    
    -- Add rounded corners to main bar
    local barCorner = Instance.new("UICorner")
    barCorner.CornerRadius = UDim.new(0, 9) -- Scaled up from 6 to 9 (1.5x larger)
    barCorner.Parent = criticalBarFrame
    
    -- Add border stroke
    local borderStroke = Instance.new("UIStroke")
    borderStroke.Color = BAR_CONFIG.borderColor
    borderStroke.Thickness = 1
    borderStroke.Parent = criticalBarFrame
    
    -- Critical zone frame (will be positioned dynamically)
    criticalZoneFrame = Instance.new("Frame")
    criticalZoneFrame.Name = "CriticalZone"
    criticalZoneFrame.BackgroundColor3 = CRITICAL_CONFIG.color
    criticalZoneFrame.BackgroundTransparency = CRITICAL_CONFIG.transparency -- Use config transparency (0.0 for opaque white)
    criticalZoneFrame.BorderSizePixel = 0
    criticalZoneFrame.Parent = criticalBarFrame
    
    -- Add rounded corners to critical zone
    local zoneCorner = Instance.new("UICorner")
    zoneCorner.CornerRadius = UDim.new(0, 6) -- Scaled up from 4 to 6 (1.5x larger)
    zoneCorner.Parent = criticalZoneFrame
    
    -- Moving indicator frame
    indicatorFrame = Instance.new("Frame")
    indicatorFrame.Name = "Indicator"
    indicatorFrame.Size = UDim2.new(1, 0, 0, INDICATOR_CONFIG.height)
    indicatorFrame.Position = UDim2.new(0, 0, 0, 0) -- Start at top
    indicatorFrame.BackgroundColor3 = INDICATOR_CONFIG.color
    indicatorFrame.BackgroundTransparency = 0
    indicatorFrame.BorderSizePixel = 0
    indicatorFrame.Parent = criticalBarFrame
    
    -- Add rounded corners to indicator
    local indicatorCorner = Instance.new("UICorner")
    indicatorCorner.CornerRadius = UDim.new(0, 3) -- Scaled up from 2 to 3 (1.5x larger)
    indicatorCorner.Parent = indicatorFrame
    
    print("Critical bar UI created")
end

function CriticalAttackUI:GenerateCriticalZone()
    -- Generate random critical zone position and size
    local position = math.random(CRITICAL_CONFIG.minPosition * 100, CRITICAL_CONFIG.maxPosition * 100) / 100
    local size = math.random(CRITICAL_CONFIG.minSize * 100, CRITICAL_CONFIG.maxSize * 100) / 100
    
    -- Ensure zone doesn't exceed bar bounds
    local endPosition = math.min(position + size, 0.9)
    size = endPosition - position
    
    currentCriticalZone = {
        startPercent = position,
        endPercent = endPosition,
        size = size
    }
    
    -- Update critical zone visual
    criticalZoneFrame.Size = UDim2.new(1, 0, size, 0)
    criticalZoneFrame.Position = UDim2.new(0, 0, position, 0)
    
    print("Generated critical zone:", position, "to", endPosition, "(size:", size .. ")")
    
    return currentCriticalZone
end

function CriticalAttackUI:ShowCriticalBar()
    if isBarVisible then return end
    
    -- Generate new random critical zone
    self:GenerateCriticalZone()
    
    -- Show the bar
    criticalBarGui.Enabled = true
    isBarVisible = true
    
    -- Start indicator animation
    self:StartIndicatorAnimation()
    
    print("Critical bar shown with new zone")
end

function CriticalAttackUI:HideCriticalBar()
    if not isBarVisible then return end
    
    -- Hide the bar
    criticalBarGui.Enabled = false
    isBarVisible = false
    
    -- Stop indicator animation
    self:StopIndicatorAnimation()
    
    print("Critical bar hidden")
end

function CriticalAttackUI:StartIndicatorAnimation()
    -- Stop any existing animation
    self:StopIndicatorAnimation()
    
    -- Create continuous up/down animation
    local startPosition = UDim2.new(0, 0, 0, 0) -- Top
    local endPosition = UDim2.new(0, 0, 1, -INDICATOR_CONFIG.height) -- Bottom
    
    -- Forward declare functions
    local animateDown, animateUp
    
    animateDown = function()
        local tween = TweenService:Create(
            indicatorFrame,
            TweenInfo.new(INDICATOR_CONFIG.speed / 2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),
            {Position = endPosition}
        )
        tween:Play()
        
        tween.Completed:Connect(function()
            if isBarVisible then
                animateUp()
            end
        end)
    end
    
    animateUp = function()
        local tween = TweenService:Create(
            indicatorFrame,
            TweenInfo.new(INDICATOR_CONFIG.speed / 2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),
            {Position = startPosition}
        )
        tween:Play()
        
        tween.Completed:Connect(function()
            if isBarVisible then
                animateDown()
            end
        end)
    end
    
    -- Start with downward animation
    indicatorFrame.Position = startPosition
    animateDown()
    
    print("Indicator animation started")
end

function CriticalAttackUI:StopIndicatorAnimation()
    -- Note: TweenService automatically handles cleanup when objects are destroyed
    -- We just need to ensure isBarVisible is false to stop the animation loop
    print("Indicator animation stopped")
end

function CriticalAttackUI:IsIndicatorInCriticalZone()
    if not isBarVisible or not currentCriticalZone then
        return false
    end
    
    -- Get current indicator position as percentage of bar height
    local indicatorY = indicatorFrame.Position.Y.Scale
    
    -- Check if indicator is within critical zone
    local inZone = indicatorY >= currentCriticalZone.startPercent and 
                   indicatorY <= currentCriticalZone.endPercent
    
    return inZone
end

function CriticalAttackUI:ShowCriticalSuccessEffect()
    -- Flash the critical zone green briefly to indicate success
    if not criticalZoneFrame then return end
    
    local originalColor = criticalZoneFrame.BackgroundColor3
    local originalTransparency = criticalZoneFrame.BackgroundTransparency
    
    -- Flash bright green
    criticalZoneFrame.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    criticalZoneFrame.BackgroundTransparency = 0
    
    -- Play critical timing success sound
    if _G.AudioSystem then
        _G.AudioSystem:PlayCriticalTimingSuccess()
    end
    
    -- Screen flash effect removed per user request
    
    -- Restore original color after brief flash
    local tween = TweenService:Create(
        criticalZoneFrame,
        TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {
            BackgroundColor3 = originalColor,
            BackgroundTransparency = originalTransparency
        }
    )
    tween:Play()
    
    print("Critical success effect displayed")
end

function CriticalAttackUI:CreateScreenFlash()
    -- Create a brief white border flash effect for critical hits
    local flashGui = Instance.new("ScreenGui")
    flashGui.Name = "CriticalFlash"
    flashGui.ResetOnSpawn = false
    flashGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    flashGui.IgnoreGuiInset = true -- Ensure full screen coverage
    flashGui.Parent = playerGui
    
    local borderThickness = 20 -- Thickness of the border flash
    
    -- Top border
    local topBorder = Instance.new("Frame")
    topBorder.Name = "TopBorder"
    topBorder.Size = UDim2.new(1, 0, 0, borderThickness)
    topBorder.Position = UDim2.new(0, 0, 0, 0)
    topBorder.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White flash
    topBorder.BackgroundTransparency = 0
    topBorder.BorderSizePixel = 0
    topBorder.Parent = flashGui
    
    -- Bottom border
    local bottomBorder = Instance.new("Frame")
    bottomBorder.Name = "BottomBorder"
    bottomBorder.Size = UDim2.new(1, 0, 0, borderThickness)
    bottomBorder.Position = UDim2.new(0, 0, 1, -borderThickness)
    bottomBorder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    bottomBorder.BackgroundTransparency = 0
    bottomBorder.BorderSizePixel = 0
    bottomBorder.Parent = flashGui
    
    -- Left border
    local leftBorder = Instance.new("Frame")
    leftBorder.Name = "LeftBorder"
    leftBorder.Size = UDim2.new(0, borderThickness, 1, 0)
    leftBorder.Position = UDim2.new(0, 0, 0, 0)
    leftBorder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    leftBorder.BackgroundTransparency = 0
    leftBorder.BorderSizePixel = 0
    leftBorder.Parent = flashGui
    
    -- Right border
    local rightBorder = Instance.new("Frame")
    rightBorder.Name = "RightBorder"
    rightBorder.Size = UDim2.new(0, borderThickness, 1, 0)
    rightBorder.Position = UDim2.new(1, -borderThickness, 0, 0)
    rightBorder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    rightBorder.BackgroundTransparency = 0
    rightBorder.BorderSizePixel = 0
    rightBorder.Parent = flashGui
    
    -- Create a table of all border frames for easy tweening
    local borderFrames = {topBorder, bottomBorder, leftBorder, rightBorder}
    
    -- Quick fade out and destroy
    for _, border in ipairs(borderFrames) do
        local tween = TweenService:Create(
            border,
            TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {BackgroundTransparency = 1}
        )
        tween:Play()
    end
    
    -- Destroy the GUI after animation completes
    task.wait(0.2)
    flashGui:Destroy()
end

function CriticalAttackUI:GetCriticalZoneInfo()
    return currentCriticalZone
end

function CriticalAttackUI:IsBarVisible()
    return isBarVisible
end

-- Cleanup function
function CriticalAttackUI:Cleanup()
    self:HideCriticalBar()
    
    if criticalBarGui then
        criticalBarGui:Destroy()
        criticalBarGui = nil
    end
    
    print("CriticalAttackUI cleanup completed")
end

return CriticalAttackUI ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="117">
            <Properties>
              <string name="Name">DragSystem</string>
              <string name="Source"><![CDATA[-- Advanced drag system with raycasting and constraints
local DragSystem = {}

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local Workspace = game:GetService("Workspace")

local RemoteEvents = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("RemoteEvents"))
local Constants = require(ReplicatedStorage.Shared.Constants)

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Drag state
local hoveredObject = nil
local grabbedObject = nil
local dragDistance = 5 -- Distance from camera to maintain object

-- Constraint objects
local dragTargetAttachment = nil
local dragObjectAttachment = nil
local alignPosition = nil
local alignOrientation = nil

-- Connections
local heartbeatConnection = nil

function DragSystem:Initialize()
    -- Create drag target attachment in terrain (acts as the "target" for dragging)
    dragTargetAttachment = Instance.new("Attachment")
    dragTargetAttachment.Name = "DragTarget"
    dragTargetAttachment.Parent = workspace.Terrain
    

    
    -- Handle mouse input
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self:HandleMouseDown()
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self:HandleMouseUp()
        end
    end)
    
    -- Start continuous update loop
    heartbeatConnection = RunService.Heartbeat:Connect(function()
        self:Update()
    end)
    
    print("Advanced drag system initialized")
end

function DragSystem:Update()
    -- Update drag target position
    self:UpdateDragTarget()
    
    -- Update hover detection
    self:UpdateHoverDetection()
    
    -- Check if dragged object is still within range
    self:CheckDragDistance()
end

function DragSystem:UpdateDragTarget()
    if not dragTargetAttachment then return end
    
    -- Position the drag target in front of the camera
    local cameraCFrame = camera.CFrame
    local forwardVector = cameraCFrame.LookVector
    local targetPosition = cameraCFrame.Position + forwardVector * dragDistance
    
    dragTargetAttachment.WorldCFrame = CFrame.new(targetPosition)
end

function DragSystem:UpdateHoverDetection()
    if grabbedObject then return end -- Don't hover while dragging
    
    -- Don't hover draggable objects when tool is equipped
    if self:HasEquippedTool() then
        -- Clear any existing hover state
        if hoveredObject then
            self:StopHover(hoveredObject)
            hoveredObject = nil
        end
        return
    end
    
    -- OPTIMIZATION: Skip hover detection when UIs are open to avoid interference
    if self:IsUIOpen() then
        -- Clear any existing hover state when UI opens
        if hoveredObject then
            self:StopHover(hoveredObject)
            hoveredObject = nil
        end
        return
    end
    
    local hitObject = self:RaycastFromMouse()
    
    if hitObject ~= hoveredObject then
        -- Stop hovering previous object
        if hoveredObject then
            self:StopHover(hoveredObject)
        end
        
        -- Start hovering new object
        if hitObject and self:IsObjectDraggable(hitObject) then
            self:StartHover(hitObject)
            hoveredObject = hitObject
        else
            hoveredObject = nil
        end
    elseif hoveredObject then
        -- Update tooltip position if still hovering the same object
        local ItemTooltip = require(script.Parent.Parent.UI.ItemTooltip)
        local mouse = player:GetMouse()
        ItemTooltip:UpdatePosition(Vector2.new(mouse.X, mouse.Y))
    end
end

function DragSystem:RaycastFromMouse()
    local mouse = player:GetMouse()
    
    -- Create raycast params
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {player.Character}
    
    -- Cast ray from camera through mouse position
    local ray = camera:ScreenPointToRay(mouse.X, mouse.Y)
    local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * Constants.DRAG.RAYCAST_DISTANCE, raycastParams)
    
    if raycastResult then
        -- OPTIMIZATION: Only return draggable objects to avoid processing non-interactive hits
        local hitObject = raycastResult.Instance
        if self:IsObjectDraggable(hitObject) then
            return hitObject
        end
        -- Don't return non-draggable objects - this eliminates most spam
        return nil
    end
    
    return nil
end

function DragSystem:IsObjectDraggable(object)
    -- Support both items and models
    local isModel = object.Parent and CollectionService:HasTag(object.Parent, "Draggable")
    local isDraggableItem = CollectionService:HasTag(object, Constants.TAGS.DRAGGABLE_ITEM)
    local isDraggableModel = object.Parent and CollectionService:HasTag(object.Parent, Constants.TAGS.DRAGGABLE_ITEM)
    
    return isDraggableItem or isModel or isDraggableModel
end

function DragSystem:StartHover(object)
    -- Highlight the correct object (parent if model, else self)
    local isModel = object.Parent and CollectionService:HasTag(object.Parent, "Draggable")
    local isDraggableModel = object.Parent and CollectionService:HasTag(object.Parent, Constants.TAGS.DRAGGABLE_ITEM)
    local highlightTarget = (isModel or isDraggableModel) and object.Parent or object
    local highlight = Instance.new("Highlight")
    highlight.FillColor = Constants.HOVER.HIGHLIGHT_COLOR
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = Constants.HOVER.HIGHLIGHT_COLOR
    highlight.OutlineTransparency = 0
    highlight.Parent = highlightTarget
    highlight.Name = "DragHoverHighlight"
    
    -- Show enhanced tooltip with name and description
    local ItemTooltip = require(script.Parent.Parent.UI.ItemTooltip)
    local mouse = player:GetMouse()
    local itemName = highlightTarget.Name
    local itemDescription = "No description available"
    local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)
    for itemId, definition in pairs(ItemDefinitions.items) do
        if definition.name == itemName then
            itemDescription = definition.description
            break
        end
    end
    ItemTooltip:ShowTooltip(itemName, itemDescription, Vector2.new(mouse.X, mouse.Y))
    print("Started hovering:", highlightTarget.Name)
end

function DragSystem:StopHover(object)
    -- Remove highlight effect from both object and its parent (if model)
    local highlight = object:FindFirstChild("DragHoverHighlight")
    if highlight then
        highlight:Destroy()
    end
    if object.Parent then
        local parentHighlight = object.Parent:FindFirstChild("DragHoverHighlight")
        if parentHighlight then
            parentHighlight:Destroy()
        end
    end
    -- Hide tooltip
    local ItemTooltip = require(script.Parent.Parent.UI.ItemTooltip)
    ItemTooltip:HideTooltip()
    print("Stopped hovering:", object.Name)
end

function DragSystem:HandleMouseDown()
    -- Prevent dragging if player is dead/ragdolled
    if CollectionService:HasTag(player, "Dead") then
        return
    end
    -- Check if player has equipped tool - if so, skip all drag processing
    if self:HasEquippedTool() then
        return -- Let tool handle the click
    end
    
    -- OPTIMIZATION: Skip drag processing when UIs are open
    if self:IsUIOpen() then
        return -- Let UI handle the click
    end
    
    -- OPTIMIZATION: Only process mouse down if we're actually hovering something
    if not hoveredObject then
        return -- No point processing if nothing is hovered
    end
    
    print("Mouse down detected") -- Debug
    print("Hovered object:", hoveredObject.Name) -- Debug
    
    if not grabbedObject then
        print("Attempting to pickup:", hoveredObject.Name) -- Debug
        self:PickupObject(hoveredObject)
    else
        print("Cannot pickup - already have grabbed object:", grabbedObject.Name) -- Debug
    end
end

function DragSystem:HandleMouseUp()
    -- Prevent dragging if player is dead/ragdolled
    if CollectionService:HasTag(player, "Dead") then
        return
    end
    -- Check if player has equipped tool - if so, skip all drag processing
    if self:HasEquippedTool() then
        return -- Let tool handle the mouse up
    end
    
    -- OPTIMIZATION: Skip drag processing when UIs are open (but still allow dropping)
    if self:IsUIOpen() and not grabbedObject then
        return -- Let UI handle the click, but allow dropping if we have something
    end
    
    -- OPTIMIZATION: Only process mouse up if we actually have a grabbed object
    if not grabbedObject then
        return -- No point processing if nothing is grabbed
    end
    
    print("Mouse up detected") -- Debug
    print("Grabbed object:", grabbedObject.Name) -- Debug
    print("Attempting to drop:", grabbedObject.Name) -- Debug
    self:DropObject(grabbedObject)
end

function DragSystem:PickupObject(object)
    print("Attempting server pickup request for:", object.Name) -- Debug
    
    -- Check if object is within pickup range
    local distanceToObject = (camera.CFrame.Position - object.Position).Magnitude
    if distanceToObject > Constants.DRAG.RAYCAST_DISTANCE then
        warn("Object too far to pickup:", object.Name, "Distance:", distanceToObject)
        return
    end
    
    -- Request pickup from server with error handling
    local success, result, message = pcall(function()
        return RemoteEvents.DragRequest:InvokeServer("pickup", object)
    end)
    
    if not success then
        warn("RemoteFunction call failed:", result)
        return
    end
    
    local serverSuccess, serverMessage = result, message
    print("Server response - Success:", serverSuccess, "Message:", serverMessage) -- Debug
    
    if not serverSuccess then
        warn("Failed to pickup object:", serverMessage)
        return
    end
    
    -- Store the drag distance (clamped to reasonable limits)
    dragDistance = math.clamp(distanceToObject, Constants.DRAG.MIN_DRAG_DISTANCE, Constants.DRAG.MAX_DRAG_DISTANCE)
    
    -- Create attachment on the object
    dragObjectAttachment = Instance.new("Attachment")
    dragObjectAttachment.Name = "DragAttachment"
    dragObjectAttachment.Parent = object
    
    -- Create constraints with anti-exploit settings
    alignPosition = Instance.new("AlignPosition")
    alignPosition.MaxForce = 25000 -- Reduced force to prevent violent movements
    alignPosition.MaxVelocity = 50 -- Limited velocity to prevent flick exploits
    alignPosition.Responsiveness = 100 -- Reduced responsiveness for smoother movement
    alignPosition.Attachment0 = dragObjectAttachment
    alignPosition.Attachment1 = dragTargetAttachment
    alignPosition.Parent = object
    
    alignOrientation = Instance.new("AlignOrientation")
    alignOrientation.MaxTorque = 25000 -- Reduced torque
    alignOrientation.MaxAngularVelocity = 20 -- Limited angular velocity
    alignOrientation.Responsiveness = 50 -- Smoother rotation
    alignOrientation.Attachment0 = dragObjectAttachment
    alignOrientation.Attachment1 = dragTargetAttachment
    alignOrientation.Parent = object
    
    -- Add a BodyVelocity for additional dampening
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(5000, 5000, 5000)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = object
    bodyVelocity.Name = "DragDampening"
    
    grabbedObject = object
    
    -- Stop hovering since we're now dragging
    if hoveredObject == object then
        self:StopHover(object)
        hoveredObject = nil
    end
    
    print("Successfully picked up object:", object.Name, "at distance:", dragDistance)
end

function DragSystem:DropObject(object)
    -- Request drop from server with error handling
    local success, result, message = pcall(function()
        return RemoteEvents.DragRequest:InvokeServer("drop", object)
    end)
    
    if not success then
        warn("RemoteFunction call failed:", result)
    else
        local serverSuccess, serverMessage = result, message
        
        if not serverSuccess then
            warn("Failed to drop object:", serverMessage)
        end
    end
    
    -- Clean up constraints
    if alignPosition then
        alignPosition:Destroy()
        alignPosition = nil
    end
    
    if alignOrientation then
        alignOrientation:Destroy()
        alignOrientation = nil
    end
    
    if dragObjectAttachment then
        dragObjectAttachment:Destroy()
        dragObjectAttachment = nil
    end
    
    -- Clean up dampening BodyVelocity
    local bodyVelocity = object:FindFirstChild("DragDampening")
    if bodyVelocity then
        bodyVelocity:Destroy()
    end
    
    grabbedObject = nil
end

function DragSystem:CheckDragDistance()
    if not grabbedObject then return end
    
    -- Check if the object is still within drag range
    local distanceToObject = (camera.CFrame.Position - grabbedObject.Position).Magnitude
    if distanceToObject > Constants.DRAG.RAYCAST_DISTANCE * 1.5 then -- Give some buffer before auto-dropping
        warn("Object too far away, auto-dropping:", grabbedObject.Name)
        self:DropObject(grabbedObject)
    end
end

function DragSystem:Cleanup()
    -- Disconnect heartbeat connection
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    
    -- Drop any grabbed object
    if grabbedObject then
        self:DropObject(grabbedObject)
    end
    
    -- Clean up drag target attachment
    if dragTargetAttachment then
        dragTargetAttachment:Destroy()
        dragTargetAttachment = nil
    end
    
    -- Clear all state
    grabbedObject = nil
    hoveredObject = nil
    dragDistance = 5
end

function DragSystem:GetHoveredObject()
    return hoveredObject
end

function DragSystem:HasEquippedTool()
    -- Access the global inventory state to avoid circular dependency
    -- This will be set by the InventorySystem when tools are equipped/unequipped
    return _G.PlayerHasEquippedTool == true
end

function DragSystem:IsUIOpen()
    -- Check if any UI that should block drag interactions is open
    local isTraderOpen = _G.TraderUI and _G.TraderUI.isShopOpen
    local isDialogueOpen = _G.DialogueUI and _G.DialogueUI.isDialogueOpen
    local isItemDetailOpen = _G.ItemDetailUI and _G.ItemDetailUI.isDetailOpen
    
    return isTraderOpen or isDialogueOpen or isItemDetailOpen
end

return DragSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="118">
            <Properties>
              <string name="Name">FunctionalSystem</string>
              <string name="Source"><![CDATA[-- Functional system with shared action registry for consumables and special items
local FunctionalSystem = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ActionRegistry = require(ReplicatedStorage.Shared.ActionRegistry)
local ActionConstants = require(ReplicatedStorage.Shared.ActionConstants)
local SystemManager = require(ReplicatedStorage.Shared.SystemManager)

-- Create functional-specific action registry
local functionalRegistry = ActionRegistry.new("FunctionalSystem")

-- Placeholder action for healing essence (to be customized later)
functionalRegistry:RegisterAction(ActionConstants.Functional.HEALING_ESSENCE, function(player, itemDef, target, actionData)
    print("🌿 Healing Essence!")
    print("  - TODO: Implement healing functionality")
    print("  - Item:", itemDef.name)
    
    if target then
        print("  - Could heal target:", target:GetFullName())
    else
        print("  - Could heal self")
    end
    
    -- Placeholder - you can customize this action later
end)

-- Summoner action - spawns boss
functionalRegistry:RegisterAction(ActionConstants.Functional.SUMMONER, function(player, itemDef, target, actionData)
    print("🔮 Summoner activated!")
    print("  - Summoning boss with item:", itemDef.name)
    
    local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
    local spawnPosition = nil
    
    if target then
        print("  - Summoning boss at target location:", target:GetFullName())
        spawnPosition = target.Position
    else
        print("  - Summoning boss at player location")
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            spawnPosition = player.Character.HumanoidRootPart.Position + Vector3.new(10, 0, 0)
        end
    end
    
    -- Fire remote event to spawn boss on server
    RemoteEvents.SpawnBoss:FireServer(spawnPosition)
    print("  - Boss spawn request sent to server")
end)

-- Revive plush action - only triggered via proximity prompt
functionalRegistry:RegisterAction(ActionConstants.Functional.REVIVE_PLUSH, function(player, itemDef, target, actionData)
    print("🧸 Revive Plush!")
    print("  - Item:", itemDef.name)
    print("  - This item can only be used via proximity prompt near dead players")
    
    -- Don't consume the item here - it will be consumed by the revive system
    -- when a successful revive is performed
end)

-- Set default action for functional items without specific actions
functionalRegistry:SetDefaultAction(function(player, itemDef, target, actionData)
    print("⚡ Functional Item Action!")
    print("  - Using", itemDef.name)
    print("  - TODO: Implement specific functionality")
    
    if target then
        print("  - Applied to target:", target:GetFullName())
    else
        print("  - Used without target")
    end
end)

function FunctionalSystem:Initialize()
    SystemManager.RegisterSystem("FunctionalSystem", self)
    print("Functional system initialized with", functionalRegistry:GetActionCount(), "functional actions")
end

function FunctionalSystem:Use(itemDef, player, target)
    print("FunctionalSystem: Use called for", itemDef.name)
    
    -- Check if item should prevent click consumption
    if itemDef.preventClickConsume then
        print("  - Item prevents click consumption:", itemDef.name)
        return
    end
    
    local actionType = itemDef.actionType or ActionConstants.Functional.DEFAULT
    local actionData = itemDef.actionData or {}
    
    print("  - Action Type:", actionType)
    print("  - Action Data:", actionData)
    
    if target then
        print("  - Target:", target:GetFullName())
    else
        print("  - No target was hit.")
    end
    
    -- Execute using shared registry
    functionalRegistry:ExecuteAction(actionType, player, itemDef, target, actionData)
    
    -- Consume the item after use (functional items are single-use)
    local InventorySystem = SystemManager.GetSystem("InventorySystem")
    if InventorySystem then
        print("FunctionalSystem: Consuming item after use")
        InventorySystem:ConsumeEquippedItem()
    else
        warn("FunctionalSystem: Could not find InventorySystem to consume item")
    end
end

-- Legacy methods for backward compatibility
function FunctionalSystem:ExecuteAction(actionName, player, itemDef, target, actionData)
    return functionalRegistry:ExecuteAction(actionName, player, itemDef, target, actionData)
end

function FunctionalSystem:RegisterAction(actionName, actionFunction)
    return functionalRegistry:RegisterAction(actionName, actionFunction)
end

function FunctionalSystem:GetRegisteredActions()
    return functionalRegistry:GetRegisteredActions()
end

return FunctionalSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="119">
            <Properties>
              <string name="Name">HoverSystem</string>
              <string name="Source"><![CDATA[-- Hover system for detecting mouse hover over items
local HoverSystem = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ECS = require(ReplicatedStorage.Shared.ECS)
-- Removed ItemNameDisplay - using rich tooltip from DragSystem instead

local player = Players.LocalPlayer
local mouse = player:GetMouse()

local currentHoveredItem = nil
local heartbeatConnection = nil

function HoverSystem:Initialize()
    -- Connect to heartbeat for continuous hover detection
    heartbeatConnection = RunService.Heartbeat:Connect(function()
        self:Update()
    end)
    
    print("Hover system initialized")
end

-- Cleanup method for proper connection management
function HoverSystem:Cleanup()
    -- Disconnect heartbeat connection
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    
    -- Clear any active hover state
    if currentHoveredItem then
        self:StopHover(currentHoveredItem)
        currentHoveredItem = nil
    end
end

function HoverSystem:Update()
    local target = mouse.Target
    
    -- Check if we're hovering over a new item
    if target and ECS:HasComponent(target, "Hoverable") then
        -- If it's a different item than what we're currently hovering
        if target ~= currentHoveredItem then
            -- Stop hovering the previous item
            if currentHoveredItem then
                self:StopHover(currentHoveredItem)
            end
            
            -- Start hovering the new item
            self:StartHover(target)
            currentHoveredItem = target
        end
        
        -- No position updates needed - DragSystem handles tooltips
    else
        -- Not hovering over any hoverable item
        if currentHoveredItem then
            self:StopHover(currentHoveredItem)
            currentHoveredItem = nil
        end
    end
end

function HoverSystem:StartHover(item)
    local hoverableComponent = ECS:GetComponent(item, "Hoverable")
    if hoverableComponent then
        -- Start the hover effect on the component
        hoverableComponent:StartHover(item)
        
        -- Name display handled by DragSystem's rich tooltip
        local itemName = hoverableComponent:GetDisplayName()
        print("Started hovering:", itemName)
    end
end

function HoverSystem:StopHover(item)
    local hoverableComponent = ECS:GetComponent(item, "Hoverable")
    if hoverableComponent then
        -- Stop the hover effect on the component
        hoverableComponent:StopHover(item)
        
        -- Name display handled by DragSystem's rich tooltip
        
        print("Stopped hovering:", hoverableComponent:GetDisplayName())
    end
end

return HoverSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="120">
            <Properties>
              <string name="Name">InventorySystem</string>
              <string name="Source"><![CDATA[-- Independent inventory system for handling item pickup/drop to inventory
local InventorySystem = {}

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RemoteEvents = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("RemoteEvents"))
local ECS = require(ReplicatedStorage.Shared.ECS)
local InventoryPredictor = require(ReplicatedStorage.Shared.InventoryPredictor)
local UIBatcher = require(ReplicatedStorage.Shared.UIBatcher)

local player = Players.LocalPlayer

-- Inventory state
local playerInventory = {}
local equippedSlot = nil

function InventorySystem:Initialize()
    -- Initialize global state for DragSystem communication (avoid circular dependency)
    _G.PlayerHasEquippedTool = false
    
    -- Set up global reference for ArmorSystem communication (minimal coupling)
    _G.InventorySystem = self
    
    -- Register with SystemManager for ArmorSystem access
    local SystemManager = require(ReplicatedStorage.Shared.SystemManager)
    SystemManager.RegisterSystem("InventorySystem", self)
    
    -- Set up consumption response handler
    RemoteEvents.ConsumeItemResponse.OnClientEvent:Connect(function(success, message, slot)
        self:HandleConsumeItemResponse(success, message, slot)
    end)
    
    -- Independent input connection (separate from DragSystem)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.E then
            self:HandleEKeyPress()
        elseif input.KeyCode == Enum.KeyCode.Q then
            self:HandleQKeyPress()
        else
            local slotNumber = self:GetSlotFromKeyCode(input.KeyCode)
            if slotNumber then
                self:HandleSlotSelection(slotNumber)
            end
        end
    end)
    
    -- Listen for inventory updates from server
    RemoteEvents.UpdateInventory.OnClientEvent:Connect(function(serverInventory)
        self:UpdateInventoryFromServer(serverInventory)
    end)
    
    -- Initialize empty inventory (10 slots)
    for i = 1, 10 do
        playerInventory[i] = nil
    end
    
    print("Inventory system initialized")
end

function InventorySystem:HandleEKeyPress()
    -- Get what player is hovering (reuse HoverSystem's detection)
    local hoveredObject = self:GetCurrentHoveredObject()
    
    if hoveredObject then
        print("DEBUG: Attempting to pickup object:", hoveredObject.Name)
        print("DEBUG: Object type:", hoveredObject.ClassName)
        print("DEBUG: Object parent:", hoveredObject.Parent and hoveredObject.Parent.Name or "nil")
        print("DEBUG: Is model:", hoveredObject:IsA("Model"))
        
        local canPickup = self:CanPickup(hoveredObject)
        print("DEBUG: Can pickup:", canPickup)
        
        if canPickup then
            print("Attempting to pickup to inventory:", hoveredObject.Name)
            self:PickupToInventory(hoveredObject)
        else
            print("Object cannot be picked up:", hoveredObject.Name)
        end
    else
        print("No object being hovered")
    end
end

function InventorySystem:HandleQKeyPress()
    -- Drop currently equipped item
    if equippedSlot and playerInventory[equippedSlot] then
        print("Attempting to drop from inventory slot:", equippedSlot)
        self:DropFromInventory(equippedSlot)
    else
        print("No item equipped to drop")
    end
end

function InventorySystem:GetCurrentHoveredObject()
    -- Access the DragSystem's hovered object (minimal coupling)
    local DragSystem = require(script.Parent.DragSystem)
    local hoveredObject = DragSystem:GetHoveredObject()
    
    -- If we're hovering over a child part of a model, get the parent model instead
    if hoveredObject and hoveredObject.Parent then
        local CollectionService = game:GetService("CollectionService")
        local Constants = require(ReplicatedStorage.Shared.Constants)
        
        -- Check if the parent is a draggable model
        if CollectionService:HasTag(hoveredObject.Parent, Constants.TAGS.DRAGGABLE_ITEM) then
            print("DEBUG: Converting child part to parent model:", hoveredObject.Name, "->", hoveredObject.Parent.Name)
            return hoveredObject.Parent
        end
    end
    
    return hoveredObject
end

function InventorySystem:CanPickup(object)
    -- Check if object has Inventoryable component with canPickup = true
    local hasComponent = ECS:HasComponent(object, "Inventoryable")
    print("DEBUG: Has Inventoryable component:", hasComponent)
    
    if hasComponent then
        local inventoryableComponent = ECS:GetComponent(object, "Inventoryable")
        local canPickup = inventoryableComponent.canPickup == true
        print("DEBUG: Component canPickup:", canPickup)
        return canPickup
    end
    
    -- Fallback: Check if object has DraggableItem tag
    local CollectionService = game:GetService("CollectionService")
    local Constants = require(ReplicatedStorage.Shared.Constants)
    local hasTag = CollectionService:HasTag(object, Constants.TAGS.DRAGGABLE_ITEM)
    print("DEBUG: Has DraggableItem tag:", hasTag)
    
    if hasTag then
        print("DEBUG: Allowing pickup via tag fallback")
        return true
    end
    
    print("DEBUG: No valid pickup method found")
    return false
end

function InventorySystem:PickupToInventory(object)
    -- Find first empty slot
    local emptySlot = self:FindEmptySlot()
    
    if not emptySlot then
        warn("Inventory full!")
        return
    end
    
    -- PERFORMANCE OPTIMIZATION: Use client-side prediction for instant feedback
    local predictionId, predictionResult = InventoryPredictor.predict("pickup_to_inventory", object, emptySlot)
    
    if predictionId then
        -- Apply prediction immediately
        local itemId = self:GetItemIdFromObject(object)
        local inventoryItem = {
            object = object,
            itemName = object.Name,
            itemId = itemId,
            icon = self:GetItemIcon(itemId), -- Temporary icon
            predicted = true,
            predictionId = predictionId
        }
        
        -- Store item in local inventory immediately
        playerInventory[emptySlot] = inventoryItem
        
        -- Update UI immediately
        self:UpdateHotbarUI()
        
        -- Update global state
        _G.PlayerHasEquippedTool = self:HasEquippedTool()
        
        print("Predicted pickup:", object.Name, "in slot", emptySlot)
    end
    
    -- Send async request to server (no blocking)
    task.spawn(function()
        local success, result, message, icon = pcall(function()
            return RemoteEvents.InventoryRequest:InvokeServer("pickup_to_inventory", object, emptySlot)
        end)
        
        if not success then
            warn("InventoryRequest call failed:", result)
            if predictionId then
                InventoryPredictor.rollback(predictionId, "Network error")
                self:UpdateHotbarUI()
            end
            return
        end
        
        local serverSuccess, serverMessage, serverIcon = result, message, icon
        
        if serverSuccess then
            -- Confirm prediction
            if predictionId then
                InventoryPredictor.confirm(predictionId)
                
                -- Update with server data
                if playerInventory[emptySlot] and playerInventory[emptySlot].predictionId == predictionId then
                    playerInventory[emptySlot].icon = serverIcon
                    playerInventory[emptySlot].predicted = nil
                    playerInventory[emptySlot].predictionId = nil
                    self:UpdateHotbarUI()
                end
            end
            
            print("Server confirmed pickup:", object.Name, "in slot", emptySlot)
        else
            -- Server rejected, rollback prediction
            if predictionId then
                InventoryPredictor.rollback(predictionId, serverMessage)
                playerInventory[emptySlot] = nil
                self:UpdateHotbarUI()
                _G.PlayerHasEquippedTool = self:HasEquippedTool()
            end
            warn("Server rejected pickup:", serverMessage)
        end
    end)
end

function InventorySystem:DropFromInventory(slot)
    local inventoryItem = playerInventory[slot]
    if not inventoryItem then return end
    
    -- Request drop from server
    local success, result, message = pcall(function()
        return RemoteEvents.InventoryRequest:InvokeServer("drop_from_inventory", slot)
    end)
    
    if not success then
        warn("InventoryRequest call failed:", result)
    else
        local serverSuccess, serverMessage = result, message
        
        if serverSuccess then
            -- Remove from local inventory
            playerInventory[slot] = nil
            
            -- Unequip if this was equipped
            if equippedSlot == slot then
                equippedSlot = nil
            end
            
            -- Update hotbar UI
            self:UpdateHotbarUI()
            
            -- Update global state for DragSystem (avoid circular dependency)
            _G.PlayerHasEquippedTool = self:HasEquippedTool()
            
            print("Successfully dropped from inventory slot:", slot)
        else
            warn("Failed to drop from inventory:", serverMessage)
        end
    end
end

function InventorySystem:FindEmptySlot()
    for i = 1, 10 do
        if not playerInventory[i] then
            return i
        end
    end
    return nil
end

function InventorySystem:EquipSlot(slot)
    if playerInventory[slot] then
        equippedSlot = slot
        self:UpdateHotbarUI()
        print("Equipped slot:", slot)
    else
        -- Unequip if trying to equip empty slot
        equippedSlot = nil
        self:UpdateHotbarUI()
    end
    
    -- Update global state for DragSystem (avoid circular dependency)
    _G.PlayerHasEquippedTool = self:HasEquippedTool()
end

function InventorySystem:UpdateHotbarUI()
    -- PERFORMANCE OPTIMIZATION: Batch UI updates to prevent frame drops
    UIBatcher.queueHotbarUpdate(function()
        local Hotbar = require(script.Parent.Parent.UI.Hotbar)
        Hotbar:UpdateDisplay(playerInventory, equippedSlot)
    end, 2) -- Medium priority
end

function InventorySystem:GetInventory()
    return playerInventory
end

function InventorySystem:GetEquippedSlot()
    return equippedSlot
end

function InventorySystem:HasEquippedTool()
    return equippedSlot ~= nil and playerInventory[equippedSlot] ~= nil
end

function InventorySystem:GetEquippedToolName()
    if self:HasEquippedTool() then
        return playerInventory[equippedSlot].itemName
    end
    return nil
end

function InventorySystem:GetSlotFromKeyCode(keyCode)
    -- Map key codes to slot numbers
    if keyCode == Enum.KeyCode.One then return 1
    elseif keyCode == Enum.KeyCode.Two then return 2
    elseif keyCode == Enum.KeyCode.Three then return 3
    elseif keyCode == Enum.KeyCode.Four then return 4
    elseif keyCode == Enum.KeyCode.Five then return 5
    elseif keyCode == Enum.KeyCode.Six then return 6
    elseif keyCode == Enum.KeyCode.Seven then return 7
    elseif keyCode == Enum.KeyCode.Eight then return 8
    elseif keyCode == Enum.KeyCode.Nine then return 9
    elseif keyCode == Enum.KeyCode.Zero then return 10
    end
    return nil
end

function InventorySystem:HandleSlotSelection(slotNumber)
    print("=== SLOT SELECTION DEBUG START ===")
    print("User pressed key for slot:", slotNumber)
    print("Current equipped slot:", equippedSlot)
    print("Item in requested slot:", playerInventory[slotNumber] and playerInventory[slotNumber].itemName or "EMPTY")
    
    -- If pressing the same slot number that's already equipped, unequip (empty hands)
    local targetSlot = slotNumber
    if equippedSlot == slotNumber then
        targetSlot = nil -- Unequip by sending nil
        print("SLOT SELECTION: Same slot pressed, will unequip")
    else
        print("SLOT SELECTION: Different slot pressed, will equip slot", slotNumber)
    end
    
    -- Request slot equip from server
    print("SLOT SELECTION: Sending equip request to server for slot:", targetSlot)
    local success, result, message = pcall(function()
        return RemoteEvents.InventoryRequest:InvokeServer("equip_slot", targetSlot)
    end)
    
    if not success then
        warn("SLOT SELECTION ERROR: InventoryRequest call failed:", result)
        return
    end
    
    local serverSuccess, serverMessage = result, message
    print("SLOT SELECTION: Server response - Success:", serverSuccess, "Message:", serverMessage)
    
    if serverSuccess then
        -- Update local equipped slot
        if targetSlot == nil then
            equippedSlot = nil
            print("SLOT SELECTION: Unequipped - hands are now empty")
        else
            self:EquipSlot(slotNumber)
            print("SLOT SELECTION: Successfully equipped slot:", slotNumber)
        end
        
        -- Update hotbar UI
        self:UpdateHotbarUI()
        
        -- Update global state for DragSystem (avoid circular dependency)
        _G.PlayerHasEquippedTool = self:HasEquippedTool()
    else
        warn("SLOT SELECTION: Failed to equip slot:", serverMessage)
    end
    
    print("=== SLOT SELECTION DEBUG END ===")
end

function InventorySystem:GetEquippedItem()
    -- Simplified logging
    
    -- Get currently equipped item for armor system integration
    if equippedSlot and playerInventory[equippedSlot] then
        local inventoryItem = playerInventory[equippedSlot]
        
        -- Use stored itemId if available, otherwise generate from object
        local itemId = inventoryItem.itemId or self:GetItemIdFromObject(inventoryItem.object)
        
        local result = {
            itemName = inventoryItem.itemName,
            itemId = itemId,
            object = inventoryItem.object,
            slot = equippedSlot
        }
        
        return result
    else
        return nil
    end
end

function InventorySystem:GetItemIdFromObject(object)
    -- Helper function to get item ID from object name
    -- Convert object name to itemId format (lowercase with underscores)
    local itemId = string.lower(object.Name)
    itemId = string.gsub(itemId, " ", "_")  -- Replace spaces with underscores
    return itemId
end

function InventorySystem:HandleArmorEquipped()
    -- Called by ArmorSystem when armor is equipped from hotbar
    if equippedSlot and playerInventory[equippedSlot] then
        -- Remove equipped item from hotbar inventory
        playerInventory[equippedSlot] = nil
        equippedSlot = nil
        
        -- Update hotbar UI
        self:UpdateHotbarUI()
        
        -- Update global state
        _G.PlayerHasEquippedTool = self:HasEquippedTool()
    end
end

function InventorySystem:HandleArmorUnequipped(armorItem)
    print("[INVENTORY DEBUG] --- HandleArmorUnequipped START ---")
    print("[INVENTORY DEBUG] Called by ArmorSystem - armor was unequipped back to hotbar")
    print("[INVENTORY DEBUG] Armor item to restore:", armorItem and armorItem.itemName or "UNKNOWN")
    
    -- Called by ArmorSystem when armor is unequipped back to hotbar
    -- Find empty slot or replace equipped slot
    local targetSlot = self:FindEmptySlot()
    print("[INVENTORY DEBUG] Looking for empty slot, found:", targetSlot)
    
    if not targetSlot then
        -- If no empty slot, replace currently equipped slot
        targetSlot = equippedSlot or 1
        print("[INVENTORY DEBUG] No empty slot, using equipped slot or slot 1:", targetSlot)
    end
    
    print("[INVENTORY DEBUG] Target slot for armor return:", targetSlot)
    
    -- Add armor back to hotbar inventory
    local inventoryItem = {
        object = armorItem.object,
        itemName = armorItem.itemName,
        itemId = armorItem.itemId,  -- Include itemId for proper item identification
        icon = self:GetItemIcon(armorItem.itemId)
    }
    
    print("[INVENTORY DEBUG] Created inventory item for slot:", inventoryItem)
    
    playerInventory[targetSlot] = inventoryItem
    print("[INVENTORY DEBUG] Added armor to hotbar slot", targetSlot)
    
    -- Leave player hands empty; unequip on both client and server
    equippedSlot = nil
    print("[INVENTORY DEBUG] Returned armor stored, hands left empty")

    -- Notify server to clear equipped slot (hands empty)
    pcall(function()
        RemoteEvents.InventoryRequest:InvokeServer("equip_slot", nil)
    end)
    
    -- Update hotbar UI
    self:UpdateHotbarUI()
    print("[INVENTORY DEBUG] Hotbar UI updated")
    
    -- Update global state
    _G.PlayerHasEquippedTool = self:HasEquippedTool()
    print("[INVENTORY DEBUG] Global state updated - HasEquippedTool:", _G.PlayerHasEquippedTool)
    
end

function InventorySystem:GetItemIcon(itemId)
    -- Helper function to get item icon for display
    local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)
    local itemDef = ItemDefinitions:GetItem(itemId)
    
    if itemDef and itemDef.components and itemDef.components.Inventoryable then
        return itemDef.components.Inventoryable.inventoryIcon
    end
    
    return "❓" -- Default unknown icon
end

function InventorySystem:SwapSlots(slot1, slot2)
    -- Swap items between two slots while preserving equipped item
    -- Get current items
    local item1 = playerInventory[slot1]
    local item2 = playerInventory[slot2]
    
    -- Perform the swap
    playerInventory[slot1] = item2
    playerInventory[slot2] = item1
    
    -- CRITICAL: Preserve equipped item by updating equippedSlot if needed
    local originalEquippedSlot = equippedSlot
    local needsServerSync = false
    
    if equippedSlot == slot1 then
        -- The equipped item moved from slot1 to slot2
        equippedSlot = slot2
        needsServerSync = true
        print("EQUIPPED ITEM TRACKING: Equipped item moved from slot", slot1, "to slot", slot2)
    elseif equippedSlot == slot2 then
        -- The equipped item moved from slot2 to slot1
        equippedSlot = slot1
        needsServerSync = true
        print("EQUIPPED ITEM TRACKING: Equipped item moved from slot", slot2, "to slot", slot1)
    else
        print("EQUIPPED ITEM TRACKING: Equipped slot", equippedSlot, "not affected by swap")
    end
    
    -- Debug: Log final local state
    print("FINAL LOCAL STATE:")
    print("  - New equipped slot:", equippedSlot)
    print("  - Item in new equipped slot:", equippedSlot and playerInventory[equippedSlot] and playerInventory[equippedSlot].itemName or "NONE")
    
    -- CRITICAL FIX: Notify server about the slot swap so server inventory stays in sync
    print("SERVER SYNC: Notifying server about slot swap:", slot1, "↔", slot2)
    local swapSuccess, swapResult, swapMessage = pcall(function()
        return RemoteEvents.InventoryRequest:InvokeServer("swap_slots", slot1, slot2)
    end)
    
    if not swapSuccess then
        warn("SERVER SYNC ERROR: Failed to sync slot swap with server:", swapResult)
    else
        local serverSwapSuccess, serverSwapMessage = swapResult, swapMessage
        if not serverSwapSuccess then
            warn("SERVER SYNC REJECTED: Server rejected slot swap:", serverSwapMessage)
        else
            print("SERVER SYNC SUCCESS: Server confirmed slot swap")
        end
    end
    
    -- Notify server about the equipped slot change (if equipped item moved)
    if needsServerSync then
        print("SERVER SYNC: Notifying server of equipped slot change to", equippedSlot)
        local success, result, message = pcall(function()
            return RemoteEvents.InventoryRequest:InvokeServer("equip_slot", equippedSlot)
        end)
        
        if not success then
            warn("SERVER SYNC ERROR: Failed to sync equipped slot with server:", result)
        else
            local serverSuccess, serverMessage = result, message
            if not serverSuccess then
                warn("SERVER SYNC REJECTED:", serverMessage)
            else
                print("SERVER SYNC SUCCESS: Server confirmed equipped slot:", equippedSlot)
            end
        end
    else
        print("SERVER SYNC: No equipped slot sync needed (equipped item not moved)")
    end
    
    -- Update hotbar UI to reflect the swap
    self:UpdateHotbarUI()
    
    -- Update global state for DragSystem
    _G.PlayerHasEquippedTool = self:HasEquippedTool()
    
    print("=== SLOT SWAP DEBUG END ===")
    print("Final result - equipped slot:", equippedSlot)
end

function InventorySystem:EquipSlotDirect(slot)
    -- Request equip slot to server
    local success, result, message = pcall(function()
        return RemoteEvents.InventoryRequest:InvokeServer("equip_slot", slot)
    end)

    if success and result then
        self:EquipSlot(slot)
        return true
    else
        warn("EquipSlotDirect failed:", message)
        return false
    end
end

-- Method called by ArmorSystem to get currently equipped item
function InventorySystem:GetEquippedItem()
    if equippedSlot and playerInventory[equippedSlot] then
        return playerInventory[equippedSlot]
    end
    return nil
end

-- Method called by ArmorSystem when armor is equipped (remove from hotbar)
function InventorySystem:HandleArmorEquipped()
    if equippedSlot and playerInventory[equippedSlot] then
        -- Clear the equipped slot since item was moved to armor
        playerInventory[equippedSlot] = nil
        equippedSlot = nil
        
        -- Update hotbar UI
        self:UpdateHotbarUI()
        
        -- Update global state
        _G.PlayerHasEquippedTool = self:HasEquippedTool()
        
        return true
    end
    return false
end

-- Update inventory from server data (used after trades)
function InventorySystem:UpdateInventoryFromServer(serverInventory)
    print("Updating inventory from server data")
    
    -- Clear current inventory
    for i = 1, 10 do
        playerInventory[i] = nil
    end
    
    -- Update with server data
    for slot, inventoryItem in pairs(serverInventory) do
        if inventoryItem then
            -- Get itemId from object name if not provided
            local itemId = inventoryItem.itemId or self:GetItemIdFromObject(inventoryItem.object or {Name = inventoryItem.itemName})
            
            playerInventory[slot] = {
                itemName = inventoryItem.itemName,
                itemId = itemId,  -- Include itemId
                icon = inventoryItem.icon,
                object = inventoryItem.object  -- Include object if available
            }
        end
    end
    
    -- Clear equipped slot since items were removed
    equippedSlot = nil
    
    -- Update the hotbar UI
    self:UpdateHotbarUI()
    
    -- Update global state
    _G.PlayerHasEquippedTool = self:HasEquippedTool()
    
    print("Inventory updated from server")
end

-- Handle consumption response from server
function InventorySystem:HandleConsumeItemResponse(success, message, slot)
    print("DEBUG: Received consumption response - success:", success, "message:", message, "slot:", slot)
    
    if success then
        print("DEBUG: Server confirmed consumption, updating client state for slot", slot)
        
        local consumedItem = playerInventory[slot]
        local itemName = consumedItem and consumedItem.itemName or "Unknown Item"
        
        -- Remove from local inventory
        playerInventory[slot] = nil
        print("DEBUG: Cleared inventory slot", slot)
        
        -- Clear equipped slot if this was the equipped item
        if equippedSlot == slot then
            equippedSlot = nil
            print("DEBUG: Cleared equipped slot")
        end
        
        -- Update hotbar UI
        self:UpdateHotbarUI()
        print("DEBUG: Updated hotbar UI")
        
        -- Update global state
        _G.PlayerHasEquippedTool = self:HasEquippedTool()
        print("DEBUG: Updated global state")
        
        print("Successfully consumed item:", itemName)
    else
        warn("Server rejected item consumption:", message)
    end
end

-- Method to consume the currently equipped item (for functional items)
function InventorySystem:ConsumeEquippedItem()
    if not equippedSlot or not playerInventory[equippedSlot] then
        warn("No equipped item to consume")
        return false
    end
    
    local consumedItem = playerInventory[equippedSlot]
    print("Consuming equipped item:", consumedItem.itemName, "from slot", equippedSlot)
    
    -- Send consumption request to server (fire and forget)
    print("DEBUG: Sending ConsumeItemRequest to server for slot", equippedSlot)
    RemoteEvents.ConsumeItemRequest:FireServer(equippedSlot)
    
    -- The response will be handled by HandleConsumeItemResponse
    print("DEBUG: Consumption request sent, waiting for server response")
    return true -- Always return true since we're using async communication
end

return InventorySystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="121">
            <Properties>
              <string name="Name">ItemSetupSystem</string>
              <string name="Source"><![CDATA[ -- Client-side item setup system - adds components to spawned items
local ItemSetupSystem = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

local ECS = require(ReplicatedStorage.Shared.ECS)
local ItemDefinitions = require(ReplicatedStorage.Shared.ItemDefinitions)
local Constants = require(ReplicatedStorage.Shared.Constants)

-- Component classes
local Draggable = require(ReplicatedStorage.Shared.Components.Draggable)
local Hoverable = require(ReplicatedStorage.Shared.Components.Hoverable)
local Inventoryable = require(ReplicatedStorage.Shared.Components.Inventoryable)

local processedItems = {}

function ItemSetupSystem:Initialize()
    -- Process existing tagged items
    local existingItems = CollectionService:GetTagged(Constants.TAGS.DRAGGABLE_ITEM)
    for _, item in ipairs(existingItems) do
        self:SetupItem(item)
    end
    
    -- Listen for new tagged items
    CollectionService:GetInstanceAddedSignal(Constants.TAGS.DRAGGABLE_ITEM):Connect(function(item)
        self:SetupItem(item)
    end)
    
    -- Listen for removed tagged items (cleanup)
    CollectionService:GetInstanceRemovedSignal(Constants.TAGS.DRAGGABLE_ITEM):Connect(function(item)
        self:CleanupItem(item)
    end)
    
    print("Item setup system initialized")
end

function ItemSetupSystem:SetupItem(item)
    -- Avoid processing the same item twice
    if processedItems[item] then return end
    processedItems[item] = true
    
    -- Skip Handle objects (they are part of tools, not world items)
    if item.Name == "Handle" then
        return
    end
    
    -- Find the item definition by name
    local itemDefinition = self:FindItemDefinitionByName(item.Name)
    if not itemDefinition then
        warn("No item definition found for:", item.Name, "- item may not have proper components")
        return
    end
    
    -- Add components to the item on the client (if not already added server-side)
    self:AddComponentsToItem(item, itemDefinition.components)
    
    print("Setup item on client:", item.Name)
end

function ItemSetupSystem:FindItemDefinitionByName(itemName)
    for itemId, definition in pairs(ItemDefinitions.items) do
        if definition.name == itemName then
            return definition
        end
    end
    return nil
end

function ItemSetupSystem:AddComponentsToItem(item, componentConfigs)
    for componentName, config in pairs(componentConfigs) do
        local component = self:CreateComponent(componentName, config)
        if component then
            ECS:AddComponent(item, componentName, component)
        else
            warn("Failed to create component:", componentName)
        end
    end
end

function ItemSetupSystem:CreateComponent(componentName, config)
    if componentName == "Draggable" then
        return Draggable.new(config)
    elseif componentName == "Hoverable" then
        return Hoverable.new(config)
    elseif componentName == "Inventoryable" then
        return Inventoryable.new(config)
    else
        warn("Unknown component type:", componentName)
        return nil
    end
end



function ItemSetupSystem:CleanupItem(item)
    -- Remove from processed items
    processedItems[item] = nil
    
    -- Clean up ECS components
    ECS:RemoveAllComponents(item)
    
    print("Cleaned up item:", item.Name)
end

return ItemSetupSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="122">
            <Properties>
              <string name="Name">PrayerSystem</string>
              <string name="Source"><![CDATA[-- PrayerSystem.luau
-- Client-side prayer system for interacting with prayer figures using ProximityPrompt

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")

local AltarConfig = require(ReplicatedStorage.Shared.AltarConfig)

local PrayerSystem = {}

local player = Players.LocalPlayer

-- Track prayer figures and their prompts
local prayerFigures = {} -- [figure] = prompt

function PrayerSystem:Initialize()
    print("Initializing PrayerSystem...")
    
    -- Find existing prayer figures
    self:SetupExistingPrayerFigures()
    
    -- Listen for new prayer figures
    CollectionService:GetInstanceAddedSignal("Prayer"):Connect(function(figure)
        self:SetupPrayerFigure(figure)
    end)
    
    -- Listen for prayer figure removal
    CollectionService:GetInstanceRemovedSignal("Prayer"):Connect(function(figure)
        self:CleanupPrayerFigure(figure)
    end)
    
    print("PrayerSystem initialized")
end

-- Setup existing prayer figures
function PrayerSystem:SetupExistingPrayerFigures()
    local taggedFigures = CollectionService:GetTagged("Prayer")
    for _, figure in ipairs(taggedFigures) do
        self:SetupPrayerFigure(figure)
    end
    print("Setup", #taggedFigures, "existing prayer figures")
end

-- Setup a single prayer figure
function PrayerSystem:SetupPrayerFigure(figure)
    -- Create ProximityPrompt for the prayer figure
    local prompt = Instance.new("ProximityPrompt")
    prompt.ObjectText = "Prayer Figure"
    prompt.ActionText = "Pray"
    prompt.HoldDuration = AltarConfig.PRAYER_CONFIG.prayerDuration
    prompt.MaxActivationDistance = AltarConfig.PRAYER_CONFIG.interactionDistance
    prompt.RequiresLineOfSight = false
    prompt.Triggered:Connect(function(playerWhoTriggered)
        if playerWhoTriggered == player then
            self:HandlePrayerTriggered(figure)
        end
    end)
    
    -- Attach prompt to the figure
    if figure:IsA("Model") then
        -- For models, attach to primary part or first part
        local primaryPart = figure.PrimaryPart
        if primaryPart then
            prompt.Parent = primaryPart
        else
            -- Find first part in the model
            for _, child in ipairs(figure:GetChildren()) do
                if child:IsA("BasePart") then
                    prompt.Parent = child
                    break
                end
            end
        end
    else
        -- For parts, attach directly
        prompt.Parent = figure
    end
    
    prayerFigures[figure] = prompt
    print("Setup prayer figure with ProximityPrompt:", figure:GetFullName())
end

-- Cleanup a single prayer figure
function PrayerSystem:CleanupPrayerFigure(figure)
    if prayerFigures[figure] then
        prayerFigures[figure]:Destroy()
        prayerFigures[figure] = nil
        print("Cleaned up prayer figure:", figure:GetFullName())
    end
end

-- Handle when prayer is triggered via ProximityPrompt
function PrayerSystem:HandlePrayerTriggered(figure)
    print("Prayer triggered for:", figure.Name)
    
    -- Send prayer request to server
    local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
    if RemoteEvents.PrayerRequest then
        RemoteEvents.PrayerRequest:FireServer(figure)
    end
end

return PrayerSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="123">
            <Properties>
              <string name="Name">RevivePromptSystem</string>
              <string name="Source"><![CDATA[-- RevivePromptSystem.luau
-- Client-side system for managing revive proximity prompts

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local RevivePromptSystem = {}

local player = Players.LocalPlayer

-- Track revive prompts
local revivePrompts = {} -- [ragdollCharacter] = prompt
local hasRevivePlushEquipped = false

-- Configuration
local PROMPT_DISTANCE = 8 -- Distance to show revive prompt
local PROMPT_HOLD_DURATION = 0 -- No hold required for revive

function RevivePromptSystem:Initialize()
    print("Initializing RevivePromptSystem...")
    
    -- Wait a moment for RemoteEvents to be ready
    task.wait(0.1)
    
    -- Wait for RemoteEvents to be available with error handling
    local success, errorMessage = pcall(function()
        -- Set up revive response handler
        RemoteEvents.ReviveResponse.OnClientEvent:Connect(function(success, message)
            self:HandleReviveResponse(success, message)
        end)
        
        -- Monitor for revive plush equipment changes
        self:SetupEquipmentMonitoring()
        
        print("RevivePromptSystem initialized successfully")
    end)
    
    if not success then
        warn("RevivePromptSystem initialization failed:", errorMessage)
    end
end

-- Set up monitoring for revive plush equipment
function RevivePromptSystem:SetupEquipmentMonitoring()
    -- Monitor for inventory updates with error handling
    local success, errorMessage = pcall(function()
        RemoteEvents.UpdateInventory.OnClientEvent:Connect(function()
            self:CheckRevivePlushEquipment()
        end)
    end)
    
    if not success then
        warn("Failed to connect to UpdateInventory RemoteEvent:", errorMessage)
    end
    
    -- Also monitor for slot selection changes (when player equips/unequips items)
    local SystemManager = require(ReplicatedStorage.Shared.SystemManager)
    local InventorySystem = SystemManager.GetSystem("InventorySystem")
    if InventorySystem then
        -- We'll check equipment status periodically since there's no direct event
        -- This is a simple solution - in a more robust system, we'd add events to InventorySystem
        task.spawn(function()
            while true do
                task.wait(0.5) -- Check every 0.5 seconds
                self:CheckRevivePlushEquipment()
            end
        end)
    end
    
    -- Initial check
    self:CheckRevivePlushEquipment()
end

-- Check if player has revive plush equipped
function RevivePromptSystem:CheckRevivePlushEquipment()
    local hadRevivePlush = hasRevivePlushEquipped
    
    -- Get the inventory system to check for revive plush
    local SystemManager = require(ReplicatedStorage.Shared.SystemManager)
    local InventorySystem = SystemManager.GetSystem("InventorySystem")
    
    if InventorySystem then
        -- Check if player has revive plush equipped
        local equippedItem = InventorySystem:GetEquippedItem()
        if equippedItem then
            -- Check if the equipped item is a revive plush
            local itemId = equippedItem.itemId or InventorySystem:GetItemIdFromObject(equippedItem.object)
            hasRevivePlushEquipped = (itemId == "revive_plush")
            
            print("RevivePromptSystem: Checking equipped item:", equippedItem.itemName, "itemId:", itemId, "isRevivePlush:", hasRevivePlushEquipped)
        else
            hasRevivePlushEquipped = false
            print("RevivePromptSystem: No item equipped")
        end
    else
        warn("RevivePromptSystem: Could not find InventorySystem")
        hasRevivePlushEquipped = false
    end
    
    -- Update prompts if equipment status changed
    if hadRevivePlush ~= hasRevivePlushEquipped then
        print("RevivePromptSystem: Equipment status changed to:", hasRevivePlushEquipped)
        self:UpdateAllPrompts()
    end
end

-- Update all revive prompts based on equipment status
function RevivePromptSystem:UpdateAllPrompts()
    if hasRevivePlushEquipped then
        -- Create prompts for all dead players
        self:CreatePromptsForDeadPlayers()
    else
        -- Remove all prompts
        self:RemoveAllPrompts()
    end
end

-- Create prompts for all dead players in workspace
function RevivePromptSystem:CreatePromptsForDeadPlayers()
    print("RevivePromptSystem: Creating prompts for dead players...")
    
    local foundDeadPlayers = 0
    -- Find all dead players in workspace
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("Model") and CollectionService:HasTag(descendant, "Draggable") then
            local playerFromCharacter = Players:GetPlayerFromCharacter(descendant)
            if playerFromCharacter and CollectionService:HasTag(playerFromCharacter, "Dead") then
                foundDeadPlayers = foundDeadPlayers + 1
                print("RevivePromptSystem: Creating prompt for dead player:", playerFromCharacter.Name)
                self:CreateRevivePrompt(playerFromCharacter, descendant)
            end
        end
    end
    print("RevivePromptSystem: Found", foundDeadPlayers, "dead players in workspace")
end

-- Remove all revive prompts
function RevivePromptSystem:RemoveAllPrompts()
    print("RevivePromptSystem: Removing all prompts...")
    for ragdollCharacter, prompt in pairs(revivePrompts) do
        if prompt and prompt.Parent then
            prompt:Destroy()
        end
    end
    revivePrompts = {}
end

-- Create a revive prompt for a dead player
function RevivePromptSystem:CreateRevivePrompt(deadPlayer, ragdollCharacter)
    -- Don't create duplicate prompts
    if revivePrompts[ragdollCharacter] then
        return
    end
    
    -- Find the primary part of the ragdoll
    local primaryPart = ragdollCharacter.PrimaryPart
    if not primaryPart then
        warn("RevivePromptSystem: No primary part found for ragdoll:", deadPlayer.Name)
        return
    end
    
    -- Create the proximity prompt
    local prompt = Instance.new("ProximityPrompt")
    prompt.ObjectText = "Dead Player"
    prompt.ActionText = "Revive"
    prompt.HoldDuration = PROMPT_HOLD_DURATION
    prompt.MaxActivationDistance = PROMPT_DISTANCE
    prompt.RequiresLineOfSight = false
    
    -- Connect the triggered event
    prompt.Triggered:Connect(function()
        self:HandleReviveTriggered(deadPlayer, ragdollCharacter)
    end)
    
    -- Parent the prompt to the ragdoll's primary part
    prompt.Parent = primaryPart
    
    -- Store the prompt
    revivePrompts[ragdollCharacter] = prompt
    
    print("RevivePromptSystem: Created revive prompt for:", deadPlayer.Name)
end

-- Remove a revive prompt
function RevivePromptSystem:RemoveRevivePrompt(ragdollCharacter)
    local prompt = revivePrompts[ragdollCharacter]
    if prompt and prompt.Parent then
        prompt:Destroy()
    end
    revivePrompts[ragdollCharacter] = nil
end

-- Handle when a revive prompt is triggered
function RevivePromptSystem:HandleReviveTriggered(deadPlayer, ragdollCharacter)
    print("RevivePromptSystem: Revive triggered for:", deadPlayer.Name)
    
    -- Double-check that we have the revive plush equipped
    if not hasRevivePlushEquipped then
        print("RevivePromptSystem: Revive plush not equipped, ignoring trigger")
        return
    end
    
    -- Send revive request to server
    RemoteEvents.ReviveRequest:FireServer(deadPlayer)
end

-- Handle revive response from server
function RevivePromptSystem:HandleReviveResponse(success, message)
    if success then
        print("RevivePromptSystem: Revive successful:", message)
        -- Remove all prompts since the player was revived
        self:RemoveAllPrompts()
    else
        print("RevivePromptSystem: Revive failed:", message)
    end
end

-- Manual test function (for debugging)
function RevivePromptSystem:TestRevivePlushDetection()
    print("=== RevivePromptSystem Test ===")
    print("Current hasRevivePlushEquipped:", hasRevivePlushEquipped)
    
    local SystemManager = require(ReplicatedStorage.Shared.SystemManager)
    local InventorySystem = SystemManager.GetSystem("InventorySystem")
    
    if InventorySystem then
        local equippedItem = InventorySystem:GetEquippedItem()
        if equippedItem then
            local itemId = equippedItem.itemId or InventorySystem:GetItemIdFromObject(equippedItem.object)
            print("Equipped item:", equippedItem.itemName)
            print("Item ID:", itemId)
            print("Is revive plush:", itemId == "revive_plush")
        else
            print("No item equipped")
        end
    else
        print("InventorySystem not found")
    end
    
    local promptCount = 0
    for _ in pairs(revivePrompts) do
        promptCount = promptCount + 1
    end
    print("Number of revive prompts:", promptCount)
    
    -- Check for dead players in workspace
    local deadPlayerCount = 0
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("Model") and CollectionService:HasTag(descendant, "Draggable") then
            local playerFromCharacter = Players:GetPlayerFromCharacter(descendant)
            if playerFromCharacter and CollectionService:HasTag(playerFromCharacter, "Dead") then
                deadPlayerCount = deadPlayerCount + 1
                print("Found dead player in workspace:", playerFromCharacter.Name)
            end
        end
    end
    print("Dead players in workspace:", deadPlayerCount)
end

-- TEMPORARY: Test function to spawn revive plush
function RevivePromptSystem:TestSpawnRevivePlush()
    print("RevivePromptSystem: Testing revive plush spawn...")
    
    local testSpawnRemote = ReplicatedStorage:FindFirstChild("TestSpawnRevivePlush")
    if testSpawnRemote then
        testSpawnRemote:FireServer()
        print("RevivePromptSystem: Sent test spawn request to server")
    else
        warn("RevivePromptSystem: TestSpawnRevivePlush remote not found")
    end
end

return RevivePromptSystem ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="124">
            <Properties>
              <string name="Name">SacrificeIndicator</string>
              <string name="Source"><![CDATA[-- SacrificeIndicator.luau
-- Shows which ragdolls are valid sacrifices

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

local SacrificeIndicator = {}

-- Track sacrifice highlights
local sacrificeHighlights = {} -- [ragdoll] = highlight

function SacrificeIndicator:Initialize()
    print("Initializing SacrificeIndicator...")
    
    -- Find existing sacrifices
    self:SetupExistingSacrifices()
    
    -- Listen for new sacrifices
    CollectionService:GetInstanceAddedSignal("Sacrifice"):Connect(function(ragdoll)
        self:SetupSacrificeIndicator(ragdoll)
    end)
    
    -- Listen for sacrifice removal
    CollectionService:GetInstanceRemovedSignal("Sacrifice"):Connect(function(ragdoll)
        self:CleanupSacrificeIndicator(ragdoll)
    end)
    
    print("SacrificeIndicator initialized")
end

-- Setup indicators for existing sacrifices
function SacrificeIndicator:SetupExistingSacrifices()
    local taggedSacrifices = CollectionService:GetTagged("Sacrifice")
    for _, sacrifice in ipairs(taggedSacrifices) do
        self:SetupSacrificeIndicator(sacrifice)
    end
    print("Setup indicators for", #taggedSacrifices, "existing sacrifices")
end

-- Setup indicator for a single sacrifice
function SacrificeIndicator:SetupSacrificeIndicator(ragdoll)
    -- No visual changes - just track for debugging
    sacrificeHighlights[ragdoll] = true -- Just mark as tracked
    
    print("Setup indicator for sacrifice:", ragdoll.Name)
end

-- Cleanup indicator for a single sacrifice
function SacrificeIndicator:CleanupSacrificeIndicator(ragdoll)
    if sacrificeHighlights[ragdoll] then
        sacrificeHighlights[ragdoll] = nil
        print("Cleaned up indicator for sacrifice:", ragdoll.Name)
    end
end

-- Update sacrifice highlight when it's being dragged
function SacrificeIndicator:UpdateSacrificeHighlight(ragdoll, isBeingDragged)
    -- No visual changes - just track for debugging
    if sacrificeHighlights[ragdoll] then
        if isBeingDragged then
            print("Sacrifice being dragged:", ragdoll.Name)
        end
    end
end

return SacrificeIndicator ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="125">
            <Properties>
              <string name="Name">ToolSystem</string>
              <string name="Source"><![CDATA[-- Tool system with shared action registry for different tool types
local ToolSystem = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ActionRegistry = require(ReplicatedStorage.Shared.ActionRegistry)
local ActionConstants = require(ReplicatedStorage.Shared.ActionConstants)
local SystemManager = require(ReplicatedStorage.Shared.SystemManager)
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

-- Create tool-specific action registry
local toolRegistry = ActionRegistry.new("ToolSystem")

-- Register generic tool attack action (all tools use this)
toolRegistry:RegisterAction(ActionConstants.Tool.ATTACK, function(player, itemDef, target, actionData, attackType)
    local baseDamage = actionData.damage or 10
    local chargeMultiplier = actionData.chargeMultiplier or 1.0
    local criticalMultiplier = actionData.criticalMultiplier or 3.0 -- Critical attacks do 3x damage
    local weaponName = itemDef.name or "Tool"
    
    -- Calculate final damage based on attack type
    local finalDamage = baseDamage
    local isCharged = attackType == "charged"
    local isCritical = attackType == "critical"
    
    if isCritical then
        finalDamage = math.floor(baseDamage * criticalMultiplier)
    elseif isCharged then
        finalDamage = math.floor(baseDamage * chargeMultiplier)
    end
    
    -- Display attack type with appropriate styling
    if isCritical then
        print("💥 CRITICAL", weaponName, "Attack!")
        print("  - Base Damage:", baseDamage)
        print("  - Critical Multiplier:", criticalMultiplier .. "x")
        print("  - Final Damage:", finalDamage)
    elseif isCharged then
        print("⚔️", weaponName, "CHARGED Attack!")
        print("  - Base Damage:", baseDamage)
        print("  - Charge Multiplier:", chargeMultiplier .. "x")
        print("  - Final Damage:", finalDamage)
    else
        print("⚔️", weaponName, "Attack!")
        print("  - Final Damage:", finalDamage)
    end
    
    if target then
        print("  - Attacking target:", target:GetFullName())
        
        -- Play appropriate hit sound based on attack type
        if _G.AudioSystem then
            if isCritical then
                -- Delay critical hit sound by 0.1 seconds after timing success
                task.wait(0.1)
                _G.AudioSystem:PlayCriticalHitSound()
            else
                _G.AudioSystem:PlayHitSuccessSound() -- Random hit success sound
            end
        end
        
        -- Send damage request to server
        RemoteEvents.ApplyDamage:FireServer(target, weaponName, finalDamage)
        print("  - Sent damage request to server")
    else
        print("  - Swinging", weaponName, "in the air")
        
        -- Play swing miss sound when no target is hit
        if _G.AudioSystem then
            _G.AudioSystem:PlaySwingMissSound()
        end
    end
end)

-- Set default action for tools without specific actions
toolRegistry:SetDefaultAction(function(player, itemDef, target, actionData)
    local displayMessage = actionData and actionData.displayMessage or "Generic tool use"
    
    print("⚡ Tool Action!", displayMessage)
    
    if target then
        print("  - Using", itemDef.name, "on", target:GetFullName())
    else
        print("  - Using", itemDef.name, "in general")
    end
end)

function ToolSystem:Initialize()
    SystemManager.RegisterSystem("ToolSystem", self)
    print("Tool system initialized with", toolRegistry:GetActionCount(), "tool actions")
end

function ToolSystem:Use(itemDef, player, target, attackType)
    attackType = attackType or "normal" -- Default to normal attack
    print("ToolSystem: Use called for", itemDef.name, "- Attack Type:", attackType)
    
    local actionType = itemDef.actionType or ActionConstants.Tool.DEFAULT
    local actionData = itemDef.actionData or {}
    
    print("  - Action Type:", actionType)
    print("  - Action Data:", actionData)
    
    if target then
        print("  - Target:", target:GetFullName())
    else
        print("  - No target was hit.")
    end
    
    -- Execute using shared registry (this will trigger the animation)
    toolRegistry:ExecuteAction(actionType, player, itemDef, target, actionData, attackType)
end

-- Legacy methods for backward compatibility
function ToolSystem:ExecuteAction(actionName, player, itemDef, target, actionData)
    return toolRegistry:ExecuteAction(actionName, player, itemDef, target, actionData)
end

function ToolSystem:RegisterAction(actionName, actionFunction)
    return toolRegistry:RegisterAction(actionName, actionFunction)
end

function ToolSystem:GetRegisteredActions()
    return toolRegistry:GetRegisteredActions()
end

return ToolSystem ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="126">
          <Properties>
            <string name="Name">TraderUI</string>
            <string name="Source"><![CDATA[-- TraderUI.luau
-- Handles client-side trader shop interface

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local TraderData = require(ReplicatedStorage.Shared.TraderData)

local TraderUI = {}

-- Track UI state
TraderUI.isShopOpen = false
TraderUI.currentShopGui = nil
TraderUI.currentConfig = nil
TraderUI.ItemDetailUI = nil -- Will be set from init.client.luau
TraderUI.modalButton = nil -- Track modal button for cursor management

-- Create the main trader shop window
function TraderUI:CreateShopWindow(traderData)
	local config = traderData.config
	
	-- Create ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "TraderShopGui"
	screenGui.ResetOnSpawn = false
	screenGui.IgnoreGuiInset = true
	screenGui.Parent = player.PlayerGui
	
	-- Main shop frame
	local shopFrame = Instance.new("Frame")
	shopFrame.Name = "ShopFrame"
	shopFrame.Size = config.shopWindowSize
	shopFrame.Position = config.shopWindowPosition
	shopFrame.BackgroundColor3 = config.backgroundColor
	shopFrame.BorderSizePixel = 0
	shopFrame.Parent = screenGui
	
	-- Corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = shopFrame
	
	-- Header frame
	local headerFrame = Instance.new("Frame")
	headerFrame.Name = "HeaderFrame"
	headerFrame.Size = UDim2.new(1, 0, 0, 50)
	headerFrame.Position = UDim2.new(0, 0, 0, 0)
	headerFrame.BackgroundColor3 = config.frameColor
	headerFrame.BorderSizePixel = 0
	headerFrame.Parent = shopFrame
	
	-- Header corner
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 12)
	headerCorner.Parent = headerFrame
	
	-- Title label
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, -60, 1, 0)
	titleLabel.Position = UDim2.new(0, 10, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "Trader's Wares"
	titleLabel.TextColor3 = config.textColor
	titleLabel.TextSize = 24
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = headerFrame
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -45, 0, 5)
	closeButton.BackgroundColor3 = Color3.new(0.8, 0.2, 0.2)
	closeButton.BorderSizePixel = 0
	closeButton.Text = "×"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextSize = 24
	closeButton.Font = Enum.Font.GothamBold
	closeButton.ZIndex = 10  -- Ensure button is on top
	closeButton.Parent = headerFrame
	
	-- Close button corner
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeButton
	
	-- Close button hover effects
	closeButton.MouseEnter:Connect(function()
		closeButton.BackgroundColor3 = Color3.new(1, 0.3, 0.3)
	end)
	
	closeButton.MouseLeave:Connect(function()
		closeButton.BackgroundColor3 = Color3.new(0.8, 0.2, 0.2)
	end)
	
	-- Close button click
	closeButton.MouseButton1Click:Connect(function()
		print("Close button clicked!")
		self:CloseShop()
	end)
	
	-- Scrolling frame for items
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemScrollFrame"
	scrollFrame.Size = UDim2.new(1, -20, 1, -70)
	scrollFrame.Position = UDim2.new(0, 10, 0, 60)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 8
	scrollFrame.ScrollBarImageColor3 = config.accentColor
	scrollFrame.Parent = shopFrame
	
	-- Grid layout for items
	local gridLayout = Instance.new("UIGridLayout")
	gridLayout.CellSize = config.itemSlotSize
	gridLayout.CellPadding = UDim2.new(0, config.gridPadding, 0, config.gridPadding)
	gridLayout.FillDirectionMaxCells = config.itemsPerRow
	gridLayout.FillDirection = Enum.FillDirection.Horizontal
	gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	gridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	gridLayout.Parent = scrollFrame
	
	-- Padding for scroll frame
	local scrollPadding = Instance.new("UIPadding")
	scrollPadding.PaddingTop = UDim.new(0, 10)
	scrollPadding.PaddingBottom = UDim.new(0, 10)
	scrollPadding.PaddingLeft = UDim.new(0, 10)
	scrollPadding.PaddingRight = UDim.new(0, 10)
	scrollPadding.Parent = scrollFrame
	
	return screenGui, scrollFrame
end

-- Create an item slot
function TraderUI:CreateItemSlot(itemData, config, parent, layoutOrder)
	local itemFrame = Instance.new("Frame")
	itemFrame.Name = "ItemSlot_" .. itemData.id
	itemFrame.Size = config.itemSlotSize
	itemFrame.BackgroundColor3 = config.frameColor
	itemFrame.BorderSizePixel = 0
	itemFrame.LayoutOrder = layoutOrder
	itemFrame.Parent = parent
	
	-- Corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = itemFrame
	
	-- Rarity border
	local rarityBorder = Instance.new("Frame")
	rarityBorder.Name = "RarityBorder"
	rarityBorder.Size = UDim2.new(1, 4, 1, 4)
	rarityBorder.Position = UDim2.new(0, -2, 0, -2)
	rarityBorder.BackgroundColor3 = config.rarityColors[itemData.data.rarity] or config.rarityColors.common
	rarityBorder.BorderSizePixel = 0
	rarityBorder.ZIndex = itemFrame.ZIndex - 1
	rarityBorder.Parent = itemFrame
	
	-- Rarity border corner
	local rarityCorner = Instance.new("UICorner")
	rarityCorner.CornerRadius = UDim.new(0, 10)
	rarityCorner.Parent = rarityBorder
	
	-- Item icon (placeholder)
	local iconFrame = Instance.new("Frame")
	iconFrame.Name = "IconFrame"
	iconFrame.Size = UDim2.new(1, -20, 1, -40)
	iconFrame.Position = UDim2.new(0, 10, 0, 10)
	iconFrame.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
	iconFrame.BorderSizePixel = 0
	iconFrame.Parent = itemFrame
	
	-- Icon corner
	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(0, 6)
	iconCorner.Parent = iconFrame
	
	-- Icon label (placeholder for actual icon)
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Name = "IconLabel"
	iconLabel.Size = UDim2.new(1, 0, 1, 0)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = "?"
	iconLabel.TextColor3 = config.textColor
	iconLabel.TextSize = 32
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.Parent = iconFrame
	
	-- Item name label
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, -10, 0, 25)
	nameLabel.Position = UDim2.new(0, 5, 1, -30)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = itemData.data.name
	nameLabel.TextColor3 = config.textColor
	nameLabel.TextSize = 12
	nameLabel.TextScaled = true
	nameLabel.TextWrapped = true
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.Parent = itemFrame
	
	-- Click detection
	local clickButton = Instance.new("TextButton")
	clickButton.Name = "ClickButton"
	clickButton.Size = UDim2.new(1, 0, 1, 0)
	clickButton.BackgroundTransparency = 1
	clickButton.Text = ""
	clickButton.Parent = itemFrame
	
	-- Hover effects
	clickButton.MouseEnter:Connect(function()
		itemFrame.BackgroundColor3 = Color3.new(0.25, 0.25, 0.25)
		-- Tween scale up slightly
		local tween = TweenService:Create(itemFrame, TweenInfo.new(0.2), {Size = UDim2.new(1.05, 0, 1.05, 0)})
		tween:Play()
	end)
	
	clickButton.MouseLeave:Connect(function()
		itemFrame.BackgroundColor3 = config.frameColor
		-- Tween scale back to normal
		local tween = TweenService:Create(itemFrame, TweenInfo.new(0.2), {Size = config.itemSlotSize})
		tween:Play()
	end)
	
	-- Click handling
	clickButton.MouseButton1Click:Connect(function()
		if self.ItemDetailUI then
			self.ItemDetailUI:ShowItemDetail(itemData.id, itemData.data)
		end
	end)
	
	return itemFrame
end

-- Create modal button for cursor management (exactly like DialogueUI)
function TraderUI:CreateModalButton()
	if self.modalButton then
		return -- Already exists
	end
	
	if not self.currentShopGui then
		return -- No shop UI active
	end
	
	-- Create invisible modal button to keep cursor unlocked
	local modalButton = Instance.new("TextButton")
	modalButton.Name = "TraderModalButton"
	modalButton.Size = UDim2.new(1, 0, 1, 0)
	modalButton.Position = UDim2.new(0, 0, 0, 0)
	modalButton.BackgroundTransparency = 1
	modalButton.Text = ""
	modalButton.Modal = true -- This keeps the cursor unlocked
	modalButton.ZIndex = -1 -- Behind other UI elements
	modalButton.Parent = self.currentShopGui
	
	self.modalButton = modalButton
end

-- Remove modal button
function TraderUI:RemoveModalButton()
	if self.modalButton then
		self.modalButton:Destroy()
		self.modalButton = nil
	end
end

-- Open the trader shop
function TraderUI:OpenShop(traderData)
	if self.isShopOpen then
		print("Shop already open, ignoring request")
		return
	end
	
	print("Opening trader shop with data:", traderData)
	print("Items count:", traderData.items and #traderData.items or "nil")
	
	self.isShopOpen = true
	self.currentConfig = traderData.config
	
	-- Create shop window
	local shopGui, scrollFrame = self:CreateShopWindow(traderData)
	self.currentShopGui = shopGui
	
	-- Create modal button to keep cursor unlocked
	self:CreateModalButton()
	
	-- Use small delay to ensure dialogue cleanup is processed first, then set cursor
	task.spawn(function()
		task.wait(0.1) -- Small delay to ensure dialogue EndDialogue has processed
		
		-- Unlock cursor and hide crosshair when shop opens
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
		
		print("[TRADER DEBUG] Set MouseBehavior to Default and MouseIconEnabled to true")
	end)
	
	-- Hide crosshair when shop is open
	if _G.CameraSystem then
		_G.CameraSystem:HideCrosshair()
	end

	-- Create item slots
	if traderData.items then
		for i, itemData in ipairs(traderData.items) do
			print("Creating item slot for:", itemData.id, itemData.data.name)
			self:CreateItemSlot(itemData, traderData.config, scrollFrame, i)
		end
	else
		print("ERROR: No items data received!")
	end
	
	-- Update scroll frame canvas size
	local gridLayout = scrollFrame:FindFirstChild("UIGridLayout")
	if gridLayout then
		gridLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
			scrollFrame.CanvasSize = UDim2.new(0, 0, 0, gridLayout.AbsoluteContentSize.Y + 20)
		end)
		-- Initial canvas size update
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, gridLayout.AbsoluteContentSize.Y + 20)
	end
	
	print("Trader shop opened with", traderData.items and #traderData.items or 0, "items")
end

-- Close the trader shop
function TraderUI:CloseShop()
	print("CloseShop called, isShopOpen:", self.isShopOpen)
	
	if not self.isShopOpen then
		print("Shop not open, ignoring close request")
		return
	end
	
	self.isShopOpen = false
	
	-- Remove modal button
	self:RemoveModalButton()

	-- Close item detail if open (force cleanup to prevent glitches)
	if self.ItemDetailUI then
		print("Force cleaning up item detail UI")
		self.ItemDetailUI:ForceCleanup()
	end
	
	-- Remove shop GUI
	if self.currentShopGui then
		print("Destroying shop GUI")
		self.currentShopGui:Destroy()
		self.currentShopGui = nil
	else
		print("No shop GUI to destroy")
	end
	

	
	-- Restore cursor lock and show crosshair when shop closes
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseIconEnabled = false
	
	-- Show crosshair when shop is closed
	if _G.CameraSystem then
		_G.CameraSystem:ShowCrosshair()
	end
	
	-- Notify server
	print("Notifying server of shop close")
	RemoteEvents.CloseTraderShop:FireServer()
	
	print("Trader shop closed")
end

-- Initialize the trader UI
function TraderUI:Initialize(itemDetailUI)
	-- Set up global reference for other systems
	_G.TraderUI = self
	
	self.ItemDetailUI = itemDetailUI
	
	-- Set up RemoteEvent connections
	RemoteEvents.OpenTraderShop.OnClientEvent:Connect(function(traderData)
		self:OpenShop(traderData)
	end)
	
	RemoteEvents.CloseTraderShop.OnClientEvent:Connect(function()
		self:CloseShop()
	end)
	
	print("TraderUI initialized")
end

return TraderUI ]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="127">
          <Properties>
            <string name="Name">UI</string>
          </Properties>
          <Item class="ModuleScript" referent="128">
            <Properties>
              <string name="Name">ArmorMenu</string>
              <string name="Source"><![CDATA[-- Armor menu UI component
local ArmorMenu = {}

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local StatsPanel = require(script.Parent.StatsPanel)

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Configuration
local SLOT_SIZE = 80  -- Larger than hotbar slots
local SLOT_SPACING = 10
local MENU_PADDING = 20

-- Armor slot configuration
local ARMOR_SLOTS = {
    {name = "Helmet", slot = "helmet", icon = "⛑️"},
    {name = "Chestplate", slot = "chestplate", icon = "🦺"},
    {name = "Boots", slot = "boots", icon = "🥾"}
}

-- UI Elements
local screenGui = nil
local titleLabel = nil
local modalButton = nil -- For freeing cursor in first person
local slots = {}
local isVisible = false

local statsPanel = nil

local daysSurvived = 1
local playtime = 0

local statsUpdateLoopActive = false

local ARMOR_SLOT_ANIM_TIME = 0.35
local ARMOR_SLOT_ANIM_TIME_OUT = 0.18
local ARMOR_SLOT_Y_HIDDEN = -200
local ARMOR_SLOT_Y_VISIBLE = 0
local DECAL_Y_HIDDEN = -300
local DECAL_Y_VISIBLE = 0
local armorSlotTweens = {}
local decalTween = nil

-- Add a container for slots and decal
local slotsContainer = nil
local SLOTS_CONTAINER_ANIM_TIME = 0.35
local SLOTS_CONTAINER_ANIM_TIME_OUT = 0.12 -- Faster hide
local SLOTS_CONTAINER_Y_HIDDEN = -300
local SLOTS_CONTAINER_Y_VISIBLE = 0
local SLOTS_CONTAINER_Y_SCALE = 0.3
local SLOTS_CONTAINER_Y_OFFSET_VISIBLE = nil -- set in CreateArmorMenuUI
local SLOTS_CONTAINER_Y_OFFSET_HIDDEN = nil -- set in CreateArmorMenuUI
local slotsContainerTween = nil

-- Store original Y offsets for slots and decal
local slotOriginalYs = {}
local decalOriginalY = nil

local function startStatsUpdateLoop()
	if statsUpdateLoopActive then return end
	statsUpdateLoopActive = true
	task.spawn(function()
		while statsUpdateLoopActive do
			RemoteEvents.StatsUpdate:FireServer()
			task.wait(1)
		end
	end)
end

local function stopStatsUpdateLoop()
	statsUpdateLoopActive = false
end

local function formatPlaytime(seconds)
	local mins = math.floor(seconds / 60)
	local secs = math.floor(seconds % 60)
	return string.format("%02d:%02d", mins, secs)
end

RemoteEvents.StatsUpdate.OnClientEvent:Connect(function(serverDaysSurvived, serverPlaytime)
	if statsPanel then
		statsPanel:SetStats(serverDaysSurvived, serverPlaytime)
	end
end)

function ArmorMenu:Initialize()
    self:CreateArmorMenuUI()
    print("Armor menu UI initialized with", #ARMOR_SLOTS, "slots")
end

function ArmorMenu:CreateArmorMenuUI()
    -- Create screen GUI
    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ArmorMenuUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = playerGui
    
    -- Calculate menu dimensions
    local menuWidth = (SLOT_SIZE * #ARMOR_SLOTS) + (SLOT_SPACING * (#ARMOR_SLOTS - 1)) + (MENU_PADDING * 2)
    local menuHeight = SLOT_SIZE + 40 + (MENU_PADDING * 2) -- Extra height for title
    self.menuHeight = menuHeight
    SLOTS_CONTAINER_Y_OFFSET_VISIBLE = -menuHeight * 1.5 + 40
    SLOTS_CONTAINER_Y_OFFSET_HIDDEN = SLOTS_CONTAINER_Y_OFFSET_VISIBLE - 300

    -- Remove armorFrame entirely
    -- Title label parented to screenGui
    -- Remove the title label creation
    -- (do not create titleLabel)
    
    -- Create container for slots and decal
    slotsContainer = Instance.new("Frame")
    slotsContainer.Name = "SlotsContainer"
    slotsContainer.Size = UDim2.new(1, 0, 1, 0)
    slotsContainer.Position = UDim2.new(0, 0, SLOTS_CONTAINER_Y_SCALE, SLOTS_CONTAINER_Y_OFFSET_VISIBLE)
    slotsContainer.BackgroundTransparency = 1
    slotsContainer.Parent = screenGui
    self.slotsContainer = slotsContainer

    -- Create armor slots parented to slotsContainer
    for i, armorSlot in ipairs(ARMOR_SLOTS) do
        self:CreateArmorSlot(i, armorSlot, menuWidth, menuHeight, slotsContainer)
    end
    
    -- Modal button for cursor management remains parented to screenGui
    modalButton = Instance.new("TextButton")
    modalButton.Name = "ModalButton"
    modalButton.Size = UDim2.new(1, 0, 1, 0) -- Full screen
    modalButton.Position = UDim2.new(0, 0, 0, 0)
    modalButton.BackgroundTransparency = 1 -- Invisible
    modalButton.Text = "" -- No text
    modalButton.Modal = true -- This is the key property that frees the cursor
    modalButton.Active = false -- Don't interfere with camera controls
    modalButton.Selectable = false -- Don't interfere with console
    modalButton.ZIndex = -1 -- Behind everything else
    modalButton.Visible = false -- Initially hidden
    modalButton.Parent = screenGui

    -- Add centered background decal behind slots, parented to slotsContainer
    local decalImage = Instance.new("ImageLabel")
    decalImage.Name = "ArmorMenuDecal"
    decalImage.Image = "rbxassetid://99343688701653"
    decalImage.BackgroundTransparency = 1
    decalImage.SizeConstraint = Enum.SizeConstraint.RelativeYY
    decalImage.Size = UDim2.new(0, menuHeight * 3, 0, menuHeight * 3)
    decalImage.Position = UDim2.new(0.5, -menuHeight * 1.5, 0.3, -menuHeight * 1.5 + 40)
    decalImage.Visible = false
    decalImage.ZIndex = 0
    decalImage.Parent = slotsContainer
    self.decalImage = decalImage
    decalOriginalY = -menuHeight * 1.5 + 40

    -- Add stats panel (modular)
    statsPanel = StatsPanel.new(screenGui)
    self.statsPanel = statsPanel

    -- Create darken overlay (behind blur, ZIndex 1)
    -- darkenOverlay = Instance.new("Frame")
    -- darkenOverlay.Name = "DarkenOverlay"
    -- darkenOverlay.Size = UDim2.new(1, 0, 1, 0)
    -- darkenOverlay.Position = UDim2.new(0, 0, 0, 0)
    -- darkenOverlay.BackgroundColor3 = Color3.new(0, 0, 0)
    -- darkenOverlay.BackgroundTransparency = 1
    -- darkenOverlay.ZIndex = 1
    -- darkenOverlay.Visible = false
    -- darkenOverlay.Parent = screenGui
    -- self.darkenOverlay = darkenOverlay
end

function ArmorMenu:CreateArmorSlot(slotIndex, armorSlotData, menuWidth, menuHeight, parent)
    -- Stack slots vertically, centered horizontally
    local totalSlots = #ARMOR_SLOTS
    local totalHeight = (SLOT_SIZE * totalSlots) + (SLOT_SPACING * (totalSlots - 1))
    local yOffset = ((slotIndex - 1) * (SLOT_SIZE + SLOT_SPACING)) - (totalHeight // 2)
    -- Move headgear up and boots down
    if armorSlotData.slot == "helmet" then
        yOffset = yOffset - 40
    elseif armorSlotData.slot == "boots" then
        yOffset = yOffset + 110
    end
    local xOffset = 0 -- Centered
    -- Slot frame parented to slotsContainer
    local slotFrame = Instance.new("Frame")
    slotFrame.Name = "ArmorSlot" .. armorSlotData.slot
    slotFrame:SetAttribute("ArmorSlotType", armorSlotData.slot)
    slotFrame.Size = UDim2.new(0, SLOT_SIZE, 0, SLOT_SIZE)
    slotFrame.Position = UDim2.new(0.5, -SLOT_SIZE/2, 0.3, yOffset)
    slotFrame.BackgroundTransparency = 1
    slotFrame.BorderSizePixel = 0
    slotFrame.Visible = false
    slotFrame.Parent = parent or screenGui
    -- Add hotbar slot image as background
    local slotImage = Instance.new("ImageLabel")
    slotImage.Name = "SlotImage"
    slotImage.Size = UDim2.new(1, 0, 1, 0)
    slotImage.Position = UDim2.new(0, 0, 0, 0)
    slotImage.BackgroundTransparency = 1
    slotImage.Image = "rbxassetid://71503412974519"
    slotImage.Parent = slotFrame
    -- Remove slot outline (no UIStroke)
    
    -- Remove slot corner rounding (no UICorner)
    
    -- Default slot icon (when empty) - remove emoji
    local defaultIcon = Instance.new("TextLabel")
    defaultIcon.Name = "DefaultIcon"
    defaultIcon.Size = UDim2.new(1, 0, 0.6, 0)
    defaultIcon.Position = UDim2.new(0, 0, 0, 0)
    defaultIcon.BackgroundTransparency = 1
    defaultIcon.Text = ""
    defaultIcon.TextColor3 = Color3.fromRGB(120, 120, 120)
    defaultIcon.TextSize = 20 -- Bigger font for icon
    defaultIcon.Font = Enum.Font.Gotham
    defaultIcon.TextXAlignment = Enum.TextXAlignment.Center
    defaultIcon.TextYAlignment = Enum.TextYAlignment.Center
    defaultIcon.Parent = slotFrame
    
    -- Item display (when equipped)
    local itemDisplay = Instance.new("TextLabel")
    itemDisplay.Name = "ItemDisplay"
    itemDisplay.Size = UDim2.new(1, -4, 0.6, 0)
    itemDisplay.Position = UDim2.new(0, 2, 0, 0)
    itemDisplay.BackgroundTransparency = 1
    itemDisplay.Text = ""
    itemDisplay.TextColor3 = Color3.fromRGB(255, 255, 255)
    itemDisplay.TextSize = 18 -- Bigger font for item name
    itemDisplay.Font = Enum.Font.Gotham
    itemDisplay.TextScaled = true
    itemDisplay.TextWrapped = true
    itemDisplay.TextXAlignment = Enum.TextXAlignment.Center
    itemDisplay.TextYAlignment = Enum.TextYAlignment.Center
    itemDisplay.Visible = false
    itemDisplay.Parent = slotFrame
    
    -- Slot label - change helmet to 'Headgear', chestplate to 'Body Armor'
    local slotLabel = Instance.new("TextLabel")
    slotLabel.Name = "SlotLabel"
    slotLabel.Size = UDim2.new(1, 0, 0.4, 0)
    slotLabel.Position = UDim2.new(0, 0, 0.6, 0)
    slotLabel.BackgroundTransparency = 1
    slotLabel.Text = armorSlotData.name
    slotLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    slotLabel.TextSize = 16 -- Bigger font for slot label
    slotLabel.Font = Enum.Font.Gotham
    slotLabel.TextXAlignment = Enum.TextXAlignment.Center
    slotLabel.TextYAlignment = Enum.TextYAlignment.Center
    slotLabel.TextWrapped = true
    -- Put long words on a new line if needed
    if armorSlotData.slot == "chestplate" then
        slotLabel.Text = "Body\nArmor"
    elseif armorSlotData.slot == "helmet" then
        slotLabel.Text = "Head\nGear"
    else
        slotLabel.Text = armorSlotData.name
    end
    slotLabel.Parent = slotFrame
    
    -- Make slot clickable
    local clickDetector = Instance.new("TextButton")
    clickDetector.Name = "ClickDetector"
    clickDetector.Size = UDim2.new(1, 0, 1, 0)
    clickDetector.Position = UDim2.new(0, 0, 0, 0)
    clickDetector.BackgroundTransparency = 1
    clickDetector.Text = ""
    clickDetector:SetAttribute("ArmorSlotType", armorSlotData.slot)
    clickDetector.Parent = slotFrame
    
    -- Add UIStroke for outline/highlight (hidden by default)
    local slotStroke = Instance.new("UIStroke")
    slotStroke.Color = Color3.fromRGB(220, 220, 220)
    slotStroke.Thickness = 0 -- Hidden by default
    slotStroke.Parent = slotFrame

    -- Add overlay for hover effect (default hidden)
    local overlay = Instance.new("Frame")
    overlay.Name = "Overlay"
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.Position = UDim2.new(0, 0, 0, 0)
    overlay.BackgroundColor3 = Color3.new(1, 1, 1)
    overlay.BackgroundTransparency = 1
    overlay.BorderSizePixel = 0
    overlay.ZIndex = 3
    overlay.Parent = slotFrame
    
    -- Store slot reference
    slots[armorSlotData.slot] = {
        frame = slotFrame,
        defaultIcon = defaultIcon,
        itemDisplay = itemDisplay,
        stroke = slotStroke, -- Store the stroke
        overlay = overlay,   -- Store the overlay
        clickDetector = clickDetector,
        isEmpty = true,
        slotType = armorSlotData.slot
    }
    
    -- Connect click event (will be handled by ArmorSystem)
    clickDetector.MouseButton1Click:Connect(function()
        -- Signal to ArmorSystem that this slot was clicked
        if _G.ArmorSystem then
            _G.ArmorSystem:HandleSlotClick(armorSlotData.slot)
        end
    end)
    -- Hover highlight logic (match hotbar)
    clickDetector.MouseEnter:Connect(function()
        slotStroke.Color = Color3.fromRGB(220, 220, 220)
        slotStroke.Thickness = 2
        overlay.BackgroundTransparency = 0.93
    end)
    clickDetector.MouseLeave:Connect(function()
        slotStroke.Thickness = 0
        overlay.BackgroundTransparency = 1
    end)
    -- Store original Y offset for animation
    slotOriginalYs[slotFrame] = yOffset
end

function ArmorMenu:Show()
    print("[ARMOR MENU DEBUG] --- Show START ---")
    print("[ARMOR MENU DEBUG] Current visibility state:", isVisible)
    
    if not isVisible then
        print("[ARMOR MENU DEBUG] Showing armor menu")
        -- Animate slotsContainer (decal and slots move together)
        if self.slotsContainer then
            self.slotsContainer.Visible = true
            self.slotsContainer.Position = UDim2.new(0, 0, SLOTS_CONTAINER_Y_SCALE, SLOTS_CONTAINER_Y_OFFSET_HIDDEN)
            if slotsContainerTween then slotsContainerTween:Cancel() end
            slotsContainerTween = TweenService:Create(self.slotsContainer, TweenInfo.new(SLOTS_CONTAINER_ANIM_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.new(0, 0, SLOTS_CONTAINER_Y_SCALE, SLOTS_CONTAINER_Y_OFFSET_VISIBLE)})
            slotsContainerTween:Play()
        end
        -- Show all slot frames and decal
        for _, slot in pairs(slots) do
            if slot.frame then slot.frame.Visible = true end
        end
        if self.decalImage then self.decalImage.Visible = true end
        modalButton.Visible = true -- Show modal button to free cursor
        isVisible = true
        
        print("[ARMOR MENU DEBUG] Frame and modal button made visible")
        
        -- Enable mouse cursor (this works with the modal button)
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        UserInputService.MouseIconEnabled = true
        
        print("[ARMOR MENU DEBUG] Mouse behavior set to Default, cursor enabled")
        
        -- Hide crosshair when armor menu is open
        if _G.CameraSystem then
            print("[ARMOR MENU DEBUG] Hiding crosshair via CameraSystem")
            _G.CameraSystem:HideCrosshair()
        else
            print("[ARMOR MENU DEBUG] WARNING: CameraSystem not found")
        end
        
        -- Camera zoom in
        if _G.CameraSystem and _G.CameraSystem.ZoomIn then
            _G.CameraSystem:ZoomIn()
        end
        
        print("[ARMOR MENU DEBUG] SUCCESS: Armor menu shown")
        if self.statsPanel then
            self.statsPanel:Show()
        end
        -- Request stats from server and start update loop
        RemoteEvents.StatsUpdate:FireServer()
        startStatsUpdateLoop()

        -- Show and tween in darken overlay
        -- if self.darkenOverlay then
        --     self.darkenOverlay.Visible = true
        --     if darkenTween then darkenTween:Cancel() end
        --     darkenTween = TweenService:Create(self.darkenOverlay, TweenInfo.new(DARKEN_TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = DARKEN_TARGET_TRANSPARENCY})
        --     darkenTween:Play()
        -- end
    else
        print("[ARMOR MENU DEBUG] Menu already visible, no action needed")
    end
    
    print("[ARMOR MENU DEBUG] --- Show END ---")
end

function ArmorMenu:Hide()
    if isVisible then
        if self.slotsContainer then
            if slotsContainerTween then slotsContainerTween:Cancel() end
            slotsContainerTween = TweenService:Create(self.slotsContainer, TweenInfo.new(SLOTS_CONTAINER_ANIM_TIME_OUT, Enum.EasingStyle.Back, Enum.EasingDirection.In), {Position = UDim2.new(0, 0, SLOTS_CONTAINER_Y_SCALE, SLOTS_CONTAINER_Y_OFFSET_HIDDEN)})
            slotsContainerTween:Play()
            task.delay(SLOTS_CONTAINER_ANIM_TIME_OUT, function()
                self.slotsContainer.Visible = false
            end)
        end
        -- Hide all slot frames and decal after animation
        task.delay(SLOTS_CONTAINER_ANIM_TIME_OUT, function()
            for _, slot in pairs(slots) do
                if slot.frame then slot.frame.Visible = false end
            end
            if self.decalImage then self.decalImage.Visible = false end
        end)
        modalButton.Visible = false -- Hide modal button to restore cursor lock
        isVisible = false
        -- Restore mouse behavior (let other systems handle it)
        UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
        UserInputService.MouseIconEnabled = false
        -- Show crosshair when armor menu is closed
        if _G.CameraSystem then
            _G.CameraSystem:ShowCrosshair()
        end
        -- Camera zoom out
        if _G.CameraSystem and _G.CameraSystem.ZoomOut then
            _G.CameraSystem:ZoomOut()
        end
        print("Armor menu hidden")
        if self.statsPanel then
            self.statsPanel:Hide()
        end
        stopStatsUpdateLoop()

        -- Tween out and hide darken overlay
        -- if self.darkenOverlay then
        --     if darkenTween then darkenTween:Cancel() end
        --     darkenTween = TweenService:Create(self.darkenOverlay, TweenInfo.new(DARKEN_TWEEN_TIME_OUT, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 1})
        --     darkenTween:Play()
        --     task.delay(DARKEN_TWEEN_TIME_OUT, function()
        --         self.darkenOverlay.Visible = false
        --     end)
        -- end
    end
end

function ArmorMenu:Toggle()
    print("[ARMOR MENU DEBUG] --- Toggle START ---")
    print("[ARMOR MENU DEBUG] Current visibility state:", isVisible)
    
    if isVisible then
        print("[ARMOR MENU DEBUG] Menu is visible - hiding")
        self:Hide()
    else
        print("[ARMOR MENU DEBUG] Menu is hidden - showing")
        self:Show()
    end
    
    print("[ARMOR MENU DEBUG] --- Toggle END ---")
end

function ArmorMenu:UpdateDisplay(armorInventory)
    -- Update all armor slots
    for slotType, slot in pairs(slots) do
        local armorItem = armorInventory[slotType]
        
        if armorItem then
            -- Slot has armor equipped
            slot.defaultIcon.Visible = false
            slot.itemDisplay.Visible = true
            slot.itemDisplay.Text = armorItem.itemName or "Unknown"
            slot.stroke.Color = Color3.fromRGB(100, 255, 100) -- Green for equipped
            slot.isEmpty = false
        else
            -- Slot is empty
            slot.defaultIcon.Visible = true
            slot.itemDisplay.Visible = false
            slot.stroke.Color = Color3.fromRGB(80, 80, 80) -- Default gray
            slot.isEmpty = true
        end
    end
end

function ArmorMenu:IsVisible()
    return isVisible
end

return ArmorMenu ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="129">
            <Properties>
              <string name="Name">Clock</string>
              <string name="Source"><![CDATA[local ClockUI = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ClockUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

local clockLabel = Instance.new("TextLabel")
clockLabel.Name = "ClockLabel"
clockLabel.Size = UDim2.new(0, 180, 0, 40)
clockLabel.Position = UDim2.new(1, -200, 0, 20) -- Top right
clockLabel.BackgroundTransparency = 0.3
clockLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
clockLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
clockLabel.TextStrokeTransparency = 0.5
clockLabel.TextSize = 28
clockLabel.Font = Enum.Font.GothamBold
clockLabel.Text = "00:00"
clockLabel.Parent = screenGui

local function formatClockTime(clockTime)
	local hour = math.floor(clockTime)
	local minute = math.floor((clockTime - hour) * 60)
	return string.format("%02d:%02d", hour, minute)
end

RemoteEvents.ClockUpdate.OnClientEvent:Connect(function(clockTime)
	clockLabel.Text = formatClockTime(clockTime)
end)

function ClockUI:Initialize()
	-- Nothing needed, UI is set up on require
end

return ClockUI ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="130">
            <Properties>
              <string name="Name">HealthBar</string>
              <string name="Source"><![CDATA[local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local Healthbar = {}

local screenGui = nil
local barFrame = nil
local healthFill = nil
local healthLabel = nil

local BAR_WIDTH = 240
local BAR_HEIGHT = 28
local BAR_MARGIN = 24

function Healthbar:Initialize()
    -- Create ScreenGui
    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "HealthbarUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = playerGui

    -- Create bar background
    barFrame = Instance.new("Frame")
    barFrame.Name = "HealthBarFrame"
    barFrame.Size = UDim2.new(0, BAR_WIDTH, 0, BAR_HEIGHT)
    barFrame.Position = UDim2.new(0, BAR_MARGIN, 1, -(BAR_HEIGHT + BAR_MARGIN))
    barFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    barFrame.BorderSizePixel = 0
    barFrame.BackgroundTransparency = 0.15
    barFrame.Parent = screenGui

    -- Create health fill
    healthFill = Instance.new("Frame")
    healthFill.Name = "HealthFill"
    healthFill.Size = UDim2.new(1, 0, 1, 0)
    healthFill.Position = UDim2.new(0, 0, 0, 0)
    healthFill.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
    healthFill.BorderSizePixel = 0
    healthFill.BackgroundTransparency = 0.05
    healthFill.Parent = barFrame

    -- Mask fill with UI corner
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = barFrame
    local fillCorner = Instance.new("UICorner")
    fillCorner.CornerRadius = UDim.new(0, 8)
    fillCorner.Parent = healthFill

    -- Health label
    healthLabel = Instance.new("TextLabel")
    healthLabel.Name = "HealthLabel"
    healthLabel.Size = UDim2.new(1, 0, 1, 0)
    healthLabel.Position = UDim2.new(0, 0, 0, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    healthLabel.TextStrokeTransparency = 0.5
    healthLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    healthLabel.TextSize = 18
    healthLabel.Font = Enum.Font.GothamBold
    healthLabel.TextXAlignment = Enum.TextXAlignment.Center
    healthLabel.TextYAlignment = Enum.TextYAlignment.Center
    healthLabel.Parent = barFrame

    self:ConnectHealth()
end

function Healthbar:ConnectHealth()
    local function updateHealth()
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        local health = math.max(0, humanoid.Health)
        local maxHealth = math.max(1, humanoid.MaxHealth)
        local percent = health / maxHealth
        healthFill.Size = UDim2.new(percent, 0, 1, 0)
        healthLabel.Text = string.format("%d / %d", math.floor(health), math.floor(maxHealth))
    end

    local function onCharacterAdded(char)
        local humanoid = char:WaitForChild("Humanoid")
        humanoid.HealthChanged:Connect(updateHealth)
        humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(updateHealth)
        updateHealth()
    end

    if player.Character then
        onCharacterAdded(player.Character)
    end
    player.CharacterAdded:Connect(onCharacterAdded)
end

return Healthbar ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="131">
            <Properties>
              <string name="Name">Hotbar</string>
              <string name="Source"><![CDATA[-- Dynamic hotbar UI component
local Hotbar = {}

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Configuration (easily changeable)
local SLOT_COUNT = 10
local SLOT_SIZE = math.floor(50 * 1.3) -- 30% bigger
local SLOT_SPACING = 5
local HOTBAR_PADDING = 10

-- UI Elements
local screenGui = nil
local hotbarFrame = nil
local slots = {}

-- Drag and drop state
local dragState = {
    isDragging = false,
    draggedSlot = nil,
    dragPreview = nil,
    originalPosition = nil
}

-- Add at the top of the file:
local hoveredSlotIndex = nil

-- ENHANCED: Track all connections for cleanup
local globalConnections = {}

function Hotbar:Initialize()
    self:CreateHotbarUI()
    self:SetupDragAndDrop()
    -- Note: Number key inputs now handled by InventorySystem
    print("Hotbar UI initialized with", SLOT_COUNT, "slots")
end

function Hotbar:CreateHotbarUI()
    -- Create screen GUI
    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "HotbarUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = playerGui
    
    -- Add centered label above hotbar
    local hotbarWidth = (SLOT_SIZE * SLOT_COUNT) + (SLOT_SPACING * (SLOT_COUNT - 1)) + (HOTBAR_PADDING * 2)
    local label = Instance.new("TextLabel")
    label.Name = "HotbarHintLabel"
    label.Size = UDim2.new(0, hotbarWidth, 0, 22)
    label.Position = UDim2.new(0.5, -hotbarWidth/2, 1, -(SLOT_SIZE + HOTBAR_PADDING + 18))
    label.BackgroundTransparency = 1
    label.Text = "(G) to open the menu"
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextStrokeTransparency = 0.6
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.TextSize = 14
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.FontFace = Font.new("rbxasset://fonts/families/GothamSSm.json", Enum.FontWeight.SemiBold, Enum.FontStyle.Italic)
    label.Parent = screenGui
    
    -- Calculate hotbar dimensions
    local hotbarHeight = SLOT_SIZE + (HOTBAR_PADDING * 2)
    
    -- Remove hotbarFrame and its styling
    -- All slots will be parented directly to screenGui
    
    -- Create slots
    for i = 1, SLOT_COUNT do
        self:CreateSlot(i)
    end
end

function Hotbar:CreateSlot(slotNumber)
    local hotbarWidth = (SLOT_SIZE * SLOT_COUNT) + (SLOT_SPACING * (SLOT_COUNT - 1))
    local slotX = -hotbarWidth/2 + ((slotNumber - 1) * (SLOT_SIZE + SLOT_SPACING))
    
    -- Slot image background (replace Frame with ImageLabel)
    local slotImage = Instance.new("ImageLabel")
    slotImage.Name = "Slot" .. slotNumber
    slotImage.Size = UDim2.new(0, SLOT_SIZE, 0, SLOT_SIZE)
    slotImage.Position = UDim2.new(0.5, slotX, 1, -(SLOT_SIZE // 4 + 52)) -- Keep same vertical offset logic
    slotImage.BackgroundTransparency = 1
    slotImage.Image = "rbxassetid://71503412974519"
    slotImage.Parent = screenGui
    
    -- Slot border (for equipped/hovered indication)
    local slotStroke = Instance.new("UIStroke")
    slotStroke.Color = Color3.fromRGB(80, 80, 80)
    slotStroke.Thickness = 1
    slotStroke.Parent = slotImage
    
    -- Light overlay (for equipped/hovered effect)
    local overlay = Instance.new("Frame")
    overlay.Name = "Overlay"
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.Position = UDim2.new(0, 0, 0, 0)
    overlay.BackgroundColor3 = Color3.new(1, 1, 1)
    overlay.BackgroundTransparency = 1 -- Default hidden
    overlay.BorderSizePixel = 0
    overlay.ZIndex = 3
    overlay.Parent = slotImage
    
    -- Item name display (text label showing full item name)
    local itemIcon = Instance.new("TextLabel")
    itemIcon.Name = "ItemIcon"
    itemIcon.Size = UDim2.new(1, -4, 1, -14) -- Leave space for slot number
    itemIcon.Position = UDim2.new(0, 2, 0, 12) -- Position below slot number
    itemIcon.BackgroundTransparency = 1
    itemIcon.Text = ""
    itemIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
    itemIcon.TextSize = 12 -- Smaller font for item name
    itemIcon.Font = Enum.Font.Gotham
    itemIcon.TextScaled = true
    itemIcon.TextWrapped = true
    itemIcon.TextXAlignment = Enum.TextXAlignment.Center
    itemIcon.TextYAlignment = Enum.TextYAlignment.Center
    itemIcon.Parent = slotImage
    
    -- Slot number indicator
    local slotNumberLabel = Instance.new("TextLabel")
    slotNumberLabel.Name = "SlotNumber"
    slotNumberLabel.Size = UDim2.new(0, 12, 0, 12)
    slotNumberLabel.Position = UDim2.new(0, 2, 0, 2)
    slotNumberLabel.BackgroundTransparency = 1
    slotNumberLabel.Text = tostring(slotNumber == 10 and 0 or slotNumber) -- Show 0 for slot 10
    slotNumberLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    slotNumberLabel.TextSize = 14 -- Smaller font for slot number
    slotNumberLabel.Font = Enum.Font.Gotham
    slotNumberLabel.TextStrokeTransparency = 0
    slotNumberLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    slotNumberLabel.Parent = slotImage
    
    -- Drag detection button (invisible)
    local dragButton = Instance.new("TextButton")
    dragButton.Name = "DragButton"
    dragButton.Size = UDim2.new(1, 0, 1, 0)
    dragButton.Position = UDim2.new(0, 0, 0, 0)
    dragButton.BackgroundTransparency = 1
    dragButton.Text = ""
    dragButton.ZIndex = 4 -- Above overlay
    dragButton.Parent = slotImage
    
    -- Store slot reference
    slots[slotNumber] = {
        frame = slotImage,
        icon = itemIcon,
        stroke = slotStroke,
        dragButton = dragButton,
        overlay = overlay,
        slotNumber = slotNumber,
        isEmpty = true
    }
    
    -- Slot created successfully
end

function Hotbar:SetupDragAndDrop()
    -- Connect drag events for all slots
    for slotNumber, slot in pairs(slots) do
        self:ConnectSlotDragEvents(slot)
    end
end

function Hotbar:ConnectSlotDragEvents(slot)
    local dragButton = slot.dragButton
    
    -- Mouse button down - start potential drag
    dragButton.MouseButton1Down:Connect(function()
        local canDrag = self:CanDragSlots()
        
        if canDrag and not slot.isEmpty then
            self:StartDrag(slot)
        end
    end)
    
    -- Mouse enter - highlight as drop target
    dragButton.MouseEnter:Connect(function()
        if dragState.isDragging and dragState.draggedSlot ~= slot then
            self:HighlightDropTarget(slot, true)
        end
    end)
    
    -- Mouse leave - remove drop target highlight
    dragButton.MouseLeave:Connect(function()
        if dragState.isDragging and dragState.draggedSlot ~= slot then
            self:HighlightDropTarget(slot, false)
        end
    end)
    
    -- Mouse button up - complete drag
    dragButton.MouseButton1Up:Connect(function()
        if dragState.isDragging then
            self:CompleteDrag(slot)
        end
    end)
end

function Hotbar:CanDragSlots()
    -- Only allow dragging when armor menu is visible
    return _G.ArmorSystem and _G.ArmorSystem:IsArmorMenuVisible()
end

function Hotbar:StartDrag(slot)
    print("[HOTBAR DEBUG] --- StartDrag START ---")
    print("[HOTBAR DEBUG] Starting drag for slot:", slot.slotNumber)
    
    dragState.isDragging = true
    dragState.draggedSlot = slot
    dragState.originalPosition = slot.frame.Position
    
    print("[HOTBAR DEBUG] Drag state updated - isDragging:", dragState.isDragging)
    
    -- Create drag preview
    self:CreateDragPreview(slot)
    print("[HOTBAR DEBUG] Drag preview created")
    
    -- Highlight the dragged slot
    slot.stroke.Color = Color3.fromRGB(100, 150, 255) -- Blue for dragging
    slot.stroke.Thickness = 2
    print("[HOTBAR DEBUG] Slot highlighted for dragging")
    
    print("[HOTBAR DEBUG] SUCCESS: Started dragging slot", slot.slotNumber)
    print("[HOTBAR DEBUG] --- StartDrag END ---")
end

function Hotbar:CreateDragPreview(slot)
    -- Create a preview frame that follows the mouse
    dragState.dragPreview = slot.frame:Clone()
    dragState.dragPreview.Name = "DragPreview"
    dragState.dragPreview.ZIndex = 10 -- Above everything
    dragState.dragPreview.BackgroundTransparency = 0.5 -- Semi-transparent
    dragState.dragPreview.Parent = screenGui
    
    -- Get GuiService for window offset calculation
    local GuiService = game:GetService("GuiService")
    
    -- Update preview position with mouse movement
    local connection
    connection = UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragState.isDragging then
            -- Get screen coordinates and convert to game window coordinates
            local mousePos = UserInputService:GetMouseLocation()
            local guiInset = GuiService:GetGuiInset()
            
            -- Adjust for window offset (title bar, etc.)
            local gameWindowX = mousePos.X - guiInset.X
            local gameWindowY = mousePos.Y - guiInset.Y
            
            -- Position drag preview centered on cursor
            dragState.dragPreview.Position = UDim2.new(0, gameWindowX - SLOT_SIZE/2, 0, gameWindowY - SLOT_SIZE/2)
        end
    end)
    
    -- Store connection for cleanup
    dragState.previewConnection = connection
end

function Hotbar:HighlightDropTarget(slot, highlight)
    if highlight then
        slot.stroke.Color = Color3.fromRGB(100, 255, 100) -- Green for valid drop target
        slot.stroke.Thickness = 2
    else
        -- Restore normal appearance (will be updated by UpdateDisplay)
        slot.stroke.Color = Color3.fromRGB(80, 80, 80)
        slot.stroke.Thickness = 1
    end
end

function Hotbar:DetectSlotAtMousePosition()
    -- Helper method to detect which hotbar slot the mouse is over
    local GuiService = game:GetService("GuiService")
    local mousePos = UserInputService:GetMouseLocation()
    local guiInset = GuiService:GetGuiInset()
    
    -- Convert to game window coordinates
    local gameWindowX = mousePos.X - guiInset.X
    local gameWindowY = mousePos.Y - guiInset.Y
    
    local guiObjects = playerGui:GetGuiObjectsAtPosition(gameWindowX, gameWindowY)
    
    -- Look for hotbar slot elements
    for _, gui in ipairs(guiObjects) do
        -- Skip the drag preview frame
        if gui.Name ~= "DragPreview" then
            local current = gui
            while current do
                -- Check if this is a hotbar slot frame
                if current.Name and string.match(current.Name, "^Slot%d+$") then
                    -- Extract slot number from name (e.g., "Slot2" -> 2)
                    local slotNumber = tonumber(string.match(current.Name, "%d+"))
                    if slotNumber and slots[slotNumber] then
                        print("[HOTBAR DEBUG] Detected hotbar slot at mouse position:", slotNumber)
                        return slots[slotNumber]
                    end
                end
                
                -- Check if this is a drag button inside a slot
                if current.Name == "DragButton" and current.Parent then
                    local slotFrame = current.Parent
                    if slotFrame.Name and string.match(slotFrame.Name, "^Slot%d+$") then
                        local slotNumber = tonumber(string.match(slotFrame.Name, "%d+"))
                        if slotNumber and slots[slotNumber] then
                            print("[HOTBAR DEBUG] Detected hotbar slot via drag button at mouse position:", slotNumber)
                            return slots[slotNumber]
                        end
                    end
                end
                
                current = current.Parent
            end
        end
    end
    
    return nil
end

function Hotbar:CompleteDrag(targetSlot)
    if not dragState.isDragging or not dragState.draggedSlot then
        return
    end
    
    local sourceSlot = dragState.draggedSlot
    
    -- If no target slot provided, try to detect one at mouse position
    if not targetSlot then
        targetSlot = self:DetectSlotAtMousePosition()
    end
    
    -- Swap only if a valid target slot was found and it's different from source
    if targetSlot and sourceSlot ~= targetSlot then
        self:SwapSlots(sourceSlot.slotNumber, targetSlot.slotNumber)
    end
    
    -- First clean up drag visuals so the preview frame no longer blocks hit-testing
    self:CleanupDrag()

    -- Now detect if the mouse is over an armour slot
    local GuiService = game:GetService("GuiService")
    local mousePos = UserInputService:GetMouseLocation()
    local guiInset = GuiService:GetGuiInset()
    
    -- Convert to game window coordinates
    local gameWindowX = mousePos.X - guiInset.X
    local gameWindowY = mousePos.Y - guiInset.Y
    
    local guiObjects = playerGui:GetGuiObjectsAtPosition(gameWindowX, gameWindowY)
    local detectedArmorSlot
    for _, gui in ipairs(guiObjects) do
        -- Skip the hotbar preview frame if it somehow survived
        if gui.Name ~= "DragPreview" then
            local current = gui
            while current do
                local slotType = current:GetAttribute("ArmorSlotType")
                if slotType then
                    detectedArmorSlot = slotType
                    break
                end
                current = current.Parent
            end
            if detectedArmorSlot then break end
        end
    end

    if detectedArmorSlot and _G.ArmorSystem then
        _G.ArmorSystem:EquipFromInventorySlot(sourceSlot.slotNumber, detectedArmorSlot)
    end
end

function Hotbar:SwapSlots(slot1, slot2)
    -- Request slot swap from inventory system (preserves equipped item)
    if _G.InventorySystem then
        _G.InventorySystem:SwapSlots(slot1, slot2)
    end
end

function Hotbar:CleanupDrag()
    -- Remove drag preview
    if dragState.dragPreview then
        dragState.dragPreview:Destroy()
        dragState.dragPreview = nil
    end
    
    -- Disconnect mouse movement connection
    if dragState.previewConnection then
        dragState.previewConnection:Disconnect()
        dragState.previewConnection = nil
    end
    
    -- Reset drag state
    dragState.isDragging = false
    dragState.draggedSlot = nil
    dragState.originalPosition = nil
    
    -- Force UI update to restore normal appearance
    if _G.InventorySystem then
        local inventory = _G.InventorySystem:GetInventory()
        local equippedSlot = _G.InventorySystem:GetEquippedSlot()
        self:UpdateDisplay(inventory, equippedSlot)
    end
end

-- ENHANCED: Handle global mouse up to complete drag even if mouse leaves slot (with connection tracking)
globalConnections.globalMouseUp = UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and dragState.isDragging then
        -- Complete drag without a specific hotbar target; will still attempt armor detection
        Hotbar:CompleteDrag(nil)
    end
end)

function Hotbar:UpdateDisplay(inventory, equippedSlot)
    -- Update all slots
    for i = 1, SLOT_COUNT do
        local slot = slots[i]
        local inventoryItem = inventory[i]
        
        if not slot then
            warn("Slot", i, "is nil in slots array!")
            continue
        end
        
        if inventoryItem then
            -- Slot has item - show full item name
            slot.icon.Text = inventoryItem.itemName or "Unknown"
            slot.isEmpty = false
        else
            -- Slot is empty
            slot.icon.Text = ""
            slot.isEmpty = true
        end
        
        -- Update equipped/hovered indicator
        if equippedSlot == i or hoveredSlotIndex == i then
            slot.stroke.Color = Color3.fromRGB(220, 220, 220) -- Slightly gray outline
            slot.stroke.Thickness = 2 -- Slightly thicker outline
            slot.overlay.BackgroundTransparency = 0.93 -- Even less bright overlay
        else
            slot.stroke.Color = Color3.fromRGB(80, 80, 80)
            slot.stroke.Thickness = 1
            slot.overlay.BackgroundTransparency = 1 -- Hide overlay
        end
    end
end

function Hotbar:SetSlotCount(newCount)
    SLOT_COUNT = newCount
    -- Recreate UI with new slot count
    if screenGui then
        screenGui:Destroy()
    end
    slots = {}
    self:CreateHotbarUI()
end

function Hotbar:SetSlotSize(newSize)
    SLOT_SIZE = newSize
    -- Recreate UI with new slot size
    if screenGui then
        screenGui:Destroy()
    end
    slots = {}
    self:CreateHotbarUI()
end

function Hotbar:GetSlotCount()
    return SLOT_COUNT
end

-- ENHANCED: Add cleanup method for connection management
function Hotbar:Cleanup()
    -- Clean up global connections
    for connectionName, connection in pairs(globalConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    globalConnections = {}
    
    -- Clean up drag state
    if dragState.previewConnection then
        dragState.previewConnection:Disconnect()
        dragState.previewConnection = nil
    end
    
    if dragState.dragPreview then
        dragState.dragPreview:Destroy()
        dragState.dragPreview = nil
    end
    
    -- Clear drag state
    dragState.isDragging = false
    dragState.draggedSlot = nil
    dragState.originalPosition = nil
    
    -- Clear hoveredSlotIndex
    hoveredSlotIndex = nil

    -- Clean up UI
    if screenGui then
        screenGui:Destroy()
        screenGui = nil
    end
    
    -- Clear slots
    slots = {}
end

-- Add this after Hotbar:Initialize()
local ArmorMenu = require(script.Parent.ArmorMenu)
local originalShow = ArmorMenu.Show
function ArmorMenu:Show(...)
    -- Add blur effect
    if not Lighting:FindFirstChild("MenuBlur") then
        local blur = Instance.new("BlurEffect")
        blur.Name = "MenuBlur"
        blur.Size = 18
        blur.Parent = Lighting
    end
    return originalShow(self, ...)
end

local originalHide = ArmorMenu.Hide
function ArmorMenu:Hide(...)
    -- Remove blur effect
    local blur = Lighting:FindFirstChild("MenuBlur")
    if blur then
        blur:Destroy()
    end
    return originalHide(self, ...)
end

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        if ArmorMenu:IsVisible() then
            local mousePos = input.Position
            local found = nil
            for i, slot in pairs(slots) do
                if slot.frame.AbsolutePosition and slot.frame.AbsoluteSize then
                    local pos = slot.frame.AbsolutePosition
                    local size = slot.frame.AbsoluteSize
                    if mousePos.X >= pos.X and mousePos.X <= pos.X + size.X and
                       mousePos.Y >= pos.Y and mousePos.Y <= pos.Y + size.Y then
                        found = i
                        break
                    end
                end
            end
            if hoveredSlotIndex ~= found then
                hoveredSlotIndex = found
                Hotbar:UpdateDisplay(_G.InventorySystem and _G.InventorySystem:GetInventory() or {}, _G.InventorySystem and _G.InventorySystem:GetEquippedSlot() or nil)
            end
        else
            if hoveredSlotIndex ~= nil then
                hoveredSlotIndex = nil
                Hotbar:UpdateDisplay(_G.InventorySystem and _G.InventorySystem:GetInventory() or {}, _G.InventorySystem and _G.InventorySystem:GetEquippedSlot() or nil)
            end
        end
    end
end)

return Hotbar ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="132">
            <Properties>
              <string name="Name">ItemNameDisplay</string>
              <string name="Source"><![CDATA[-- UI component for displaying item names on hover
local ItemNameDisplay = {}

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Create the GUI elements
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ItemNameDisplay"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local nameLabel = Instance.new("TextLabel")
nameLabel.Name = "NameLabel"
nameLabel.Size = UDim2.new(0, 200, 0, 30)
nameLabel.Position = UDim2.new(0, 0, 0, 0)
nameLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
nameLabel.BackgroundTransparency = 0.3
nameLabel.BorderSizePixel = 0
nameLabel.Text = ""
nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
nameLabel.TextSize = 18
nameLabel.TextStrokeTransparency = 0
nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
nameLabel.Font = Enum.Font.SourceSansBold
nameLabel.Visible = false
nameLabel.Parent = screenGui

-- Add corner rounding
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 6)
corner.Parent = nameLabel

-- Tween info for smooth animations
local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)

function ItemNameDisplay:ShowName(itemName, mousePosition)
    -- Set the text
    nameLabel.Text = itemName
    
    -- Position near mouse with offset
    local offset = Vector2.new(10, -35)
    nameLabel.Position = UDim2.new(0, mousePosition.X + offset.X, 0, mousePosition.Y + offset.Y)
    
    -- Show with tween
    nameLabel.Visible = true
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextTransparency = 1
    
    local showTween = TweenService:Create(nameLabel, tweenInfo, {
        BackgroundTransparency = 0.3,
        TextTransparency = 0
    })
    showTween:Play()
end

function ItemNameDisplay:HideName()
    -- Hide with tween
    local hideTween = TweenService:Create(nameLabel, tweenInfo, {
        BackgroundTransparency = 1,
        TextTransparency = 1
    })
    
    hideTween:Play()
    hideTween.Completed:Connect(function()
        nameLabel.Visible = false
    end)
end

function ItemNameDisplay:UpdatePosition(mousePosition)
    if nameLabel.Visible then
        local offset = Vector2.new(10, -35)
        nameLabel.Position = UDim2.new(0, mousePosition.X + offset.X, 0, mousePosition.Y + offset.Y)
    end
end

function ItemNameDisplay:IsVisible()
    return nameLabel.Visible
end

return ItemNameDisplay ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="133">
            <Properties>
              <string name="Name">ItemTooltip</string>
              <string name="Source"><![CDATA[-- Enhanced tooltip UI component for displaying item information on hover
local ItemTooltip = {}

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Create the GUI elements
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ItemTooltip"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

local tooltipFrame = Instance.new("Frame")
tooltipFrame.Name = "TooltipFrame"
tooltipFrame.Size = UDim2.new(0, 250, 0, 80)
tooltipFrame.Position = UDim2.new(0, 0, 0, 0)
tooltipFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
tooltipFrame.BackgroundTransparency = 0.1
tooltipFrame.BorderSizePixel = 0
tooltipFrame.Visible = false
tooltipFrame.ZIndex = 1000
tooltipFrame.Parent = screenGui

-- Add corner rounding
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = tooltipFrame

-- Add border
local stroke = Instance.new("UIStroke")
stroke.Color = Color3.fromRGB(100, 100, 100)
stroke.Thickness = 1
stroke.Parent = tooltipFrame

-- Title label (item name)
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "TitleLabel"
titleLabel.Size = UDim2.new(1, -16, 0, 24)
titleLabel.Position = UDim2.new(0, 8, 0, 8)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = ""
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 16
titleLabel.TextStrokeTransparency = 0
titleLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextYAlignment = Enum.TextYAlignment.Top
titleLabel.Parent = tooltipFrame

-- Description label
local descriptionLabel = Instance.new("TextLabel")
descriptionLabel.Name = "DescriptionLabel"
descriptionLabel.Size = UDim2.new(1, -16, 1, -40)
descriptionLabel.Position = UDim2.new(0, 8, 0, 32)
descriptionLabel.BackgroundTransparency = 1
descriptionLabel.Text = ""
descriptionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
descriptionLabel.TextSize = 12
descriptionLabel.TextStrokeTransparency = 0
descriptionLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
descriptionLabel.Font = Enum.Font.SourceSans
descriptionLabel.TextXAlignment = Enum.TextXAlignment.Left
descriptionLabel.TextYAlignment = Enum.TextYAlignment.Top
descriptionLabel.TextWrapped = true
descriptionLabel.Parent = tooltipFrame

-- Tween info for smooth animations
local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)

function ItemTooltip:ShowTooltip(itemName, itemDescription, mousePosition)
    -- Set the text
    titleLabel.Text = itemName or "Unknown Item"
    descriptionLabel.Text = itemDescription or "No description available."
    
    -- Calculate text size and adjust frame size
    local titleSize = TextService:GetTextSize(titleLabel.Text, titleLabel.TextSize, titleLabel.Font, Vector2.new(234, math.huge))
    local descSize = TextService:GetTextSize(descriptionLabel.Text, descriptionLabel.TextSize, descriptionLabel.Font, Vector2.new(234, math.huge))
    
    local totalHeight = math.max(80, titleSize.Y + descSize.Y + 24)
    tooltipFrame.Size = UDim2.new(0, 250, 0, totalHeight)
    
    -- Position near mouse with offset and screen boundary checking
    local offset = Vector2.new(15, -totalHeight - 10)
    local screenSize = workspace.CurrentCamera.ViewportSize
    
    local posX = math.clamp(mousePosition.X + offset.X, 0, screenSize.X - 250)
    local posY = math.clamp(mousePosition.Y + offset.Y, 0, screenSize.Y - totalHeight)
    
    tooltipFrame.Position = UDim2.new(0, posX, 0, posY)
    
    -- Show with tween
    tooltipFrame.Visible = true
    tooltipFrame.BackgroundTransparency = 1
    titleLabel.TextTransparency = 1
    descriptionLabel.TextTransparency = 1
    stroke.Transparency = 1
    
    local showTween = TweenService:Create(tooltipFrame, tweenInfo, {
        BackgroundTransparency = 0.1
    })
    local titleTween = TweenService:Create(titleLabel, tweenInfo, {
        TextTransparency = 0
    })
    local descTween = TweenService:Create(descriptionLabel, tweenInfo, {
        TextTransparency = 0
    })
    local strokeTween = TweenService:Create(stroke, tweenInfo, {
        Transparency = 0
    })
    
    showTween:Play()
    titleTween:Play()
    descTween:Play()
    strokeTween:Play()
end

function ItemTooltip:HideTooltip()
    -- Hide with tween
    local hideTween = TweenService:Create(tooltipFrame, tweenInfo, {
        BackgroundTransparency = 1
    })
    local titleTween = TweenService:Create(titleLabel, tweenInfo, {
        TextTransparency = 1
    })
    local descTween = TweenService:Create(descriptionLabel, tweenInfo, {
        TextTransparency = 1
    })
    local strokeTween = TweenService:Create(stroke, tweenInfo, {
        Transparency = 1
    })
    
    hideTween:Play()
    titleTween:Play()
    descTween:Play()
    strokeTween:Play()
    
    hideTween.Completed:Connect(function()
        tooltipFrame.Visible = false
    end)
end

function ItemTooltip:UpdatePosition(mousePosition)
    if tooltipFrame.Visible then
        local offset = Vector2.new(15, -tooltipFrame.AbsoluteSize.Y - 10)
        local screenSize = workspace.CurrentCamera.ViewportSize
        
        local posX = math.clamp(mousePosition.X + offset.X, 0, screenSize.X - tooltipFrame.AbsoluteSize.X)
        local posY = math.clamp(mousePosition.Y + offset.Y, 0, screenSize.Y - tooltipFrame.AbsoluteSize.Y)
        
        tooltipFrame.Position = UDim2.new(0, posX, 0, posY)
    end
end

function ItemTooltip:IsVisible()
    return tooltipFrame.Visible
end

return ItemTooltip ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="134">
            <Properties>
              <string name="Name">SpectateUI</string>
              <string name="Source"><![CDATA[local SpectateUI = {}

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

-- UI Elements
local screenGui = nil
local frm_Spectate = nil
local BTN_Next = nil
local BTN_Previous = nil
local TXT_Player = nil
local BTN_Respawn = nil

-- Spectate System Variables
local WatchablePlayers = {}
local WatchIndex = 1
local DeathConnection = nil
local RespawnConnection = nil
local CharDeathConnection = nil

-- Cached player list for performance
local CachedAlivePlayers = {}

-- Helper function to check if a player is alive and watchable
local function isPlayerWatchable(p)
    return p.UserId ~= player.UserId and p.Character and p.Character:FindFirstChildOfClass("Humanoid") and p.Character:FindFirstChildOfClass("Humanoid").Health > 0
end

-- Update the cached player list
local function updateCachedPlayerList()
    CachedAlivePlayers = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if isPlayerWatchable(p) then
            table.insert(CachedAlivePlayers, p)
        end
    end
end

-- Helper: Clean up UI and camera
local function cleanupSpectate()
    print("[SpectateUI] cleanupSpectate called")
    
    if DeathConnection then
        DeathConnection:Disconnect()
        DeathConnection = nil
    end
    if RespawnConnection then
        RespawnConnection:Disconnect()
        RespawnConnection = nil
    end
    if CharDeathConnection then
        CharDeathConnection:Disconnect()
        CharDeathConnection = nil
    end
    if screenGui then
        screenGui:Destroy()
        screenGui = nil
        frm_Spectate = nil
        BTN_Next = nil
        BTN_Previous = nil
        TXT_Player = nil
        BTN_Respawn = nil
    end
    -- Restore limb CanCollide to false on respawn
    local character = player.Character or player.CharacterAdded:Wait()
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and (part.Name:find("Arm") or part.Name:find("Leg") or part.Name == "Torso" or part.Name == "Head") then
            part.CanCollide = false
        end
    end
    
    -- Let CameraSystem handle all camera restoration
    if _G.CameraSystem then
        print("[SpectateUI] Calling CameraSystem:ExitSpectateMode()")
        _G.CameraSystem:ExitSpectateMode()
    end
    
    print("[SpectateUI] cleanupSpectate completed")
end

function SpectateUI:WatchPlayer(index)
    if DeathConnection then
        DeathConnection:Disconnect()
        DeathConnection = nil
    end
    
    -- Use cached player list instead of scanning all players
    WatchablePlayers = CachedAlivePlayers
    
    if #WatchablePlayers == 0 then
        TXT_Player.Text = "No players alive"
        -- Let CameraSystem handle camera subject
        if _G.CameraSystem then
            _G.CameraSystem:SetSpectateTarget(nil)
        end
        return
    end
    if index > #WatchablePlayers then
        WatchIndex = 1
    elseif index < 1 then
        WatchIndex = #WatchablePlayers
    else
        WatchIndex = index
    end
    local targetPlayer = WatchablePlayers[WatchIndex]
    if not targetPlayer or not targetPlayer.Character then
        self:WatchPlayer(1)
        return
    end
    TXT_Player.Text = targetPlayer.Name
    local targetCharacter = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
    local targetPart = targetCharacter:FindFirstChild("HumanoidRootPart") or targetCharacter:FindFirstChild("Head") or targetCharacter:FindFirstChild("Torso")
    if not targetPart then
        self:WatchPlayer(WatchIndex + 1)
        return
    end
    local targetHumanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
    
    -- Let CameraSystem handle all camera operations
    if _G.CameraSystem then
        _G.CameraSystem:SetSpectateTarget(targetPart)
    end
    
    DeathConnection = targetHumanoid.Died:Connect(function()
        self:WatchPlayer(WatchIndex)
    end)
end

local function createSpectateUI()
    if screenGui then return end
    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "SpectateUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = playerGui

    frm_Spectate = Instance.new("Frame")
    frm_Spectate.Name = "frm_Spectate"
    frm_Spectate.Size = UDim2.new(0, 320, 0, 120)
    frm_Spectate.Position = UDim2.new(0, 30, 0, 170)
    frm_Spectate.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    frm_Spectate.Parent = screenGui

    BTN_Next = Instance.new("TextButton")
    BTN_Next.Name = "BTN_Next"
    BTN_Next.Size = UDim2.new(0, 80, 0, 40)
    BTN_Next.Position = UDim2.new(1, -90, 0.5, -50)
    BTN_Next.AnchorPoint = Vector2.new(0, 0)
    BTN_Next.BackgroundColor3 = Color3.fromRGB(60, 60, 90)
    BTN_Next.TextColor3 = Color3.fromRGB(255, 255, 255)
    BTN_Next.Text = ">>"
    BTN_Next.TextSize = 22
    BTN_Next.Font = Enum.Font.GothamBold
    BTN_Next.Parent = frm_Spectate

    BTN_Previous = Instance.new("TextButton")
    BTN_Previous.Name = "BTN_Previous"
    BTN_Previous.Size = UDim2.new(0, 80, 0, 40)
    BTN_Previous.Position = UDim2.new(0, 10, 0.5, -50)
    BTN_Previous.AnchorPoint = Vector2.new(0, 0)
    BTN_Previous.BackgroundColor3 = Color3.fromRGB(60, 60, 90)
    BTN_Previous.TextColor3 = Color3.fromRGB(255, 255, 255)
    BTN_Previous.Text = "<<"
    BTN_Previous.TextSize = 22
    BTN_Previous.Font = Enum.Font.GothamBold
    BTN_Previous.Parent = frm_Spectate

    TXT_Player = Instance.new("TextLabel")
    TXT_Player.Name = "TXT_Player"
    TXT_Player.Size = UDim2.new(0, 120, 0, 40)
    TXT_Player.Position = UDim2.new(0.5, -60, 0.5, -50)
    TXT_Player.BackgroundTransparency = 1
    TXT_Player.TextColor3 = Color3.fromRGB(255, 255, 255)
    TXT_Player.TextStrokeTransparency = 0.5
    TXT_Player.Text = "PlayerName"
    TXT_Player.TextSize = 20
    TXT_Player.Font = Enum.Font.GothamBold
    TXT_Player.Parent = frm_Spectate

    BTN_Respawn = Instance.new("TextButton")
    BTN_Respawn.Name = "BTN_Respawn"
    BTN_Respawn.Size = UDim2.new(0, 180, 0, 40)
    BTN_Respawn.Position = UDim2.new(0.5, -90, 1, -50)
    BTN_Respawn.BackgroundColor3 = Color3.fromRGB(80, 120, 60)
    BTN_Respawn.TextColor3 = Color3.fromRGB(255, 255, 255)
    BTN_Respawn.Text = "Respawn"
    BTN_Respawn.TextSize = 22
    BTN_Respawn.Font = Enum.Font.GothamBold
    BTN_Respawn.Parent = frm_Spectate

    BTN_Next.Activated:Connect(function()
        SpectateUI:WatchPlayer(WatchIndex + 1)
    end)
    BTN_Previous.Activated:Connect(function()
        SpectateUI:WatchPlayer(WatchIndex - 1)
    end)
    BTN_Respawn.Activated:Connect(function()
        local event = ReplicatedStorage:FindFirstChild("RequestRespawn")
        if event then
            event:FireServer()
        end
    end)
end

function SpectateUI:Initialize()
    -- Initialize cached player list
    updateCachedPlayerList()
    
    -- Listen for player join/leave to update cache
    Players.PlayerAdded:Connect(function(joinedPlayer)
        task.wait(0.1) -- Wait for character to load
        updateCachedPlayerList()
    end)
    
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        updateCachedPlayerList()
    end)
    
    -- Listen for the 'Dead' tag on the local player
    local function onDeadTagAdded(inst)
        if inst == player then
            createSpectateUI()
            -- Set all limb CanCollide to true since EvaluateStateMachine is off
            local character = player.Character or player.CharacterAdded:Wait()
            for _, part in ipairs(character:GetChildren()) do
                if part:IsA("BasePart") and (part.Name:find("Arm") or part.Name:find("Leg") or part.Name == "Torso" or part.Name == "Head") then
                    part.CanCollide = true
                end
            end
            
            -- Let CameraSystem handle all camera operations
            if _G.CameraSystem then
                _G.CameraSystem:EnterSpectateMode()
            end
            
            WatchIndex = 1
            SpectateUI:WatchPlayer(WatchIndex)
            if RespawnConnection then RespawnConnection:Disconnect() end
            RespawnConnection = player.CharacterAdded:Connect(function(newChar)
                cleanupSpectate()
            end)
        end
    end
    local function onDeadTagRemoved(inst)
        if inst == player then
            cleanupSpectate()
        end
    end
    -- Connect tag listeners
    CollectionService:GetInstanceAddedSignal("Dead"):Connect(onDeadTagAdded)
    CollectionService:GetInstanceRemovedSignal("Dead"):Connect(onDeadTagRemoved)
    -- If the player already has the tag (e.g., on join), trigger immediately
    if CollectionService:HasTag(player, "Dead") then
        onDeadTagAdded(player)
    end
end

return SpectateUI ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="135">
            <Properties>
              <string name="Name">StatsPanel</string>
              <string name="Source"><![CDATA[local TweenService = game:GetService("TweenService")

local StatsPanel = {}
StatsPanel.__index = StatsPanel

local STATS_FRAME_WIDTH = 400
local STATS_FRAME_HEIGHT = 180
local STATS_FRAME_Y = 0.25
local STATS_ANIM_TIME = 0.35
local STATS_ANIM_TIME_OUT = 0.12 -- Faster hide
local STATS_FRAME_X_HIDDEN = -STATS_FRAME_WIDTH
local STATS_FRAME_X_VISIBLE = 40
local STAT_LABEL_X_HIDDEN = -STATS_FRAME_WIDTH
local STAT_LABEL_X_VISIBLE = 0
local WAVE_DELAY = 0.15

function StatsPanel.new(parent)
	local self = setmetatable({}, StatsPanel)

	-- Main frame
	self.frame = Instance.new("Frame")
	self.frame.Name = "StatsFrame"
	self.frame.Size = UDim2.new(0, STATS_FRAME_WIDTH, 0, STATS_FRAME_HEIGHT)
	self.frame.Position = UDim2.new(0, STATS_FRAME_X_HIDDEN, 0.08, 0)
	self.frame.BackgroundTransparency = 1
	self.frame.Visible = false
	self.frame.Parent = parent

	-- Title
	self.title = Instance.new("TextLabel")
	self.title.Name = "RunStatsTitle"
	self.title.Size = UDim2.new(1, 0, 0, 48)
	self.title.Position = UDim2.new(0, 0, 0, 0)
	self.title.BackgroundTransparency = 1
	self.title.TextColor3 = Color3.fromRGB(255, 255, 255)
	self.title.TextStrokeTransparency = 0.2
	self.title.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	self.title.TextSize = 56 -- Larger than stats
	self.title.Font = Enum.Font.GothamBold
	self.title.TextXAlignment = Enum.TextXAlignment.Left
	self.title.TextYAlignment = Enum.TextYAlignment.Top
	self.title.Text = "Run Stats:"
	self.title.Parent = self.frame

	-- Days Survived label
	self.daysLabel = Instance.new("TextLabel")
	self.daysLabel.Name = "DaysLabel"
	self.daysLabel.Size = UDim2.new(1, 0, 0, 56)
	self.daysLabel.Position = UDim2.new(0, STAT_LABEL_X_HIDDEN, 0, 48)
	self.daysLabel.BackgroundTransparency = 1
	self.daysLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	self.daysLabel.TextStrokeTransparency = 0.2
	self.daysLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	self.daysLabel.TextSize = 40
	self.daysLabel.Font = Enum.Font.GothamBold
	self.daysLabel.TextXAlignment = Enum.TextXAlignment.Left
	self.daysLabel.TextYAlignment = Enum.TextYAlignment.Top
	self.daysLabel.Text = "Days Survived: 1"
	self.daysLabel.Parent = self.frame

	-- Playtime label
	self.playtimeLabel = Instance.new("TextLabel")
	self.playtimeLabel.Name = "PlaytimeLabel"
	self.playtimeLabel.Size = UDim2.new(1, 0, 0, 56)
	self.playtimeLabel.Position = UDim2.new(0, STAT_LABEL_X_HIDDEN, 0, 104)
	self.playtimeLabel.BackgroundTransparency = 1
	self.playtimeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	self.playtimeLabel.TextStrokeTransparency = 0.2
	self.playtimeLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	self.playtimeLabel.TextSize = 40
	self.playtimeLabel.Font = Enum.Font.GothamBold
	self.playtimeLabel.TextXAlignment = Enum.TextXAlignment.Left
	self.playtimeLabel.TextYAlignment = Enum.TextYAlignment.Top
	self.playtimeLabel.Text = "Playtime: 00:00"
	self.playtimeLabel.Parent = self.frame

	self.statsTween = nil
	self.labelTweens = {}
	return self
end

function StatsPanel:SetStats(daysSurvived, playtime)
	self.daysLabel.Text = string.format("Days Survived: %d", daysSurvived)
	self.playtimeLabel.Text = string.format("Playtime: %s", self:FormatPlaytime(playtime))
end

function StatsPanel:FormatPlaytime(seconds)
	local mins = math.floor(seconds / 60)
	local secs = math.floor(seconds % 60)
	return string.format("%02d:%02d", mins, secs)
end

function StatsPanel:Show()
	self.frame.Visible = true
	if self.statsTween then self.statsTween:Cancel() end
	self.frame.Position = UDim2.new(0, STATS_FRAME_X_HIDDEN, 0.08, 0)
	self.statsTween = TweenService:Create(self.frame, TweenInfo.new(STATS_ANIM_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0, STATS_FRAME_X_VISIBLE, 0.08, 0)})
	self.statsTween:Play()

	-- Wave in labels with bounce/spring
	self.daysLabel.Position = UDim2.new(0, STAT_LABEL_X_HIDDEN, 0, 48)
	self.playtimeLabel.Position = UDim2.new(0, STAT_LABEL_X_HIDDEN, 0, 104)
	if self.labelTweens.days then self.labelTweens.days:Cancel() end
	if self.labelTweens.playtime then self.labelTweens.playtime:Cancel() end
	self.labelTweens.days = nil
	self.labelTweens.playtime = nil

	task.delay(0.05, function()
		self.labelTweens.days = TweenService:Create(self.daysLabel, TweenInfo.new(STATS_ANIM_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.new(0, STAT_LABEL_X_VISIBLE, 0, 48)})
		self.labelTweens.days:Play()
	end)
	task.delay(WAVE_DELAY + 0.05, function()
		self.labelTweens.playtime = TweenService:Create(self.playtimeLabel, TweenInfo.new(STATS_ANIM_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.new(0, STAT_LABEL_X_VISIBLE, 0, 104)})
		self.labelTweens.playtime:Play()
	end)
end

function StatsPanel:Hide()
	if self.statsTween then self.statsTween:Cancel() end
	self.statsTween = TweenService:Create(self.frame, TweenInfo.new(STATS_ANIM_TIME_OUT, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = UDim2.new(0, STATS_FRAME_X_HIDDEN, 0.08, 0)})
	self.statsTween:Play()

	-- Wave out labels (faster, together)
	if self.labelTweens.days then self.labelTweens.days:Cancel() end
	if self.labelTweens.playtime then self.labelTweens.playtime:Cancel() end
	self.labelTweens.days = TweenService:Create(self.daysLabel, TweenInfo.new(STATS_ANIM_TIME_OUT, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = UDim2.new(0, STAT_LABEL_X_HIDDEN, 0, 48)})
	self.labelTweens.playtime = TweenService:Create(self.playtimeLabel, TweenInfo.new(STATS_ANIM_TIME_OUT, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = UDim2.new(0, STAT_LABEL_X_HIDDEN, 0, 104)})
	self.labelTweens.days:Play()
	self.labelTweens.playtime:Play()
	task.delay(STATS_ANIM_TIME_OUT, function()
		self.frame.Visible = false
	end)
end

return StatsPanel ]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="136">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
      <bool name="NeedsPivotMigration">false</bool>
    </Properties>
    <Item class="Part" referent="137">
      <Properties>
        <string name="Name">Baseplate</string>
        <bool name="Anchored">true</bool>
        <Color3uint8 name="Color3uint8">6512483</Color3uint8>
        <bool name="Locked">true</bool>
        <Vector3 name="Position">
          <X>0</X>
          <Y>-10</Y>
          <Z>0</Z>
        </Vector3>
        <Vector3 name="size">
          <X>512</X>
          <Y>20</Y>
          <Z>512</Z>
        </Vector3>
      </Properties>
    </Item>
  </Item>
</roblox>